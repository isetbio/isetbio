function coneMosaicView(app, mode)
    switch (mode)
        case 'initialize'
            initializeConeMosaicView(app);
        case 'update'
            updateConeMosaicViewWithNewData(app);
    end
end

function initializeConeMosaicView(app)

    set(app.coneMosaicView, 'LineWidth', 0.5);
    box(app.coneMosaicView, 'off');
    
    % Do not show the interactions toolbax
    app.coneMosaicView.Toolbar.Visible = 'off';
            
    % Only allow zooming
    app.coneMosaicView.Interactions = [panInteraction zoomInteraction];
            
    % Add listener to zoom-events
    addlistener(app.coneMosaicView, {'XLim', 'YLim'}, 'PostSet', @app.handleConeMosaicViewZoomEvent);
end

function updateConeMosaicViewWithNewData(app)

    if (~isempty(app.coneMosaicViewXLimsDegs))
        switch (app.viewModes.coneMosaicVisualizationDomain)
           case 'degrees'
                domainVisualizationLimits(1:2) = app.coneMosaicViewXLimsDegs;
                domainVisualizationLimits(3:4) = app.coneMosaicViewYLimsDegs;
           case 'microns'
                domainVisualizationLimits(1:2) = app.coneMosaicViewXLimsMicrons;
                domainVisualizationLimits(3:4) = app.coneMosaicViewYLimsMicrons;
        end
    else
        domainVisualizationLimits = [];
    end
    
    mosaicVisualizationView = 'retinal view';
    conesNumThresholdForShowingProgressBar = 10000;
     
    if (~isempty(app.components.coneMosaic.coneRFpositionsDegs))

        conesNum = size(app.components.coneMosaic.coneRFpositionsMicrons,1);
        if (conesNum >  conesNumThresholdForShowingProgressBar)
            % Open progressbar
            dialogBox = uiprogressdlg(app.mainView,'Title','Please Wait',...
                 'Message', sprintf('Rendering cone mosaic with %d cones...', conesNum));
            dialogBox.Value = 0.2; 
        end
        
        switch (app.viewModes.coneMosaic)
            case {'cone types', 'cones+retinal image'}

                % Check for overlapping cones. The lower this number the 
                % less strict the overap becomes.
                maxSeparationForDeclaringOverlap = 0.6;
                [~, overlappingConeIndices] = cMosaic.identifyOverlappingRFs([],[], ...
                    app.components.coneMosaic.coneRFpositionsMicrons, ...
                    app.components.coneMosaic.coneRFspacingsMicrons, ...
                    maxSeparationForDeclaringOverlap);

                app.components.coneMosaic.visualize(...
                    'figureHandle', app.mainView, ...
                    'axesHandle', app.coneMosaicView, ...
                    'visualizationView', mosaicVisualizationView, ...
                    'labelCones', true, ...
                    'outlinedConesWithIndices', overlappingConeIndices, ...
                    'crossHairsOnFovea', true, ...
                    'crossHairsColor', [1 1 1], ...
                    'visualizedConeAperture', 'geometricArea', ...
                    'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                    'domainVisualizationLimits', domainVisualizationLimits, ...
                    'noYLabel', true, ...
                    'fontSize', 14, ...
                    'backgroundColor', [0 0 0], ...  
                    'plotTitle',  ' ');
               
                if (strcmp(app.viewModes.coneMosaic, 'cones+retinal image'))
                    hold(app.coneMosaicView, 'on');
                    [imPlot, ~, ~, mask] = renderRetinalImageOnAxes(app);
                    imPlot.AlphaData = 0.85*mask;
                    hold(app.coneMosaicView, 'off');
                end
                
            case 'activation'
                colorbarTickPostfix = 'R*';
                cMapForActivation = brewermap(1024, '*spectral');
                if (strcmp(app.viewModes.coneMosaicActivationType, 'noise-free responses'))
                    activationRange = prctile(app.products.noiseFreeConeMosaicActivation(:), [1 99]);
                    app.components.coneMosaic.visualize(...
                        'figureHandle', app.mainView, ...
                        'axesHandle', app.coneMosaicView, ...
                        'visualizationView', mosaicVisualizationView, ...
                        'activation', app.products.noiseFreeConeMosaicActivation, ...  % noise-free activation
                        'activationRange', [], ...
                        'activationColorMap', cMapForActivation, ...
                        'labelCones', ~true, ...
                        'colorBarTickLabelPostFix', colorbarTickPostfix, ...
                        'verticalActivationColorBarInside', true, ...
                        'crossHairsOnFovea', true, ...
                        'crossHairsColor', [1 1 1], ...
                        'visualizedConeAperture', 'geometricArea', ...
                        'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'noYLabel', true, ...
                        'fontSize', 14, ...
                        'backgroundColor', [0 0 0], ...  
                        'plotTitle',  ' ');
                else
                    instancesNum = size(app.products.noisyConeMosaicActivationInstances,1);
                    activationRange = prctile(app.products.noisyConeMosaicActivationInstances(:), [1 99]);
                    app.coneMosaicViewModeKnob.Enable = 'off';
                    app.coneMosaicActivationTypeSwitch.Enable = 'off';
                    app.coneMosaicVisualizationDomainSwitch.Enable = 'off';
                    for instanceNo = 1:instancesNum
                        app.components.coneMosaic.visualize(...
                        'figureHandle', app.mainView, ...
                        'axesHandle', app.coneMosaicView, ...
                        'visualizationView', mosaicVisualizationView, ...
                        'activation', app.products.noisyConeMosaicActivationInstances(instanceNo,:,:), ...  % noisy activation instances
                        'activationRange', activationRange, ...
                        'activationColorMap', cMapForActivation, ...
                        'labelCones', ~true, ...
                        'colorBarTickLabelPostFix', colorbarTickPostfix, ...
                        'verticalActivationColorBarInside', true, ...
                        'crossHairsOnFovea', true, ...
                        'crossHairsColor', [1 1 1], ...
                        'visualizedConeAperture', 'geometricArea', ...
                        'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'noYLabel', true, ...
                        'fontSize', 14, ...
                        'backgroundColor', [0 0 0], ...  
                        'plotTitle',  ' ', ...
                        'textDisplay', sprintf('instance %d/%d', instanceNo, instancesNum), ...
                        'textDisplayColor', [0 1 1]);
                        drawnow;
                    end
                    app.coneMosaicViewModeKnob.Enable = 'on';
                    app.coneMosaicActivationTypeSwitch.Enable = 'on';
                    app.coneMosaicVisualizationDomainSwitch.Enable = 'on';
                end
                
            case 'modulation'
                colorbarTickPostfix = '%';
                cMapForActivation = brewermap(1024, '*greys');
                
                if (strcmp(app.viewModes.coneMosaicActivationType, 'noise-free responses'))
                    activationRange = max(abs(app.products.noiseFreeConeMosaicModulation(:)))*[-1 1];
                    app.components.coneMosaic.visualize(...
                        'figureHandle', app.mainView, ...
                        'axesHandle', app.coneMosaicView, ...
                        'visualizationView', mosaicVisualizationView, ...
                        'activation', app.products.noiseFreeConeMosaicModulation, ...  % noise-free activation
                        'activationRange', activationRange, ...
                        'activationColorMap', cMapForActivation, ...
                        'labelCones', ~true, ...
                        'colorBarTickLabelPostFix', colorbarTickPostfix, ...
                        'verticalActivationColorBarInside', true, ...
                        'crossHairsOnFovea', true, ...
                        'crossHairsColor', [1 0 0], ...
                        'visualizedConeAperture', 'geometricArea', ...
                        'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'noYLabel', true, ...
                        'fontSize', 14, ...
                        'backgroundColor', [0.5 0.5 0.5], ...  
                        'plotTitle',  ' ');
                else
                    instancesNum = size(app.products.noisyConeMosaicModulationInstances,1);
                    activationRange = max(abs(app.products.noisyConeMosaicModulationInstances(:)))*[-1 1];
                    app.coneMosaicViewModeKnob.Enable = 'off';
                    app.coneMosaicActivationTypeSwitch.Enable = 'off';
                    app.coneMosaicVisualizationDomainSwitch.Enable = 'off';
                    for instanceNo = 1:instancesNum
                        app.components.coneMosaic.visualize(...
                        'figureHandle', app.mainView, ...
                        'axesHandle', app.coneMosaicView, ...
                        'visualizationView', mosaicVisualizationView, ...
                        'activation', app.products.noisyConeMosaicModulationInstances(instanceNo,:,:), ...  % noisy activation instances
                        'activationRange', activationRange, ...
                        'activationColorMap', cMapForActivation, ...
                        'colorBarTickLabelPostFix', colorbarTickPostfix, ...
                        'verticalActivationColorBarInside', true, ...
                        'labelCones', ~true, ...
                        'crossHairsOnFovea', true, ...
                        'crossHairsColor', [1 0 0], ...
                        'visualizedConeAperture', 'geometricArea', ...
                        'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'noYLabel', true, ...
                        'fontSize', 14, ...
                        'backgroundColor', 'none', ...  
                        'plotTitle',  ' ', ...
                        'textDisplay', sprintf('instance %d/%d', instanceNo, instancesNum), ...
                        'textDisplayColor', [0 1 1]);
                        drawnow;
                    end
                    app.coneMosaicViewModeKnob.Enable = 'on';
                    app.coneMosaicActivationTypeSwitch.Enable = 'on';
                    app.coneMosaicVisualizationDomainSwitch.Enable = 'on';
                end
                
                case 'residual'
                    colorbarTickPostfix = '%';
                    cMapForActivation = brewermap(1024, '*RdBu');
                    
                    % Find cones that do not lie within the stimulus borders
                    if (app.stimParams.mosaicCenteredPosition)
                        roiStruct = struct(...
                            'units', 'degs', ...
                            'shape', 'rect', ...
                            'center', app.components.coneMosaic.eccentricityDegs, ...
                            'width',  app.stimParams.sizeDegs*0.9, ...
                            'height', app.stimParams.sizeDegs*0.9, ...
                            'rotation', 0);
                    else
                        roiStruct = struct(...
                            'units', 'degs', ...
                            'shape', 'rect', ...
                            'center', app.stimParams.positionDegs, ...
                            'width',  app.stimParams.sizeDegs(1)*0.9, ...
                            'height', app.stimParams.sizeDegs(2)*0.9, ...
                            'rotation', 0);
                    end
                    coneIndices = app.components.coneMosaic.indicesOfConesWithinROI(roiStruct);
                    activationRange = max(abs(app.products.residualConeMosaicActivation(coneIndices)))*[-1 1];
                    
                    app.components.coneMosaic.visualize(...
                        'figureHandle', app.mainView, ...
                        'axesHandle', app.coneMosaicView, ...
                        'visualizationView', mosaicVisualizationView, ...
                        'activation', app.products.residualConeMosaicActivation, ...  % residual activation
                        'activationRange', activationRange, ...
                        'activationColorMap', cMapForActivation, ...
                        'colorBarTickLabelPostFix', colorbarTickPostfix, ...
                        'verticalActivationColorBarInside', true, ...
                        'labelCones', ~true, ...
                        'crossHairsOnFovea', true, ...
                        'crossHairsColor', [1 1 1], ...
                        'visualizedConeAperture', 'geometricArea', ...
                        'domain', app.viewModes.coneMosaicVisualizationDomain, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'noYLabel', true, ...
                        'fontSize', 14, ...
                        'backgroundColor', 'none', ...  
                        'plotTitle',  ' ');
            otherwise
                error('Dont know how to interpret view mode: ''%s''.', app.viewModes.coneMosaic);
        end
        if (conesNum > conesNumThresholdForShowingProgressBar)
            close(dialogBox);
        end
    else
        cla(app.coneMosaicView)
    end
    
    
end

 function [imPlot, xSupport, ySupport, mask] = renderRetinalImageOnAxes(app)
            
    % Compute optical image for the first frame of the stimulus
    theScene = app.products.demoStimulusSceneSequence{1};
    app.components.optics = oiCompute(theScene, app.components.optics);
    
    % Get the rgb value
    rgbImage = flipud(oiGet(app.components.optics, 'rgb'));
    mask = ones(size(rgbImage,1), size(rgbImage,2));
            
    % Obtain spatial support in microns
    spatialSupportMeters = oiGet(app.components.optics, 'spatial support');
    xSupport = squeeze(spatialSupportMeters(1,1:end,1)) * 1e6;
    ySupport = squeeze(spatialSupportMeters(1:end,1,2)) * 1e6;
            
    if (strcmp(app.viewModes.coneMosaicVisualizationDomain, 'degrees'))
         % Convert spatial support in microns to degs
         %hDegs = oiGet(app.components.optics, 'hangular');
         %hMicrons = 1e6*oiGet(app.components.optics, 'height');
         %micronsPerDegree = hMicrons/hDegs;
         xSupport = xSupport / app.components.coneMosaic.micronsPerDegree;
         ySupport = ySupport / app.components.coneMosaic.micronsPerDegree;
    end
            
    % Translate to position
    if (app.stimParams.mosaicCenteredPosition)
        % Translate to mosaic center
        if (strcmp(app.viewModes.coneMosaicVisualizationDomain, 'degrees'))
            xSupport = xSupport + app.components.coneMosaic.eccentricityDegs(1);
            ySupport = ySupport + app.components.coneMosaic.eccentricityDegs(2);
        else
            xSupport = xSupport + app.components.coneMosaic.eccentricityMicrons(1);
            ySupport = ySupport + app.components.coneMosaic.eccentricityMicrons(2);
        end
    else
        % Translate to custom position
        if (strcmp(app.viewModes.coneMosaicVisualizationDomain, 'degrees'))
            xSupport = xSupport + app.stimParams.positionDegs(1);
            ySupport = ySupport + app.stimParams.positionDegs(2);
        else
            % Convert degs to microns
            if (~isempty(app.components.coneMosaic.micronsPerDegreeApproximation))
                stimPosMicrons = app.stimParams.positionDegs * app.components.coneMosaic.micronsPerDegreeApproximation;
            else
                stimPosMicrons = 1e3 * RGCmodels.Watson.convert.rhoDegsToMMs(app.stimParams.positionDegs);
            end
            xSupport = xSupport + stimPosMicrons(1);
            ySupport = ySupport + stimPosMicrons(2);
        end
    end
            
    % Render demo stimulus on the passed axes
    imPlot = image(app.coneMosaicView, xSupport, ySupport, rgbImage);
 end
        
