function performContrastSTFsAcrossDifferentChromaticities(...
            mosaicParams, varargin)

    % Get PDF directory
    [~,~,pdfDirectory] = MosaicPoolingOptimizer.resourceFileNameAndPath('pdfsDirectory', ...
        'mosaicParams', mosaicParams);

    % Ask the user what optics were used for computing the compute-ready MRGC mosaic
    fprintf('\n---> Select the optics that were used to compute the compute-ready mosaic\n');
    opticsParamsForComputeReadyMosaic = ...
        MosaicPoolingOptimizer.chooseOpticsForInputConeMosaicSTFresponses(mosaicParams);

    % Ask the user which H1 cell index was used for optimizing the RF
    % surround pooling model
    retinalRFmodelParams = MosaicPoolingOptimizer.chooseRFmodelForSurroundConePoolingOptimization(...
        mosaicParams, opticsParamsForComputeReadyMosaic);

    % Generate the filename of the compute-ready mRGCMosaic to use
    [computeReadyMosaicFileName, computeReadyMosaicResourcesDirectory] = ...
        MosaicPoolingOptimizer.resourceFileNameAndPath('computeReadyMosaic', ...
                'mosaicParams', mosaicParams, ...
                'opticsParams', opticsParamsForComputeReadyMosaic, ...
                'retinalRFmodelParams', retinalRFmodelParams);

    % Now, ask the user what optics were used for computing the mRGC mosaic STF responses, so we can obtain the corresponding mRGCMosaicSTFresponsesFileName
    fprintf('\n---> Select the optics that were used to compute the mRGC mosaic STF responses \n');
    opticsParamsForMRGCSTFs = ...
        MosaicPoolingOptimizer.chooseOpticsForInputConeMosaicSTFresponses(mosaicParams);

    % Generate filename for the computed mRGCMosaicSTF responses
    [mRGCMosaicSTFresponsesFileName, resourcesDirectory] = ...
        MosaicPoolingOptimizer.resourceFileNameAndPath('mRGCMosaicSTFresponses', ...
            'mosaicParams', mosaicParams, ...
            'opticsParams', opticsParamsForMRGCSTFs);

    % Achromatic STF responses filename
    [~, mRGCMosaicAchromaticSTFresponsesFileName] = ...
        MosaicPoolingOptimizer.chooseStimulusChromaticityForMosaicResponsesAndUpdateFileName(...
        mRGCMosaicSTFresponsesFileName, 'STFresponses', ...
        'doNotQueryUserInsteadEmployThisStimulusChromaticity', 'achromatic');

    % L-cone isolating STF responses filename
    [~, mRGCMosaicLconeIsolatingSTFresponsesFileName] = ...
        MosaicPoolingOptimizer.chooseStimulusChromaticityForMosaicResponsesAndUpdateFileName(...
        mRGCMosaicSTFresponsesFileName, 'STFresponses', ...
        'doNotQueryUserInsteadEmployThisStimulusChromaticity', 'Lcone isolating');


    % M-cone isolating STF responses filename
    [~, mRGCMosaicMconeIsolatingSTFresponsesFileName] = ...
        MosaicPoolingOptimizer.chooseStimulusChromaticityForMosaicResponsesAndUpdateFileName(...
        mRGCMosaicSTFresponsesFileName, 'STFresponses', ...
        'doNotQueryUserInsteadEmployThisStimulusChromaticity', 'Mcone isolating');



    % Retrieve indices of mRGCs along the horizontal meridian
    load(fullfile(computeReadyMosaicResourcesDirectory, computeReadyMosaicFileName), 'theComputeReadyMRGCmosaic');
    targetYdegs = 0.0;
    [~, ~, visualizedMRGCindices] = extractVisualizedConeAndRGCindices(theComputeReadyMRGCmosaic, targetYdegs);

    MosaicPoolingOptimizer.contrastVisualSTFsAcrossDifferentChromaticities(...
        fullfile(computeReadyMosaicResourcesDirectory, computeReadyMosaicFileName), ...
        fullfile(resourcesDirectory, mRGCMosaicAchromaticSTFresponsesFileName), ...
        fullfile(resourcesDirectory, mRGCMosaicLconeIsolatingSTFresponsesFileName), ...
        fullfile(resourcesDirectory, mRGCMosaicMconeIsolatingSTFresponsesFileName), ...
        opticsParamsForMRGCSTFs, ...
        'pdfDirectory', pdfDirectory, ...
        'visualizedRGCindices', visualizedMRGCindices(1:2:end), ...
        'tickSeparationArcMin', 2.0);

end


function [visualizedConeIndices, theVisualizedConeXcoords, ...
          visualizedMRGCindices, theVisualizedMRGCXcoords, theROI] = extractVisualizedConeAndRGCindices(theMRGCMosaic, targetYdegs)

    % Define an ROI
    roiHeightDegs = 0.1;
    theROI = regionOfInterest(...
        'geometryStruct', struct(...
            'units', 'degs', ...
            'shape', 'rect', ...
            'center', [theMRGCMosaic.eccentricityDegs(1) targetYdegs], ...
            'width', theMRGCMosaic.sizeDegs(1), ...
            'height', roiHeightDegs , ...
            'rotation', 0.0...
        ));

    visualizedConeIndices = theROI.indicesOfPointsInside(theMRGCMosaic.inputConeMosaic.coneRFpositionsDegs);
    visualizedMRGCindices = theROI.indicesOfPointsInside(theMRGCMosaic.rgcRFpositionsDegs);

    theVisualizedConeXcoords = squeeze(theMRGCMosaic.inputConeMosaic.coneRFpositionsDegs(visualizedConeIndices,1));
    theVisualizedMRGCXcoords = squeeze(theMRGCMosaic.rgcRFpositionsDegs(visualizedMRGCindices,1));

    [~,idx] = sort(theVisualizedConeXcoords, 'ascend');
    visualizedConeIndices = visualizedConeIndices(idx);
    % Exclude S-cones
    idx = find(theMRGCMosaic.inputConeMosaic.coneTypes(visualizedConeIndices) == cMosaic.SCONE_ID);
    [~, idx] = setdiff(visualizedConeIndices, visualizedConeIndices(idx));
    visualizedConeIndices = visualizedConeIndices(idx);
    theVisualizedConeXcoords = squeeze(theMRGCMosaic.inputConeMosaic.coneRFpositionsDegs(visualizedConeIndices,1));

    [~,idx] = sort(theVisualizedMRGCXcoords, 'ascend');
    theVisualizedMRGCXcoords = theVisualizedMRGCXcoords(idx);
    visualizedMRGCindices = visualizedMRGCindices(idx);
end
