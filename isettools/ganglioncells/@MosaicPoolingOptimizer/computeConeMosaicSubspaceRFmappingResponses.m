function [theConeMosaicSubspaceResponses, theConeMosaicNullResponses, ...
    HartleySpatialModulationPatterns, lIndices, mIndices] = ...
    computeConeMosaicSubspaceResponses(theConeMosaic, theOptics,  ...
                                           thePresentationDisplay, ...
                                           stimParams, ...
                                           stimPositionDegs, ...
                                           useParfor, ...
                                           visualizeResponses)

    % Compute the Hartley spatial patterns
    fprintf('Generating Hartley patterns\n')
    % Compute spatial modulation patterns for the Hartley set
    [HartleySpatialModulationPatterns, lIndices, mIndices] = ...
            rfMappingStimulusGenerator.HartleyModulationPatterns(...
            stimParams.omega, stimParams.stimSizeDegs, stimParams.pixelSizeDegs);


    % Generate scenes for the Hartley patterns
    fprintf('Generating scenes for the Hartley patterns\n')
    [theRFMappingStimulusScenes, theNullStimulusScene, spatialSupportDegs] = ...
            rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false);

    % Generate scenes for the inverse-polarity Hartley patterns
    fprintf('Generating scenes for the inverse polarity Hartley patterns\n');
    theInversePolarityRFMappingStimulusScenes = ...
            rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -HartleySpatialModulationPatterns, ...
                'validateScenes', false);
    
    fprintf('Done with all scene generation\n');


    % This is necessary to avoid the background being modulated when the
    % stimulus is smaller than the mosaic. This is due to the way oiCompute
    % does the padding.
    padOIwithZeros = true;
    if (padOIwithZeros)
        theOptics = oiSet(theOptics, 'pad', struct('value', 'zero photons'));
    end

    % Compute the optical image of the null scene
    theOptics  = oiCompute(theNullStimulusScene, theOptics);

    % Compute the cone mosaic null responses
    theConeMosaicNullResponses = theConeMosaic.compute(theOptics, ...
                    'padOIwithZeros', padOIwithZeros, ...
                    'opticalImagePositionDegs', stimPositionDegs, ...
                    'nTrials', 1);

    coneIndicesWithZeroNullResponse = find(theConeMosaicNullResponses== 0);
    normalizingResponses = 1./theConeMosaicNullResponses;
    normalizingResponses(coneIndicesWithZeroNullResponse) = 0;
    normalizingResponses = reshape(normalizingResponses, [1 1 numel(normalizingResponses)]);
             

    % Compute the input cone mosaic responses
    nStim = numel(theRFMappingStimulusScenes);

    % Allocate memory
    theConeMosaicSubspaceResponses = zeros(nStim, conesNum, 'single');

    if (useParfor)
         theOI = theOptics;
         parfor iFrame = 1:nStim
             % Get scene corresponding to this forward polarity of the stimulus frame
             theFrameScene = theRFMappingStimulusScenes{iFrame};

             % Compute the optical image of the frame scene
             theCurrentOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses
             noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theCurrentOI, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

             % Convert to modulation responses
             noiseFreeAbsorptionsCountForwardPolarity = ...
                (noiseFreeAbsorptionsCountForwardPolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

             % Get scene corresponding to the inverse polarity of this stimulus frame
             theFrameScene = theInversePolarityRFMappingStimulusScenes{iFrame};

             % Compute the optical image of the frame scene
             theCurrentOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses
             noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theCurrentOI, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

             % Convert to modulation responses
             noiseFreeAbsorptionsCountInversePolarity = ...
                (noiseFreeAbsorptionsCountInversePolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

             theConeMosaicSubspaceResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsCountForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsCountInversePolarity(1,1,:));

         end % iFrame
    else
        for iFrame = 1:nStim
            % Get scene corresponding to this forward polarity of the stimulus frame
            theFrameScene = theRFMappingStimulusScenes{iFrame};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert to modulation responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                (noiseFreeAbsorptionsCountForwardPolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

            % Get scene corresponding to the inverse polarity of this stimulus frame
            theFrameScene = theInversePolarityRFMappingStimulusScenes{iFrame};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert to modulation responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                (noiseFreeAbsorptionsCountInversePolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

            theConeMosaicSubspaceResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsCountForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsCountInversePolarity(1,1,:));
        end
    end

end
