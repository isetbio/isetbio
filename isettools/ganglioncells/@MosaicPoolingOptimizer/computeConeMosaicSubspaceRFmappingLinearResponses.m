function [theConeMosaicSubspaceResponses, theConeMosaicNullResponses, ...
    HartleySpatialModulationPatterns, spatialSupportDegs, lIndices, mIndices] = ...
    computeConeMosaicSubspaceRFmappingLinearResponses(theConeMosaic, theOptics,  ...
                                           thePresentationDisplay, ...
                                           stimParams, ...
                                           stimPositionDegs, ...
                                           useParfor, ...
                                           visualizeResponses)

    % Compute the Hartley spatial patterns
    fprintf('Generating Hartley patterns\n')
    % Compute spatial modulation patterns for the Hartley set
    [HartleySpatialModulationPatterns, lIndices, mIndices] = ...
            rfMappingStimulusGenerator.HartleyModulationPatterns(...
            stimParams.omega, stimParams.stimSizeDegs, stimParams.pixelSizeDegs);


    % Compute the null stimulus
    [~, theNullStimulusScene, spatialSupportDegs] = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 0);


    % This is necessary to avoid the background being modulated when the
    % stimulus is smaller than the mosaic. This is due to the way oiCompute
    % does the padding.
    padOIwithZeros = true;
    if (padOIwithZeros)
        theOptics = oiSet(theOptics, 'pad', struct('value', 'zero photons'));
    end

    % Compute the optical image of the null scene
    theOptics  = oiCompute(theNullStimulusScene, theOptics);

    % Compute the cone mosaic null responses
    theConeMosaicNullResponses = theConeMosaic.compute(theOptics, ...
                    'padOIwithZeros', padOIwithZeros, ...
                    'opticalImagePositionDegs', stimPositionDegs, ...
                    'nTrials', 1);

    coneIndicesWithZeroNullResponse = find(theConeMosaicNullResponses== 0);
    normalizingResponses = 1./theConeMosaicNullResponses;
    normalizingResponses(coneIndicesWithZeroNullResponse) = 0;
    normalizingResponses = reshape(normalizingResponses, [1 1 numel(normalizingResponses)]);
             

    % Compute the input cone mosaic responses
    nStim = size(HartleySpatialModulationPatterns,1);

    % Allocate memory
    theConeMosaicSubspaceResponses = zeros(nStim, theConeMosaic.conesNum, 'single');
    if (useParfor)
         theOI = theOptics;
         poolobj = gcp('nocreate'); % If no pool, do not create new one.
         if (~isempty(poolobj))
            delete(poolobj);
         end
         processorsNum = 2;
         parpool('local',processorsNum);
         parfor iFrame = 1:nStim

             % Generate scenes for the Hartley patterns
            fprintf('Computing cone mosaic response for Hartley pattern %d of %d.\n', iFrame, nStim);

             theForwardPolarityRFMappingStimulusScenes =  rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame);

    
             theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame);

             % Get scene corresponding to this forward polarity of the stimulus frame
             theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theCurrentOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses
             noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theCurrentOI, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

             % Convert to modulation responses
             noiseFreeAbsorptionsCountForwardPolarity = ...
                (noiseFreeAbsorptionsCountForwardPolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

             % Get scene corresponding to the inverse polarity of this stimulus frame
             theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theCurrentOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses
             noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theCurrentOI, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

             % Convert to modulation responses
             noiseFreeAbsorptionsCountInversePolarity = ...
                (noiseFreeAbsorptionsCountInversePolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

             theConeMosaicSubspaceResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsCountForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsCountInversePolarity(1,1,:));

         end % iFrame

         poolobj = gcp('nocreate'); % If no pool, do not create new one.
         if (~isempty(poolobj))
            delete(poolobj);
         end
         
    else
        for iFrame = 1:nStim

            fprintf('Computing cone mosaic response for Hartley pattern %d of %d.\n', iFrame, nStim);

            theForwardPolarityRFMappingStimulusScenes =  rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame);

    
            theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame);

            % Get scene corresponding to this forward polarity of the stimulus frame
            theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};


            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert to modulation responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                (noiseFreeAbsorptionsCountForwardPolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

            % Get scene corresponding to the inverse polarity of this stimulus frame
            theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'padOIwithZeros', padOIwithZeros, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert to modulation responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                (noiseFreeAbsorptionsCountInversePolarity - theConeMosaicNullResponses) ./ ...
                normalizingResponses;

            theConeMosaicSubspaceResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsCountForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsCountInversePolarity(1,1,:));
        end
    end

end
