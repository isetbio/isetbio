function [theConeMosaicSubspaceLinearModulationResponses, theConeMosaicNullResponses, ...
    HartleySpatialModulationPatterns, spatialSupportDegs, lIndices, mIndices] = ...
    computeConeMosaicSubspaceRFmappingLinearResponses(theConeMosaic, theOptics,  ...
                                           thePresentationDisplay, ...
                                           stimParams, ...
                                           stimPositionDegs, ...
                                           varargin)

    p = inputParser;
    p.addParameter('parPoolSize', [], @(x)(isempty(x)||(isscalar(x))));
    p.addParameter('visualizeResponses', false, @islogical);
    p.addParameter('customConeFundamentals', [], @(x)(isempty(x)||(isstruct(x))));
    p.parse(varargin{:});
    parPoolSize = p.Results.parPoolSize;
    visualizeResponses = p.Results.visualizeResponses;
    customConeFundamentals = p.Results.customConeFundamentals;

    % Compute the Hartley spatial patterns
    visualizePatterns = ~true;

    if (visualizePatterns)
        % Compute spatial modulation patterns for the Hartley set
        [HartleySpatialModulationPatterns, lIndices, mIndices] = ...
                rfMappingStimulusGenerator.HartleyModulationPatterns(...
                    stimParams.omega, stimParams.stimSizeDegs, stimParams.pixelSizeDegs, ...
                    'parPoolSize', 0, ...
                    'visualizePatterns', true);
    else
        [HartleySpatialModulationPatterns, lIndices, mIndices] = ...
            rfMappingStimulusGenerator.HartleyModulationPatterns(...
                stimParams.omega, stimParams.stimSizeDegs, stimParams.pixelSizeDegs);
    end


    % Compute the null stimulus.
    fprintf('Computing null scene\n');
    [~, theNullStimulusScene, spatialSupportDegs, theConeFundamentalsStruct] = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 0, ...
                'customConeFundamentals', customConeFundamentals);

   
    fprintf('Computing null scene response\n');
    % Compute the optical image of the null scene
    theOptics  = oiCompute(theNullStimulusScene, theOptics);

    % Compute the cone mosaic response to the null stimulus
    theConeMosaicNullResponses = theConeMosaic.compute(theOptics, ...
                    'opticalImagePositionDegs', stimPositionDegs, ...
                    'nTrials', 1);

    coneIndicesWithZeroNullResponse = find(theConeMosaicNullResponses == 0);
    normalizingResponses = 1./theConeMosaicNullResponses;
    normalizingResponses(coneIndicesWithZeroNullResponse) = 0;
    normalizingResponses = reshape(normalizingResponses, [1 1 numel(normalizingResponses)]);
             
    % Compute the input cone mosaic modulation responses
    nStim = size(HartleySpatialModulationPatterns,1);
    theConeMosaicSubspaceLinearModulationResponses = zeros(nStim, theConeMosaic.conesNum, 'single');

    if ((~isempty(parPoolSize)) && (parPoolSize>1)) || (isempty(parPoolSize))
         % Reset parpool
         [shutdownParPoolOnceCompleted, numWorkers] = MosaicPoolingOptimizer.resetParPool(parPoolSize);

         theOI = theOptics;
         parfor iFrame = 1:nStim
             % Generate scenes for the Hartley patterns
            fprintf('Computing cone mosaic response for Hartley pattern %d of %d (using %d parallel processes).\n', ...
                iFrame, nStim, numWorkers);

             theForwardPolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

             theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

             % Get scene corresponding to the forward polarity of the stimulus frame
             theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theFrameOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses to the forward polarity stimulus
             noiseFreeAbsorptionsCountForwardPolarity = theConeMosaic.compute(...
                 theFrameOI, ...
                 'opticalImagePositionDegs', stimPositionDegs, ...
                 'nTrials', 1);

             % Convert  absorption responses to modulation responses (forward polarity)
             noiseFreeAbsorptionsModulationForwardPolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountForwardPolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % Get scene corresponding to the inverse polarity of this stimulus frame
             theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theFrameOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses to the inverse polarity stimulus
             noiseFreeAbsorptionsCountInversePolarity = theConeMosaic.compute(...
                 theFrameOI, ...
                 'opticalImagePositionDegs', stimPositionDegs, ...
                 'nTrials', 1);

             % Convert  absorption responses to modulation responses (inverse polarity)
             noiseFreeAbsorptionsModulationInversePolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountInversePolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % The linear response: forward - inverse
             theConeMosaicSubspaceLinearModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

         end % iFrame

         if (shutdownParPoolOnceCompleted)
            poolobj = gcp('nocreate'); 
            delete(poolobj);
         end
         
    else
        for iFrame = 1:nStim
            fprintf('Computing cone mosaic response for Hartley pattern %d of %d (serially).\n', iFrame, nStim);

            theForwardPolarityRFMappingStimulusScenes =  rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

            theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -HartleySpatialModulationPatterns, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', iFrame, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

            % Get scene corresponding to this forward polarity of the stimulus frame
            theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert  absorption responses to modulation responses (forward polarity)
            noiseFreeAbsorptionsModulationForwardPolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountForwardPolarity, theConeMosaicNullResponses), ...
                normalizingResponses);


            % Get scene corresponding to the inverse polarity of this stimulus frame
            theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

 
            % Convert  absorption responses to modulation responses (inverse polarity)
            noiseFreeAbsorptionsModulationInversePolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountInversePolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % The linear response: forward - inverse
             theConeMosaicSubspaceLinearModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

         
            if (visualizeResponses)
                hFig = figure(2); clf;
                set(hFig, 'Position', [10 10 2000 800]);
                ax1 = subplot(1,3,1);
                ax2 = subplot(1,3,2);
                ax3 = subplot(1,3,3);
    
                 theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax1, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15]);

                theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax2, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15], ...
                    'activation', noiseFreeAbsorptionsModulationForwardPolarity, ...
                    'activationRange', max(abs(noiseFreeAbsorptionsModulationForwardPolarity(:)))*[-1 1]);
                
                theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax3, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15], ...
                    'activation', noiseFreeAbsorptionsModulationInversePolarity, ...
                    'activationRange', max(abs(noiseFreeAbsorptionsModulationForwardPolarity(:)))*[-1 1]);
                drawnow;
                pause
            end

           
        end
    end
end
