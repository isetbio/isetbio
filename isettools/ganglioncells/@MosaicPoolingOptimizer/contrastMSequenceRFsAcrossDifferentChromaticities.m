function contrastMSequenceRFsAcrossDifferentChromaticities(...
    exampleLconeCenterRGCposition, exampleMconeCenterRGCposition, ...
    theComputeReadyMRGCmosaic, ...
    theOptimallyMappedAchromaticRFmapsFileName, ...
    theOptimallyMappedLconeIsolatingRFmapsFileName, ...
    theOptimallyMappedMconeIsolatingRFmapsFileName, ...
    coneFundamentalsOptimizedForStimPosition, ...
    rfPixelsAcross, opticsParams, rawFiguresRoot, scaledFiguresRoot, ...
    exportScaledFigureVersionForManuscript, varargin)

    % Parse input
    p = inputParser;
    p.addParameter('examinedRGCindices', [], @(x)(isnumeric(x)||(ischar(x))));
    p.addParameter('tickSeparationArcMin', 3, @isscalar);
    p.addParameter('performSurroundAnalysisForConesExclusiveToTheSurround', true, @islogical);
    p.addParameter('generateVideoWithAllExaminedRGCs', false, @islogical);

    p.parse(varargin{:});
    examinedRGCindices = p.Results.examinedRGCindices;
    performSurroundAnalysisForConesExclusiveToTheSurround = p.Results.performSurroundAnalysisForConesExclusiveToTheSurround;
    tickSeparationArcMin = p.Results.tickSeparationArcMin;
    generateVideoWithAllExaminedRGCs = p.Results.generateVideoWithAllExaminedRGCs;


    % Load the achromatic RF maps
    load(theOptimallyMappedAchromaticRFmapsFileName, 'optimallyMappedVisualRFmaps', 'indicesOfOptimallyMappedRGCs');
    theOptimallyMappedAchromaticVisualRFmaps = optimallyMappedVisualRFmaps;
    theRGCindicesOfOptimallyMappedAchromaticVisualRFmaps = indicesOfOptimallyMappedRGCs;
    clear 'optimallyMappedVisualRFmaps';

    % Load the L-cone isolating RF maps
    load(theOptimallyMappedLconeIsolatingRFmapsFileName, 'optimallyMappedVisualRFmaps', 'indicesOfOptimallyMappedRGCs');
    theOptimallyMappedLconeIsolatingVisualRFmaps = optimallyMappedVisualRFmaps;
    theRGCindicesOfOptimallyMappedLconeIsolatingVisualRFmaps = indicesOfOptimallyMappedRGCs;
    clear 'optimallyMappedVisualRFmaps';

    load(theOptimallyMappedMconeIsolatingRFmapsFileName, 'optimallyMappedVisualRFmaps', 'indicesOfOptimallyMappedRGCs');
    theOptimallyMappedMconeIsolatingVisualRFmaps = optimallyMappedVisualRFmaps;
    theRGCindicesOfOptimallyMappedMconeIsolatingVisualRFmaps = indicesOfOptimallyMappedRGCs;
    clear 'optimallyMappedVisualRFmaps';


    % Cone contrasts and overall contrast for achromatic stimulus
    [achromaticStimulusConeContrasts, achromaticStimulusContrast] = ...
        MosaicPoolingOptimizer.contrastForChromaticity('achromatic');

    % Cone contrasts and overall contrast for L-coneIsolating stimulus
    [LconeIsolatingStimulusConeContrasts, LconeIsolatingStimulusContrast] = ...
        MosaicPoolingOptimizer.contrastForChromaticity('Lcone isolating');

    % Cone contrasts and overall contrast for M-coneIsolating stimulus
    [MconeIsolatingStimulusConeContrasts, MconeIsolatingStimulusContrast] = ...
        MosaicPoolingOptimizer.contrastForChromaticity('Mcone isolating');

    % Correction factors to account for low L/M cone isolating stimulus contrast
    % compared to the achromatic sitmulus contrast
    LconeStimulusContrastCorrection =  achromaticStimulusContrast * achromaticStimulusConeContrasts(1) / (LconeIsolatingStimulusContrast * LconeIsolatingStimulusConeContrasts(1));
    MconeStimulusContrastCorrection =  achromaticStimulusContrast * achromaticStimulusConeContrasts(2) / (MconeIsolatingStimulusContrast * MconeIsolatingStimulusConeContrasts(2));


    if (isempty(examinedRGCindices))
        examinedRGCindices = 1:theComputeReadyMRGCmosaic.rgcsNum;
    end

    if (opticsParams.examinedSubjectRankOrder == 0)
       opticsString = sprintf('diffr-limited, pupil_%2.0fmm, defocus_%1.2fD', opticsParams.pupilDiameterMM, opticsParams.refractiveErrorDiopters);
    else
       opticsString = sprintf('physio-optics, defocus_%1.2fD', opticsParams.refractiveErrorDiopters);
    end

    
    if (opticsParams.employMonochromaticVlambdaWeightedPSF)
        opticsString = sprintf('%s_MonoVLambdaPSF', opticsString);
    end

    if (coneFundamentalsOptimizedForStimPosition)
        opticsString = sprintf('%s_OptimizedConeFundamentals', opticsString);
    end

    analyzedLconeCenterRGCs = 0;
    analyzedMconeCenterRGCs = 0;

    for iRGC = 1:numel(examinedRGCindices)

        % Get theRGCindex
        theRGCindex = examinedRGCindices(iRGC);
        [~, ~, theCenterMajorityConeType] = theComputeReadyMRGCmosaic.centerConeTypeWeights(theRGCindex);

        if (theCenterMajorityConeType == cMosaic.LCONE_ID)
            analyzedLconeCenterRGCs = analyzedLconeCenterRGCs +1;
        end

        if (theCenterMajorityConeType == cMosaic.MCONE_ID)
            analyzedMconeCenterRGCs = analyzedMconeCenterRGCs +1;
        end
    end


    theLconeCenterData = {};
    theMconeCenterData = {};
    for iRGC = 1:numel(examinedRGCindices)

        % Get theRGCindex
        theRGCindex = examinedRGCindices(iRGC);
      
        % Analyze cone weights to center and surround
        [theCenterMajorityConeType, netCenterLconeWeight, netCenterMconeWeight, ...
         netSurroundLconeWeight, netSurroundMconeWeight, surroundConeMix] = MosaicPoolingOptimizer.analyzeCenterSurroundConeMix(...
            theComputeReadyMRGCmosaic, theRGCindex, performSurroundAnalysisForConesExclusiveToTheSurround);


        theOptimallyMappedRGCindexA = find(theRGCindicesOfOptimallyMappedAchromaticVisualRFmaps == theRGCindex);
        theOptimallyMappedRGCindexL = find(theRGCindicesOfOptimallyMappedLconeIsolatingVisualRFmaps == theRGCindex);
        theOptimallyMappedRGCindexM = find(theRGCindicesOfOptimallyMappedMconeIsolatingVisualRFmaps == theRGCindex);


        if (theCenterMajorityConeType == cMosaic.LCONE_ID)
            
           if ( (isempty(theOptimallyMappedRGCindexA)) || ...
                (isempty(theOptimallyMappedRGCindexL)) || ...
                (isempty(theOptimallyMappedRGCindexM)) )
                    fprintf('No optimally mapped mseq RF map for RGC #%d.\n', theRGCindex);
           else
               theLconeCenterData{numel(theLconeCenterData) + 1} = struct(...
                    'theRGCindex', theRGCindex, ...
                    'netCenterLconeWeight', netCenterLconeWeight, ...
                    'netCenterMconeWeight', netCenterMconeWeight, ...
                    'netSurroundLconeWeight', netSurroundLconeWeight, ...
                    'netSurroundMconeWeight', netSurroundMconeWeight, ...
                    'surroundConeMix',  surroundConeMix, ...
                    'achromaticRFmapDataStruct', theOptimallyMappedAchromaticVisualRFmaps{theOptimallyMappedRGCindexA}, ...
                    'LconeIsolatingRFmapDataStruct', theOptimallyMappedLconeIsolatingVisualRFmaps{theOptimallyMappedRGCindexL}, ...
                    'MconeIsolatingRFmapDataStruct', theOptimallyMappedMconeIsolatingVisualRFmaps{theOptimallyMappedRGCindexM} ...
                    );
           end
        end

        if (theCenterMajorityConeType == cMosaic.MCONE_ID)
            if ( (isempty(theOptimallyMappedRGCindexA)) || ...
                 (isempty(theOptimallyMappedRGCindexL)) || ...
                 (isempty(theOptimallyMappedRGCindexM)) )
                    fprintf('No optimally mapped mseq RF map for RGC #%d.\n', theRGCindex);
            else
                theMconeCenterData{numel(theMconeCenterData)+1} = struct(...
                    'theRGCindex', theRGCindex, ...
                    'netCenterLconeWeight', netCenterLconeWeight, ...
                    'netCenterMconeWeight', netCenterMconeWeight, ...
                    'netSurroundLconeWeight', netSurroundLconeWeight, ...
                    'netSurroundMconeWeight', netSurroundMconeWeight, ...
                    'surroundConeMix',  surroundConeMix, ...
                    'achromaticRFmapDataStruct', theOptimallyMappedAchromaticVisualRFmaps{theOptimallyMappedRGCindexA}, ...
                    'LconeIsolatingRFmapDataStruct', theOptimallyMappedLconeIsolatingVisualRFmaps{theOptimallyMappedRGCindexL}, ...
                    'MconeIsolatingRFmapDataStruct', theOptimallyMappedMconeIsolatingVisualRFmaps{theOptimallyMappedRGCindexM} ...
                    );
            end
        end

    end

    centerSubregionContourSamples = 32;
    contourGenerationMethod = 'ellipseFitToPooledConeApertureImage';
    theComputeReadyMRGCmosaic.generateVisualizationCache([], [], centerSubregionContourSamples, contourGenerationMethod);
  

    plotSelectedRGCData(theComputeReadyMRGCmosaic, ...
        theLconeCenterData, theMconeCenterData, ...
        exampleLconeCenterRGCposition, exampleMconeCenterRGCposition, ...
        LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
        rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript)

end

function plotSelectedRGCData(theComputeReadyMRGCmosaic, ...
        theLconeCenterData, theMconeCenterData, ...
        exampleLconeCenterRGCposition, exampleMconeCenterRGCposition, ...
        LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
        rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript)

    lConeCenterRGCsNum = numel(theLconeCenterData);
    mConeCenterRGCsNum = numel(theMconeCenterData);

    if (~isempty(exampleLconeCenterRGCposition))
        theLconeCenterRFpositions = zeros(lConeCenterRGCsNum ,2);
        theMconeCenterRFpositions = zeros(mConeCenterRGCsNum ,2);
    
        for iLconeRGC = 1:lConeCenterRGCsNum
            d = theLconeCenterData{iLconeRGC};
            theLconeCenterRFpositions(iLconeRGC,:) = theComputeReadyMRGCmosaic.rgcRFpositionsDegs(d.theRGCindex,:);
        end
    
        for iMconeRGC = 1:mConeCenterRGCsNum
            d = theMconeCenterData{iMconeRGC};
            theMconeCenterRFpositions(iMconeRGC,:) = theComputeReadyMRGCmosaic.rgcRFpositionsDegs(d.theRGCindex,:);
        end
    
        distances = sum((bsxfun(@minus, theLconeCenterRFpositions, exampleLconeCenterRGCposition)).^2,2);
        [~,idx] = min(distances(:));
        if (~isempty(idx))
            exampleLconeCenterData = theLconeCenterData{idx};
        else
            exampleLconeCenterData = [];
        end
    
        distances = sum((bsxfun(@minus, theMconeCenterRFpositions, exampleMconeCenterRGCposition)).^2,2);
        [~, idx] = min(distances(:));
        if (~isempty(idx))
            exampleMconeCenterData = theMconeCenterData{idx};
        else
            exampleMconeCenterData = [];
        end

        if (~isempty(exampleLconeCenterData))
            renderMSequenceRFMaps(20, theComputeReadyMRGCmosaic, exampleLconeCenterData, 'L', ...
                LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
                rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript);
        end

        if (~isempty(exampleMconeCenterData))
            renderMSequenceRFMaps(21, theComputeReadyMRGCmosaic, exampleMconeCenterData, 'M', ...
                LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
                rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript);
        end
        
    else
        for iRGC = 1:numel(theLconeCenterData)
            exampleLconeCenterData = theLconeCenterData{iRGC};
            renderMSequenceRFMaps(20, theComputeReadyMRGCmosaic, exampleLconeCenterData, 'L', ...
                LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
                rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript);
        end

        for iRGC = 1:numel(theMconeCenterData)
            exampleMconeCenterData = theMconeCenterData{iRGC};
            renderMSequenceRFMaps(21, theComputeReadyMRGCmosaic, exampleMconeCenterData, 'M', ...
                LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
                rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript);
        end

    end


    
    

end

function renderMSequenceRFMaps(figNo, theComputeReadyMRGCmosaic, exampleConeCenterData, coneType, ...
    LconeStimulusContrastCorrection, MconeStimulusContrastCorrection, ...
    rfPixelsAcross, opticsString, rawFiguresRoot, scaledFiguresRoot, exportScaledFigureVersionForManuscript)

    % Apply correction factors to account for low L/M cone isolating stimulus contrast
    % compared to the achromatic stimulus contrast
    exampleConeCenterData.LconeIsolatingRFmapDataStruct.theRFmap = ...
        exampleConeCenterData.LconeIsolatingRFmapDataStruct.theRFmap * LconeStimulusContrastCorrection;
    exampleConeCenterData.MconeIsolatingRFmapDataStruct.theRFmap = ...
        exampleConeCenterData.MconeIsolatingRFmapDataStruct.theRFmap * MconeStimulusContrastCorrection;


    % Smoothed maps
    [exampleConeCenterData.achromaticRFmapDataStruct.theSmoothedRFmap, smoothingKernel, rfPixelSizeSamples] = MosaicPoolingOptimizer.applyReidShapleySmoothingToRFmap(...
       exampleConeCenterData.achromaticRFmapDataStruct.spatialSupportDegsX, exampleConeCenterData.achromaticRFmapDataStruct.theRFmap, rfPixelsAcross);

    exampleConeCenterData.LconeIsolatingRFmapDataStruct.theSmoothedRFmap = MosaicPoolingOptimizer.applyReidShapleySmoothingToRFmap(...
       exampleConeCenterData.LconeIsolatingRFmapDataStruct.spatialSupportDegsX, exampleConeCenterData.LconeIsolatingRFmapDataStruct.theRFmap, rfPixelsAcross);

    exampleConeCenterData.MconeIsolatingRFmapDataStruct.theSmoothedRFmap = MosaicPoolingOptimizer.applyReidShapleySmoothingToRFmap(...
       exampleConeCenterData.MconeIsolatingRFmapDataStruct.spatialSupportDegsX, exampleConeCenterData.MconeIsolatingRFmapDataStruct.theRFmap, rfPixelsAcross);

    % Fit ellipse to the achromatic RF
    [achromaticRFcenterContourData, achromaticRFcentroid] = ellipseContourFromSubregionRFmap(exampleConeCenterData.achromaticRFmapDataStruct);
    
    % Fit ellipse to the L-cone isolating RF
    [~, theLconeRFmapCentroid] = ellipseContourFromSubregionRFmap(exampleConeCenterData.LconeIsolatingRFmapDataStruct);

    % Fit ellipse to the M-cone isolating RF
    [~, theMconeRFmapCentroid] = ellipseContourFromSubregionRFmap(exampleConeCenterData.MconeIsolatingRFmapDataStruct);


    % Profiles
    [~,theRFcenterCol] = min(abs(exampleConeCenterData.achromaticRFmapDataStruct.spatialSupportDegsX-achromaticRFcentroid(1)));
    [~,theRFcenterRow] = min(abs(exampleConeCenterData.achromaticRFmapDataStruct.spatialSupportDegsY-achromaticRFcentroid(2)));
    radiallySymmetricAchromaticRFprofileX = generateRFprofile(...
        exampleConeCenterData.achromaticRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow, 'radially averaged profile');

    lineWeightingAchromaticRFprofileX = generateRFprofile(...
        exampleConeCenterData.achromaticRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow,'line weighting function');

    [~,theRFcenterCol] = min(abs(exampleConeCenterData.LconeIsolatingRFmapDataStruct.spatialSupportDegsX-theLconeRFmapCentroid(1)));
    [~,theRFcenterRow] = min(abs(exampleConeCenterData.LconeIsolatingRFmapDataStruct.spatialSupportDegsY-theLconeRFmapCentroid(2)));
    radiallySymmetricLconeIsolatingRFprofileX = generateRFprofile(...
        exampleConeCenterData.LconeIsolatingRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow, 'radially averaged profile');

    lineWeightingLconeIsolatingRFprofileX = generateRFprofile(...
        exampleConeCenterData.LconeIsolatingRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow,'line weighting function');


    [~,theRFcenterCol] = min(abs(exampleConeCenterData.MconeIsolatingRFmapDataStruct.spatialSupportDegsX-theMconeRFmapCentroid(1)));
    [~,theRFcenterRow] = min(abs(exampleConeCenterData.MconeIsolatingRFmapDataStruct.spatialSupportDegsY-theMconeRFmapCentroid(2)));
    radiallySymmetricMconeIsolatingRFprofileX = generateRFprofile(...
        exampleConeCenterData.MconeIsolatingRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow, 'radially averaged profile');

    lineWeightingMconeIsolatingRFprofileX = generateRFprofile(...
        exampleConeCenterData.MconeIsolatingRFmapDataStruct.theSmoothedRFmap, ...
        theRFcenterCol, theRFcenterRow,'line weighting function');
   

    % Max RF map range
    m = min([...
           max(abs(exampleConeCenterData.LconeIsolatingRFmapDataStruct.theRFmap(:))) ...
           max(abs(exampleConeCenterData.MconeIsolatingRFmapDataStruct.theRFmap(:)))...
        ]);
    RFmapRangeMaxSurroundVisibility = m * [-1 1];

    m = max([...
           max(abs(exampleConeCenterData.LconeIsolatingRFmapDataStruct.theRFmap(:))) ...
           max(abs(exampleConeCenterData.MconeIsolatingRFmapDataStruct.theRFmap(:)))...
        ]);
    RFmapRange = m * [-1 1];


    cLUTReidShapley = MosaicPoolingOptimizer.generateReidShapleyRFmapLUT();
    cLUTBlueRed = redblueLUT();
    fontSize = 16;

    
    hFig = figure(figNo); clf;
    set(hFig, 'Color', [1 1 1], 'Position', [10 10 1620 900]);

    referenceCentroid = achromaticRFcentroid;

    subplotPosVectors = NicePlot.getSubPlotPosVectors(...
       'rowsNum', 3, ...
       'colsNum', 5, ...
       'heightMargin',  0.03, ...
       'widthMargin',    0.03, ...
       'leftMargin',     0.04, ...
       'rightMargin',    0.01, ...
       'bottomMargin',   0.06, ...
       'topMargin',      0.02);

    ax = subplot('Position', subplotPosVectors(2,1).v);
    theAxes{1,1} = ax;
    theAxes{1,2} = [];
    theAxes{1,3} = [];
    tickSeparationArcMin = 3;
    visualizedRangeDegs = 0.3;

    XLims = visualizedRangeDegs*0.5*[-1 1] + referenceCentroid(1);
    YLims = visualizedRangeDegs*0.5*[-1 1] + referenceCentroid(2);
    XTicks = referenceCentroid(1) + (-2:tickSeparationArcMin/60:2);
    YTicks = referenceCentroid(2) + (-2:tickSeparationArcMin/60:2);
    

    ff = [];
    theComputeReadyMRGCmosaic.visualizeRetinalConePoolingRFmapOfRGCwithIndex(exampleConeCenterData.theRGCindex, ...
            'theAxes', theAxes, ...
            'tickSeparationArcMin', tickSeparationArcMin, ...
            'surroundSaturationLevel', 0.1, ...
            'normalizedPeakSurroundSensitivity', 0.4, ...
            'gridlessLineWeightingFunctions', true, ...
            'withFigureFormat', ff, ...
            'regenerateVisualizationCache', false);
    set(theAxes{1,1}, 'fontSize', fontSize);
    set(theAxes{1,1}, 'XLim', XLims, ...
                      'YLim', YLims, ...
                      'XTick', XTicks, ...
                      'YTick', YTicks, ...
                      'XTickLabel', sprintf('%2.2f\n', XTicks), ...
                      'YTickLabel', sprintf('%2.2f\n', YTicks));
    title(theAxes{1,1}, sprintf('RGC #%d\n(surround purity: %2.2f)', exampleConeCenterData.theRGCindex, exampleConeCenterData.surroundConeMix));

    

    ax = subplot('Position', subplotPosVectors(1,2).v);
    renderRFmap(ax, exampleConeCenterData.LconeIsolatingRFmapDataStruct, RFmapRangeMaxSurroundVisibility, ...
        [], theLconeRFmapCentroid, referenceCentroid, ...
        XLims, YLims, XTicks, YTicks, cLUTBlueRed,  ...
        'raw', 'L-cone', true, true, fontSize);

    ax = subplot('Position', subplotPosVectors(1,3).v);
    renderRFmap(ax, exampleConeCenterData.MconeIsolatingRFmapDataStruct, RFmapRangeMaxSurroundVisibility, ...
        [], theMconeRFmapCentroid, referenceCentroid, ...
        XLims, YLims, XTicks, YTicks, cLUTBlueRed,  ...
        'raw', 'M-cone', true, true, fontSize);
    
    ax = subplot('Position', subplotPosVectors(1,4).v);
    renderRFmap(ax, exampleConeCenterData.achromaticRFmapDataStruct, RFmapRangeMaxSurroundVisibility, ...
        [], achromaticRFcentroid, referenceCentroid,...
        XLims, YLims, XTicks, YTicks, cLUTBlueRed,  ...
        'raw', 'achromatic', true, true, fontSize);


    ax = subplot('Position', subplotPosVectors(2,2).v);
    renderRFmap(ax, exampleConeCenterData.LconeIsolatingRFmapDataStruct, RFmapRange, ...
        [], theLconeRFmapCentroid, referenceCentroid, ...
        XLims, YLims, XTicks, YTicks,  cLUTReidShapley,  ...
        'smoothed', '', true, true, fontSize);

    ax = subplot('Position', subplotPosVectors(2,3).v);
    renderRFmap(ax, exampleConeCenterData.MconeIsolatingRFmapDataStruct, RFmapRange, ...
        [],  theMconeRFmapCentroid, referenceCentroid, ...
        XLims, YLims, XTicks, YTicks, cLUTReidShapley,  ...
        'smoothed', '', true, true, fontSize);
    
     ax = subplot('Position', subplotPosVectors(2,4).v);
    renderRFmap(ax, exampleConeCenterData.achromaticRFmapDataStruct, RFmapRange, ...
        [], achromaticRFcentroid, referenceCentroid, ...
        XLims, YLims, XTicks, YTicks, cLUTReidShapley,  ...
        'smoothed', '', true, true, fontSize);


    m1 = max([max(radiallySymmetricAchromaticRFprofileX) max(radiallySymmetricLconeIsolatingRFprofileX) max(radiallySymmetricMconeIsolatingRFprofileX)]);
    m2 = min([min(radiallySymmetricAchromaticRFprofileX) min(radiallySymmetricLconeIsolatingRFprofileX) min(radiallySymmetricMconeIsolatingRFprofileX)]);
    if (-m2 > m1)
       YLimsRadiallySymmetricProfiles(1) = m2*1.01;
       YLimsRadiallySymmetricProfiles(2) = -m2*0.3;
    else
       YLimsRadiallySymmetricProfiles(2) = m1*1.01;
       YLimsRadiallySymmetricProfiles(1) = -m1*0.3;
    end
    
    m1 = max([max(lineWeightingAchromaticRFprofileX) max(lineWeightingLconeIsolatingRFprofileX) max(lineWeightingMconeIsolatingRFprofileX)]);
    m2 = min([min(lineWeightingAchromaticRFprofileX) min(lineWeightingLconeIsolatingRFprofileX) min(lineWeightingMconeIsolatingRFprofileX)]);
    if (-m2 > m1)
       YLimsLineWeightingProfiles(1) = m2*1.01;
       YLimsLineWeightingProfiles(2) = -m2*0.3;
    else
       YLimsLineWeightingProfiles(2) = m1*1.01;
       YLimsLineWeightingProfiles(1) = -m1*0.3;
    end

    

    % The line weighting functions
    labelYaxisTicks = false;
    ax = subplot('Position', subplotPosVectors(3,2).v);
    faceColor = [237 110 128]/237;
    edgeColor = [1 0 0];
    renderRFprofile(ax, exampleConeCenterData.LconeIsolatingRFmapDataStruct, ...
        lineWeightingLconeIsolatingRFprofileX(:), faceColor, edgeColor, ...
        XLims, YLimsLineWeightingProfiles, XTicks, ...
        referenceCentroid, visualizedRangeDegs, fontSize, ...
        labelYaxisTicks, 1);

    ax = subplot('Position', subplotPosVectors(3,3).v);
    faceColor = [91 197 128]/197;
    edgeColor = [0 0.8 0.3];
    renderRFprofile(ax, exampleConeCenterData.MconeIsolatingRFmapDataStruct, ...
        lineWeightingMconeIsolatingRFprofileX(:), faceColor, edgeColor, ...
        XLims, YLimsLineWeightingProfiles, XTicks, ...
        referenceCentroid, visualizedRangeDegs, fontSize, ...
        labelYaxisTicks, 1);

    ax = subplot('Position', subplotPosVectors(3,4).v);
    faceColor = [0.8 0.8 0.8];
    edgeColor = [0.0 0.0 0.0];
    labelYaxisTicks = true;
    renderRFprofile(ax, exampleConeCenterData.achromaticRFmapDataStruct, ...
        lineWeightingAchromaticRFprofileX(:), faceColor, edgeColor, ...
        XLims, YLimsLineWeightingProfiles, XTicks, ...
        referenceCentroid, visualizedRangeDegs, fontSize, ...
        labelYaxisTicks, 1);


    p = subplotPosVectors(3,4).v;
    ax = subplot('Position', [p(1)+p(3)+0.04 p(2) p(3) 0.91]);
    allProfiles = [...
        radiallySymmetricAchromaticRFprofileX(:) ...
        radiallySymmetricLconeIsolatingRFprofileX(:) ...
        radiallySymmetricMconeIsolatingRFprofileX(:) ...
        ];
    labelYaxisTicks = true;
    renderRFprofile(ax, exampleConeCenterData.MconeIsolatingRFmapDataStruct, ...
        allProfiles, [], [], ...
        XLims, YLimsRadiallySymmetricProfiles, XTicks, ...
        referenceCentroid, visualizedRangeDegs, fontSize, ...
        labelYaxisTicks, 10);

    title(ax, 'radially-averaged profiles');
    drawnow;

    thePDFFileName = sprintf('mosaicEcc_%2.1f_%2.1f_%s_RGC%d_%dx%dmSeqRFmap.pdf', ...
        theComputeReadyMRGCmosaic.eccentricityDegs(1), theComputeReadyMRGCmosaic.eccentricityDegs(2), ...
        opticsString, ...
        exampleConeCenterData.theRGCindex, ...
        rfPixelsAcross, rfPixelsAcross);

    NicePlot.exportFigToPDF(fullfile(rawFiguresRoot, thePDFFileName), hFig, 300);


end


function renderRFprofile(ax, RFmapDataStruct,  profileX, faceColor, edgeColor, ...
    XLims, YLims, XTicks, theRFmapReferenceCentroid, visualizedRangeDegs, fontSize, ...
    labelYaxisTicks, YTickRoundingNumber)

    if (size(profileX,2) == 1)
        faceAlpha = 0.6;
        lineWidth = 1.5;
        shadedAreaPlot(ax,RFmapDataStruct.spatialSupportDegsX, profileX, profileX*0, ...
            faceColor, edgeColor, faceAlpha, lineWidth, '-');
    else
        faceColor = [0.8 0.8 0.8];
        edgeColor = [0.0 0.0 0.0];
        faceAlpha = 0.0;
        lineWidth = 1.5;

        p(1) = shadedAreaPlot(ax,RFmapDataStruct.spatialSupportDegsX, profileX(:,1), profileX(:,1)*0, ...
            faceColor, edgeColor, faceAlpha, lineWidth, '-');
        hold(ax, 'on');

        faceColor = [237 110 128]/237;
        edgeColor = [1 0 0];
        faceAlpha = 0.6;
        lineWidth = 1.5;
        p(2) = shadedAreaPlot(ax,RFmapDataStruct.spatialSupportDegsX, profileX(:,2), profileX(:,2)*0, ...
            faceColor, edgeColor, faceAlpha, lineWidth, '-');
  

        faceColor = [91 197 128]/197;
        edgeColor = [0 0.5 0.3];
        faceAlpha = 0.6;
        lineWidth = 1.5;
        p(3) = shadedAreaPlot(ax,RFmapDataStruct.spatialSupportDegsX, profileX(:,3), profileX(:,3)*0, ...
            faceColor, edgeColor, faceAlpha, lineWidth, '-');

    end

    
    hold(ax, 'on');

    YTicks = linspace(0, ceil(YLims(2)/YTickRoundingNumber)*YTickRoundingNumber, 10);
    YTicks = [-fliplr(YTicks) YTicks(2:end)];
    
    YTicksToBeLabeled = [YTicks(1) 0 YTicks(end)];
    YLims(2) = YTicks(end);
    YTickLabels = cell(1, numel(YTicks));
    for k = 1:numel(YTicks)
        if (ismember(YTicks(k), YTicksToBeLabeled))
            YTickLabels{k} = sprintf('%2.0f', YTicks(k));
        else
            YTickLabels{k} = '';
        end
    end

    

    plot(ax, theRFmapReferenceCentroid(1)*[1 1], YLims, 'k-', 'LineWidth', 1.0);
    plot(ax, visualizedRangeDegs*0.5*[-1 1] + theRFmapReferenceCentroid(1), [0 0], 'k-', 'LineWidth', 1.0);
    box(ax, 'off');
    grid(ax, 'on');
    if (size(profileX,2) == 1)
        axis(ax, 'square');
    end

    set(ax, 'XLim', XLims, 'YLim', YLims);
    set(ax, 'XTick', XTicks, 'YTick', YTicks, 'XTickLabel', sprintf('%2.2f\n', XTicks), 'YTickLabel', {}); 
    set(ax, 'FontSize', fontSize);
    if (labelYaxisTicks)
        set(ax, 'YTickLabel', YTickLabels);
    end

    xlabel(ax, 'space, x (deg)');
    xtickangle(ax, 0);
    % if (size(profileX,2) == 3)
    %     legend(ax, p, {'achromatic', 'L-cone', 'M-cone'});
    % end
end

function p = shadedAreaPlot(ax,x,y, baseline, faceColor, edgeColor, faceAlpha, lineWidth, lineStyle)
    x = [x fliplr(x)];
    y = [y y*0+baseline];
    px = reshape(x, [1 numel(x)]);
    py = reshape(y, [1 numel(y)]);
    pz = -10*eps*ones(size(py)); 
    p = patch(ax,px,py,pz,'FaceColor',faceColor,'EdgeColor', edgeColor, 'FaceAlpha', faceAlpha, 'LineWidth', lineWidth, 'lineStyle', lineStyle);
end


function [theProfileX, theProfileY] = generateRFprofile(theRF, theRFcenterCol, theRFcenterRow, profileType)

    switch (profileType)
        case 'radially averaged profile'
            % do nothing
        case 'line weighting function'
            theProfileX = mean(theRF, 1);
            theProfileY = mean(theRF,2);
            return;
        otherwise
            error('Unknown profile type: ''%s''.', profileType);
    end

    % Compute unit circle radial distances
    N = size(theRF,1);
    xx = (1:N)-theRFcenterCol;
    yy = (1:N)-theRFcenterRow;
    [X,Y] = meshgrid(xx,yy);
    r = sqrt(X.^2+Y.^2);

    % Compute bins of data matrix for averaging by accumarray
    binLocations = round(r)+1;

    % reshape matrices to vectors for accumarray operation
    binLocations = reshape(binLocations, N*N, 1);
    theRF = reshape(theRF, N*N, 1);

    % Compute radial average (mean)
    theRadialRFprofile = accumarray(binLocations,theRF,[],@mean);
  
    nn = 1:(N+1-theRFcenterCol);
    theRadiallySymmetricRFprofileX = zeros(1,N);
    for i = 1:numel(nn)
        if (theRFcenterCol-1+nn(i) <= N) && (theRFcenterCol-1+nn(i) >= 1)
            theRadiallySymmetricRFprofileX(theRFcenterCol-1+nn(i)) = theRadialRFprofile(nn(i));
        end
    end
    for i = 1:numel(nn)
        if (theRFcenterCol+1-nn(i) <= N) && (theRFcenterCol+1-nn(i) >= 1)
            theRadiallySymmetricRFprofileX(theRFcenterCol+1-nn(i)) = theRadialRFprofile(nn(i));
        end
    end


    nn = 1:(N+1-theRFcenterRow);
    theRadiallySymmetricRFprofileY = zeros(1,N);
    for i = 1:numel(nn)
        if (theRFcenterRow-1+nn(i) <= N) && (theRFcenterRow-1+nn(i) >= 1)
            theRadiallySymmetricRFprofileY(theRFcenterRow-1+nn(i)) = theRadialRFprofile(nn(i));
        end
    end
    for i = 1:numel(nn)
        if (theRFcenterRow+1-nn(i) <= N) && (theRFcenterRow+1-nn(i) >= 1)
            theRadiallySymmetricRFprofileY(theRFcenterRow+1-nn(i)) = theRadialRFprofile(nn(i));
        end
    end

    theProfileX = theRadiallySymmetricRFprofileX;
    theProfileY = theRadiallySymmetricRFprofileY;

end





function renderRFmap(ax, RFmapDataStruct, RFmapRange, contourData, RFcentroid, referenceCentroid, ...
    XLims, YLims, XTicks, YTicks, cLUT,  whichMap, plotTitle, ...
    noXLabel, noYLabel, fontSize)

    switch (whichMap)
        case 'raw'
            imagesc(ax, RFmapDataStruct.spatialSupportDegsX, ...
                        RFmapDataStruct.spatialSupportDegsY, ...
                        RFmapDataStruct.theRFmap);
            
        case 'smoothed'
            imagesc(ax, RFmapDataStruct.spatialSupportDegsX, ...
                        RFmapDataStruct.spatialSupportDegsY, ...
                        RFmapDataStruct.theSmoothedRFmap);
    end
    hold(ax, 'on');
    if (~isempty(contourData))
        S = contourData;
        S.FaceVertexCData = [0.85 0.85 0.85];
            S.FaceColor = 'flat';
            S.EdgeColor = [0 0 0];
            S.FaceAlpha = 0.0;
            S.LineWidth = 1.0;
            patch(S, 'Parent', ax)

    end

    
    plot(ax, referenceCentroid(1)*[1 1], [RFmapDataStruct.spatialSupportDegsY(1) RFmapDataStruct.spatialSupportDegsY(end)], 'k-', 'LineWidth', 1.0);
    plot(ax,  [RFmapDataStruct.spatialSupportDegsX(1) RFmapDataStruct.spatialSupportDegsX(end)], referenceCentroid(2)*[1 1], 'k-', 'LineWidth', 1.0);
    plot(ax, RFcentroid(1), RFcentroid(2), 'kx', 'MarkerSize', 14, 'LineWidth', 1.5);
    hold(ax, 'off');
    colormap(ax, cLUT);
    midPoint = (size(cLUT,1)-1)/2+1;
    %colorbar
    set(ax, 'Color', cLUT(midPoint,:));
    set(ax, 'CLim', RFmapRange);
    axis(ax, 'image'); axis(ax, 'xy');
    set(ax, 'XLim', XLims);
    set(ax, 'YLim', YLims);
    set(ax, 'XTick', XTicks, 'YTick', YTicks, ...
        'XTickLabel', sprintf('%2.2f\n', XTicks), 'YTickLabel', sprintf('%2.2f\n', YTicks));
    set(ax, 'FontSize', fontSize);
    if (noXLabel)
        set(ax, 'XTick', {});
    else
        xlabel(ax, 'space, x (deg)');
    end
    if (noYLabel)
        set(ax, 'YTick', {});
    else
        ylabel(ax, 'space, y (deg)');
    end
    title(ax, plotTitle);
end


function [contourData, centerOfMass] = ellipseContourFromSubregionRFmap(RFmapDataStruct)

    xSupport = RFmapDataStruct.spatialSupportDegsX;
    ySupport = RFmapDataStruct.spatialSupportDegsY;
   
    zLevel = 0.1;
    centerSubregionContourSamples = 30;

    RF = RFmapDataStruct.theSmoothedRFmap;

    
    maxRF = max(RF(:));
    minRF = min(RF(:));
    if (abs(minRF) > maxRF)
        RF = -RF;
    end

    % Find center of mass of points contributing to the max response
    [X,Y] = meshgrid(xSupport,ySupport);
    absRF = abs(RF);
    absRF = absRF / max(abs(RF(:)));
    absRF(absRF<0.01) = 0;
    centerOfMass(1) = sum(X(:).*absRF(:))/sum(absRF(:));
    centerOfMass(2) = sum(Y(:).*absRF(:))/sum(absRF(:));


    % Binarize
    RF = RF / max(RF(:));
    RF(RF<zLevel) = 0.0;
    RF(RF>0) = 1.0;
    BW = imbinarize(RF);

    % Extract the maximum area
    BW = imclearborder(BW);
    BW = bwareafilt(BW,1);

    % Calculate centroid, orientation and major/minor axis length of the ellipse
    s = regionprops(BW,{'Centroid','Orientation','MajorAxisLength','MinorAxisLength'});
    if (isempty(s))
        fprintf(2, 'Could not fit an ellipse to subregion map. Returning empty contour.\n')
        contourData = [];
        centroidPos = [];
        return;
    end
    
    
    % Calculate the ellipse line
    theta = linspace(0, 2*pi, centerSubregionContourSamples);
    col = (s.MajorAxisLength/2)*cos(theta);
    row = (s.MinorAxisLength/2)*sin(theta);
    M = makehgtform('translate',[s.Centroid, 0],'zrotate',deg2rad(-1*s.Orientation));
    D = M*[col;row;zeros(1,numel(row));ones(1,numel(row))];

    x = D(1,:);
    y = D(2,:);
    x = (x-1)/(numel(xSupport)-1) * (xSupport(end)-xSupport(1)) + xSupport(1); 
    y = (y-1)/(numel(ySupport)-1) * (ySupport(end)-ySupport(1)) + ySupport(1); 

    v = [x(:) y(:)];
    f = 1:numel(x);
    s = struct('faces', f, 'vertices', v);
    contourData = s; 
end

function c = redblueLUT()
B = 2*(1-(1:255)/255);
B(B>1) = 1;

R = fliplr(B);
G = 1-abs(-1+2*(1:255)/255);

c = [R(:) G(:) B(:)];

% c = [...
% 25      82      255; ...
% 27      84      255; ...
% 28      85      255; ...
% 30      86      255; ...
% 31      87      255; ...
% 33      88      255; ...
% 34      89      255; ...
% 36      90      255; ...
% 37      92      255; ...
% 39      93      255; ...
% 40      94      255; ...
% 42      95      255; ...
% 43      96      255; ...
% 45      97      255; ...
% 46      98      255; ...
% 48      100     255; ...
% 49      101     255; ...
% 51      102     255; ...
% 53      103     255; ...
% 54      104     255; ...
% 56      105     255; ...
% 57      106     255; ...
% 59      108     255; ...
% 60      109     255; ...
% 62      110     255; ...
% 63      111     255; ...
% 65      112     255; ...
% 66      113     255; ...
% 68      115     255; ...
% 69      116     255; ...
% 71      117     255; ...
% 72      118     255; ...
% 74      119     255; ...
% 75      120     255; ...
% 77      121     255; ...
% 79      123     255; ...
% 80      124     255; ...
% 82      125     255; ...
% 83      126     255; ...
% 85      127     255; ...
% 86      128     255; ...
% 88      129     255; ...
% 89      131     255; ...
% 91      132     255; ...
% 92      133     255; ...
% 94      134     255; ...
% 95      135     255; ...
% 97      136     255; ...
% 98      137     255; ...
% 100     139     255; ...
% 102     140     255; ...
% 103     141     255; ...
% 105     142     255; ...
% 106     143     255; ...
% 108     144     255; ...
% 109     145     255; ...
% 111     147     255; ...
% 112     148     255; ...
% 114     149     255; ...
% 115     150     255; ...
% 117     151     255; ...
% 118     152     255; ...
% 120     154     255; ...
% 121     155     255; ...
% 123     156     255; ...
% 124     157     255; ...
% 126     158     255; ...
% 128     159     255; ...
% 129     160     255; ...
% 131     162     255; ...
% 132     163     255; ...
% 134     164     255; ...
% 135     165     255; ...
% 137     166     255; ...
% 138     167     255; ...
% 140     168     255; ...
% 141     170     255; ...
% 143     171     255; ...
% 144     172     255; ...
% 146     173     255; ...
% 147     174     255; ...
% 149     175     255; ...
% 150     176     255; ...
% 152     178     255; ...
% 154     179     255; ...
% 155     180     255; ...
% 157     181     255; ...
% 158     182     255; ...
% 160     183     255; ...
% 161     185     255; ...
% 163     186     255; ...
% 164     187     255; ...
% 166     188     255; ...
% 167     189     255; ...
% 169     190     255; ...
% 170     191     255; ...
% 172     193     255; ...
% 173     194     255; ...
% 175     195     255; ...
% 176     196     255; ...
% 178     197     255; ...
% 180     198     255; ...
% 181     199     255; ...
% 183     201     255; ...
% 184     202     255; ...
% 186     203     255; ...
% 187     204     255; ...
% 189     205     255; ...
% 190     206     255; ...
% 192     207     255; ...
% 193     209     255; ...
% 195     210     255; ...
% 196     211     255; ...
% 198     212     255; ...
% 199     213     255; ...
% 201     214     255; ...
% 202     215     255; ...
% 204     217     255; ...
% 206     218     255; ...
% 207     219     255; ...
% 209     220     255; ...
% 210     221     255; ...
% 212     222     255; ...
% 213     224     255; ...
% 215     225     255; ...
% 216     226     255; ...
% 236     242     255; ...
% 255     255     255; ...
% 255     236     236; ...
% 255     216     216; ...
% 255     215     215; ...
% 255     213     213; ...
% 255     212     212; ...
% 255     210     210; ...
% 255     209     209; ...
% 255     207     207; ...
% 255     206     206; ...
% 255     204     204; ...
% 255     202     202; ...
% 255     201     201; ...
% 255     199     199; ...
% 255     198     198; ...
% 255     196     196; ...
% 255     195     195; ...
% 255     193     193; ...
% 255     192     192; ...
% 255     190     190; ...
% 255     189     189; ...
% 255     187     187; ...
% 255     186     186; ...
% 255     184     184; ...
% 255     183     183; ...
% 255     181     181; ...
% 255     180     180; ...
% 255     178     178; ...
% 255     176     176; ...
% 255     175     175; ...
% 255     173     173; ...
% 255     172     172; ...
% 255     170     170; ...
% 255     169     169; ...
% 255     167     167; ...
% 255     166     166; ...
% 255     164     164; ...
% 255     163     163; ...
% 255     161     161; ...
% 255     160     160; ...
% 255     158     158; ...
% 255     157     157; ...
% 255     155     155; ...
% 255     154     154; ...
% 255     152     152; ...
% 255     150     150; ...
% 255     149     149; ...
% 255     147     147; ...
% 255     146     146; ...
% 255     144     144; ...
% 255     143     143; ...
% 255     141     141; ...
% 255     140     140; ...
% 255     138     138; ...
% 255     137     137; ...
% 255     135     135; ...
% 255     134     134; ...
% 255     132     132; ...
% 255     131     131; ...
% 255     129     129; ...
% 255     128     128; ...
% 255     126     126; ...
% 255     124     124; ...
% 255     123     123; ...
% 255     121     121; ...
% 255     120     120; ...
% 255     118     118; ...
% 255     117     117; ...
% 255     115     115; ...
% 255     114     114; ...
% 255     112     112; ...
% 255     111     111; ...
% 255     109     109; ...
% 255     108     108; ...
% 255     106     106; ...
% 255     105     105; ...
% 255     103     103; ...
% 255     101     101; ...
% 255     100     100; ...
% 255     98      98; ...
% 255     97      97; ...
% 255     95      95; ...
% 255     94      94; ...
% 255     92      92; ...
% 255     91      91; ...
% 255     89      89; ...
% 255     88      88; ...
% 255     86      86; ...
% 255     85      85; ...
% 255     83      83; ...
% 255     82      82; ...
% 255     80      80; ...
% 255     79      79; ...
% 255     77      77; ...
% 255     75      75; ...
% 255     74      74; ...
% 255     72      72; ...
% 255     71      71; ...
% 255     69      69; ...
% 255     68      68; ...
% 255     66      66; ...
% 255     65      65; ...
% 255     63      63; ...
% 255     62      62; ...
% 255     60      60; ...
% 255     59      59; ...
% 255     57      57; ...
% 255     56      56; ...
% 255     54      54; ...
% 255     53      53; ...
% 255     51      51; ...
% 255     49      49; ...
% 255     48      48; ...
% 255     46      46; ...
% 255     45      45; ...
% 255     43      43; ...
% 255     42      42; ...
% 255     40      40; ...
% 255     39      39; ...
% 255     37      37; ...
% 255     36      36; ...
% 255     34      34; ...
% 255     33      33; ...
% 255     31      31; ...
% 255     30      30; ...
% 255     28      28; ...
% 255     27      27; ...
% 255     25      25];
% c = c /255;
end
