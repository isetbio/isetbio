function [theConeMosaicMSequenceLinearModulationResponses, theConeMosaicNullResponses, ...
          theConeMosaicMSequenceForwardModulationResponses, theConeMosaicMSequenceInverseModulationResponses, ...
          mSequenceIndicatorFunctions, spatialSupportDegs] = computeConeMosaicMSequenceRFmappingLinearResponses(...
                theConeMosaic, theOptics,  ...
                thePresentationDisplay, ...
                stimParams, ...
                stimPositionDegs, varargin)

    p = inputParser;
    p.addParameter('parPoolSize', [], @(x)(isempty(x)||(isscalar(x))));
    p.addParameter('visualizeResponses', false, @islogical);
    p.addParameter('customConeFundamentals', [], @(x)(isempty(x)||(isstruct(x))));
    p.parse(varargin{:});
    parPoolSize = p.Results.parPoolSize;
    visualizeResponses = p.Results.visualizeResponses;
    customConeFundamentals = p.Results.customConeFundamentals;


    % Compute the M-sequence spatial patterns
    visualizePatterns = ~true;

    mSequenceIndicatorFunctions = rfMappingStimulusGenerator.binaryMsequencePatterns(...
                    stimParams.rfPixelsAcross, ...
                    'ternaryInsteadOfBinaryMsequence', stimParams.ternaryInsteadOfBinaryMsequence, ...
                    'mSequenceBitLength', stimParams.mSequenceBitLength, ...
                    'visualizePatterns', visualizePatterns);

    % Compute the null stimulus scene and retrieve theConeFundamentalsStruct
    % so we can pass it to each stimulus frame response computation
    fprintf('Computing null scene\n');
    % Expand the m-sequence indicator function for the first frame
    spatialModulationPattern = rfMappingStimulusGenerator.expandFrame(squeeze(mSequenceIndicatorFunctions(1,:,:)), stimParams.rfPixelRetinalPixelsWithin);
    [~, theNullStimulusScene, spatialSupportDegs, theConeFundamentalsStruct] = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, spatialModulationPattern, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 0, ...
                'customConeFundamentals', customConeFundamentals);

   
    fprintf('Computing null scene response\n');
    % Compute the optical image of the null scene
    theOptics  = oiCompute(theNullStimulusScene, theOptics);

    % Compute the cone mosaic response to the null stimulus
    theConeMosaicNullResponses = theConeMosaic.compute(theOptics, ...
                    'opticalImagePositionDegs', stimPositionDegs, ...
                    'nTrials', 1);

    coneIndicesWithZeroNullResponse = find(theConeMosaicNullResponses == 0);
    normalizingResponses = 1./theConeMosaicNullResponses;
    normalizingResponses(coneIndicesWithZeroNullResponse) = 0;
    normalizingResponses = reshape(normalizingResponses, [1 1 numel(normalizingResponses)]);

    % Allocate memory for the input cone mosaic modulation responses
    nStim = size(mSequenceIndicatorFunctions,1);
    theConeMosaicMSequenceLinearModulationResponses = zeros(nStim, theConeMosaic.conesNum, 'single');
    theConeMosaicMSequenceForwardModulationResponses = zeros(nStim, theConeMosaic.conesNum, 'single');
    theConeMosaicMSequenceInverseModulationResponses = zeros(nStim, theConeMosaic.conesNum, 'single');

    % Compute the input cone mosaic modulation responses
    if ((~isempty(parPoolSize)) && (parPoolSize>1)) || (isempty(parPoolSize))
         % Reset parpool
         [shutdownParPoolOnceCompleted, numWorkers] = MosaicPoolingOptimizer.resetParPool(parPoolSize);

         theOI = theOptics;
         fprintf('About to start parallel computation of responses to m-sequence stimuli using %d workers.\n', numWorkers);
         parfor iFrame = 1:nStim

             % Capture time we begin
             tStart = cputime;
             
             % Expand the m-sequence indicator function for the current frame
             spatialModulationPattern = rfMappingStimulusGenerator.expandFrame(squeeze(mSequenceIndicatorFunctions(iFrame,:,:)), stimParams.rfPixelRetinalPixelsWithin);
             spatialModulationPattern = reshape(spatialModulationPattern, [1 size(spatialModulationPattern ,1) size(spatialModulationPattern ,2)]);

             % Forward polarity
             theForwardPolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, spatialModulationPattern, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 1, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

             % Inverse polatity
             theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -spatialModulationPattern, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 1, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

             % Get scene corresponding to the forward polarity of the stimulus frame
             theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theFrameOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses to the forward polarity stimulus
             noiseFreeAbsorptionsCountForwardPolarity = theConeMosaic.compute(...
                 theFrameOI, ...
                 'opticalImagePositionDegs', stimPositionDegs, ...
                 'nTrials', 1);

             % Convert  absorption responses to modulation responses (forward polarity)
             noiseFreeAbsorptionsModulationForwardPolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountForwardPolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % Get scene corresponding to the inverse polarity of this stimulus frame
             theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

             % Compute the optical image of the frame scene
             theFrameOI = oiCompute(theFrameScene, theOI);

             % Compute the cone mosaic responses to the inverse polarity stimulus
             noiseFreeAbsorptionsCountInversePolarity = theConeMosaic.compute(...
                 theFrameOI, ...
                 'opticalImagePositionDegs', stimPositionDegs, ...
                 'nTrials', 1);

             % Convert  absorption responses to modulation responses (inverse polarity)
             noiseFreeAbsorptionsModulationInversePolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountInversePolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % The linear response: forward - inverse
             theConeMosaicMSequenceLinearModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

             % The forward response
             theConeMosaicMSequenceForwardModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:));

             % The inverse response
             theConeMosaicMSequenceInverseModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

             % Report time to completion
             fprintf('Cone mosaic response computation for m-sequence frame %d of %d took %f seconds.\n', ...
                iFrame, nStim, cputime - tStart);
         end % iFrame

         if (shutdownParPoolOnceCompleted)
            poolobj = gcp('nocreate'); 
            delete(poolobj);
         end

    else
        for iFrame = 1:nStim
            fprintf('Computing cone mosaic response for m-sequence frame %d of %d (serially).\n', iFrame, nStim);

            % Expand the m-sequence indicator function for the current frame
            spatialModulationPattern = rfMappingStimulusGenerator.expandFrame(squeeze(mSequenceIndicatorFunctions(iFrame,:,:)), stimParams.rfPixelRetinalPixelsWithin);
            spatialModulationPattern = reshape(spatialModulationPattern, [1 size(spatialModulationPattern ,1) size(spatialModulationPattern ,2)]);

            theForwardPolarityRFMappingStimulusScenes =  rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, spatialModulationPattern, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 1, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

            theInversePolarityRFMappingStimulusScenes = rfMappingStimulusGenerator.generateStimulusFramesOnPresentationDisplay(...
                thePresentationDisplay, stimParams, -spatialModulationPattern, ...
                'validateScenes', false, ...
                'sceneIndexToCompute', 1, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct);

            % Get scene corresponding to this forward polarity of the stimulus frame
            theFrameScene = theForwardPolarityRFMappingStimulusScenes{1};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountForwardPolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

            % Convert  absorption responses to modulation responses (forward polarity)
            noiseFreeAbsorptionsModulationForwardPolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountForwardPolarity, theConeMosaicNullResponses), ...
                normalizingResponses);


            % Get scene corresponding to the inverse polarity of this stimulus frame
            theFrameScene = theInversePolarityRFMappingStimulusScenes{1};

            % Compute the optical image of the frame scene
            theOptics = oiCompute(theFrameScene, theOptics);

            % Compute the cone mosaic responses
            noiseFreeAbsorptionsCountInversePolarity = ...
                        theConeMosaic.compute(theOptics, ...
                        'opticalImagePositionDegs', stimPositionDegs, ...
                        'nTrials', 1);

 
            % Convert  absorption responses to modulation responses (inverse polarity)
            noiseFreeAbsorptionsModulationInversePolarity = bsxfun(@times,...
                bsxfun(@minus, noiseFreeAbsorptionsCountInversePolarity, theConeMosaicNullResponses), ...
                normalizingResponses);

             % The linear response: forward - inverse
             theConeMosaicMSequenceLinearModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:) - ...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

            % The forward response
             theConeMosaicMSequenceForwardModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationForwardPolarity(1,1,:));

             % The inverse response
             theConeMosaicMSequenceInverseModulationResponses(iFrame,:) = single(...
                 noiseFreeAbsorptionsModulationInversePolarity(1,1,:));

            if (visualizeResponses)
                hFig = figure(2); clf;
                set(hFig, 'Position', [10 10 2000 800]);
                ax1 = subplot(1,3,1);
                ax2 = subplot(1,3,2);
                ax3 = subplot(1,3,3);
    
                 theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax1, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15]);

                theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax2, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15], ...
                    'activation', noiseFreeAbsorptionsModulationForwardPolarity, ...
                    'activationRange', max(abs(noiseFreeAbsorptionsModulationForwardPolarity(:)))*[-1 1]);
                
                theConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax3, ...
                    'crossHairsAtPosition', stimPositionDegs, ...
                    'domainVisualizationLimits', [stimPositionDegs(1)-0.15 stimPositionDegs(1)+0.15  stimPositionDegs(2)-0.15 stimPositionDegs(2)+0.15], ...
                    'activation', noiseFreeAbsorptionsModulationInversePolarity, ...
                    'activationRange', max(abs(noiseFreeAbsorptionsModulationForwardPolarity(:)))*[-1 1]);
                drawnow;
                pause
            end
        end
    end
end