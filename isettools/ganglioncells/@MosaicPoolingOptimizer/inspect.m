function inspect(obj, gridNodeIndex, opticsParams, optimizedRGCpoolingObjectsFileName, varargin)
    % Parse optional input
%     p = inputParser;
%     p.addParameter('visualize', [], @(x)(isempty(x)||(isscalar(x))));
%     p.parse(varargin{:});

    % Optimized RGCpooling object filename
    optimizedRGCpoolingObjectsFileNameForThisNode = ...
        strrep(optimizedRGCpoolingObjectsFileName, '.mat', sprintf('_ForGridNode_%d.mat', gridNodeIndex));

    fprintf('Loading optimized L- and M-cone RF compute structs from %s\n', optimizedRGCpoolingObjectsFileNameForThisNode);
    load(optimizedRGCpoolingObjectsFileNameForThisNode, ...
        'theLconeRFcomputeStruct', ...
        'theMconeRFcomputeStruct');

    LconeRGCindex = obj.targetRGCindicesWithLconeMajorityCenter(gridNodeIndex);
    figNo = 10000 + gridNodeIndex;
    figTitle = sprintf('grid no %d of %d L-cone center RGC %d', ...
        gridNodeIndex, numel(obj.conesNumPooledByTheRFcenterGrid), LconeRGCindex);
    pdfFilename = strrep(optimizedRGCpoolingObjectsFileNameForThisNode, '.mat', '_Lcone');

    inspectConeSpecificRFcomputeStruct(figNo, figTitle, pdfFilename, ...
        opticsParams, ...
        obj.theRGCMosaic.rgcRFpositionsDegs(LconeRGCindex,:), ...
        obj.theRGCMosaic.inputConeMosaic, ...
        theLconeRFcomputeStruct);

    MconeRGCindex = obj.targetRGCindicesWithMconeMajorityCenter(gridNodeIndex);
    figNo = 20000 + gridNodeIndex;
    figTitle = sprintf('grid no %d of %d M-cone center RGC %d', ...
        gridNodeIndex, numel(obj.conesNumPooledByTheRFcenterGrid), MconeRGCindex);
    pdfFilename = strrep(optimizedRGCpoolingObjectsFileNameForThisNode, '.mat', '_Mcone');
    inspectConeSpecificRFcomputeStruct(figNo, figTitle, pdfFilename, ...
        opticsParams, ...
        obj.theRGCMosaic.rgcRFpositionsDegs(MconeRGCindex,:), ...
        obj.theRGCMosaic.inputConeMosaic, ...
        theMconeRFcomputeStruct);

end

function inspectConeSpecificRFcomputeStruct(figNo, figTitle, pdfFilename, ...
    opticsParams, rgcRFposDegs, inputConeMosaic, theConeSpecificRFcomputeStruct)

    % Retrieve the saved data
    targetVisualSTFparams = theConeSpecificRFcomputeStruct.theTargetSTFparams;
    theFinalSTFdata = theConeSpecificRFcomputeStruct.theAchievedSTFdata;
    retinalConePoolingParams = theConeSpecificRFcomputeStruct.retinalConePoolingParams;
    retinalConePoolingModel = theConeSpecificRFcomputeStruct.modelConstants.retinalConePoolingModel;
    theFinalPooledConeIndicesAndWeights = theConeSpecificRFcomputeStruct.theFinalPooledConeIndicesAndWeights;
    rmseSequence = [];

    [hFig, ff] = MosaicPoolingOptimizer.visualizeOptimizationProgress(...
                figNo, figTitle, ...
                targetVisualSTFparams, opticsParams, ...
                theFinalSTFdata, retinalConePoolingParams, retinalConePoolingModel, ...
                theFinalPooledConeIndicesAndWeights, ...
                rmseSequence);

    figure(hFig);

    % Replace the DoG params with a correspondence between H1 cell data and
    % our surround params
    ax = subplot('Position', ff.subplotPosVectors(1,2).v);
    MSreadyPlot.renderFittedH1paramsCorrespondenceToPackerDaceyData(ax, ...
        retinalConePoolingParams, ff);
    
    
    % Add the RF center cone pooling map
    tickSeparationArcMin = 3;
    spatialSupportRangeArcMin = tickSeparationArcMin*6;
    
    ax = subplot('Position',  ff.subplotPosVectors(2,1).v);
    cla(ax, 'reset');

    centerLineWeightingFunctions = MSreadyPlot.renderConePoolingPlot(ax, ...
        inputConeMosaic, ...
        rgcRFposDegs, ...
        theFinalPooledConeIndicesAndWeights.centerConeIndices, ...
        theFinalPooledConeIndicesAndWeights.centerConeWeights, ...
        ff, ...
        'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
        'tickSeparationArcMin', tickSeparationArcMin, ...
        'plotTitle', 'RF center');

    
    ax = subplot('Position',  ff.subplotPosVectors(2,2).v);
    cla(ax, 'reset');

    surroundLineWeightingFunctions = MSreadyPlot.renderConePoolingPlot(ax, ...
        inputConeMosaic, ...
        rgcRFposDegs, ...
        theFinalPooledConeIndicesAndWeights.surroundConeIndices, ...
        theFinalPooledConeIndicesAndWeights.surroundConeWeights, ...
        ff, ...
        'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
        'tickSeparationArcMin', tickSeparationArcMin, ...
        'plotTitle', 'RF surround', ...
        'noYLabel', true);



    % Add the line weighting functions
    % Visualized sensitivity range
    %sensitivityRange(1) = -1.05*max([max(surroundLineWeightingFunctions.x.amplitude(:)) max(surroundLineWeightingFunctions.y.amplitude(:))]);
    sensitivityRange(2) =  1.0*max([max(centerLineWeightingFunctions.x.amplitude(:)) max(centerLineWeightingFunctions.y.amplitude(:))]);
    sensitivityRange(1) = -0.8*sensitivityRange(2);

    centerLineWeightingFunctions.x.amplitude = centerLineWeightingFunctions.x.amplitude / max(sensitivityRange);
    centerLineWeightingFunctions.y.amplitude = centerLineWeightingFunctions.y.amplitude / max(sensitivityRange);
    surroundLineWeightingFunctions.x.amplitude = surroundLineWeightingFunctions.x.amplitude / max(sensitivityRange);
    surroundLineWeightingFunctions.y.amplitude = surroundLineWeightingFunctions.y.amplitude / max(sensitivityRange);
    sensitivityRange = sensitivityRange / max(sensitivityRange);

    ax = subplot('Position',  ff.subplotPosVectors(2,3).v);
    MSreadyPlot.renderConePoolingLineWeightingFunctions(ax, ...
        centerLineWeightingFunctions.x, surroundLineWeightingFunctions.x, ...
        sensitivityRange, ff, ...
        'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
        'tickSeparationArcMin', tickSeparationArcMin, ...
        'plotTitle', 'line weighting functions, X');

   

    ax = subplot('Position',  ff.subplotPosVectors(2,4).v);
    MSreadyPlot.renderConePoolingLineWeightingFunctions(ax, ...
        centerLineWeightingFunctions.y, surroundLineWeightingFunctions.y, ...
        sensitivityRange, ff, ...
        'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
        'tickSeparationArcMin', tickSeparationArcMin, ...
        'plotTitle', 'line weighting functions, Y', ...
        'noYLabel', true);


    pdfFilename = strrep(sprintf('%s.pdf',pdfFilename), 'MosaicOptimizerResources', 'MosaicOptimizerPDFs');
    NicePlot.exportFigToPDF(pdfFilename, hFig, 300);

    close(hFig);
end

