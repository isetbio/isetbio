function visualizeRetinalConePoolingRFmapOfRGCwithIndex(obj, theRGCindex, theAxes, varargin)
    % Parse optional input
    p = inputParser;
    p.addParameter('withFigureFormat', [], @(x)(isempty(x)||(isstruct(x))));
    p.parse(varargin{:});
    ff = p.Results.withFigureFormat;

    % Generate the visualization cache
    xSupport = [];
    ySupport = []; 
    obj.generateVisualizationCache(xSupport, ySupport);
    theContourData = obj.visualizationCache.rfCenterContourData{theRGCindex};

    % The cell position
    theCurrentRGCposition = obj.rgcRFpositionsDegs(theRGCindex,:);

    % Retrieve this cell's  center cone indices and weights
    connectivityVector = full(squeeze(obj.rgcRFcenterConePoolingMatrix(:, theRGCindex)));
    centerConeIndicesForCurrentRGC = find(connectivityVector > 0.0001);
    centerConeWeightsForCurrentRGC = connectivityVector(centerConeIndicesForCurrentRGC);

    % Retrieve this cell's surround cone indices and weights
    connectivityVector = full(squeeze(obj.rgcRFsurroundConePoolingMatrix(:, theRGCindex)));
    surroundConeIndicesForCurrentRGC = find(connectivityVector > 0.0001);
    surroundConeWeightsForCurrentRGC = connectivityVector(surroundConeIndicesForCurrentRGC);

    inputConeMosaic = obj.inputConeMosaic;

    tickSeparationArcMin = 6;
    spatialSupportRangeArcMin = tickSeparationArcMin*4;


    centerLineWeightingFunctions = mRGCMosaic.renderSubregionConePoolingPlot(theAxes{1,1}, ...
            inputConeMosaic, ...
            theCurrentRGCposition, ...
            centerConeIndicesForCurrentRGC, ...
            centerConeWeightsForCurrentRGC, ...
            'withFigureFormat', ff, ...
            'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
            'tickSeparationArcMin', tickSeparationArcMin, ...
            'plotTitle', '', ...
            'noXLabel', true, ...
            'noYLabel', true, ...
            'noYTicks', true, ...
            'xAxisTickAngleRotationDegs', 0);

    cla(theAxes{1,1}, 'reset');

    % Plot the RFs
    surroundLineWeightingFunctions = mRGCMosaic.renderSubregionConePoolingPlot(theAxes{1,1}, ...
            inputConeMosaic, ...
            theCurrentRGCposition, ...
            surroundConeIndicesForCurrentRGC, ...
            surroundConeWeightsForCurrentRGC, ...
            'withFigureFormat', ff, ...
            'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
            'tickSeparationArcMin', tickSeparationArcMin, ...
            'plotTitle', '', ...
            'noXLabel', false, ...
            'noYLabel', false, ...
            'noYTicks', false, ...
            'xAxisTickAngleRotationDegs', 0);

    S.Vertices = theContourData{1}.vertices;
    S.Faces = theContourData{1}.faces;
    S.FaceVertexCData = [0.5 0.5 0.5];

    S.FaceColor = 'flat';
    S.EdgeColor = [0 0 0];
    S.FaceAlpha = 0.0;
    S.LineWidth = 1.0;
    patch(S, 'Parent', theAxes{1,1})


    % Add the line weighting functions
    sensitivityRange(2) =  max([max(centerLineWeightingFunctions.x.amplitude(:)) max(centerLineWeightingFunctions.y.amplitude(:))]);
    sensitivityRange(1) = -0.4*sensitivityRange(2);
    
    centerLineWeightingFunctions.x.amplitude = centerLineWeightingFunctions.x.amplitude / max(sensitivityRange);
    centerLineWeightingFunctions.y.amplitude = centerLineWeightingFunctions.y.amplitude / max(sensitivityRange);
    surroundLineWeightingFunctions.x.amplitude = surroundLineWeightingFunctions.x.amplitude / max(sensitivityRange);
    surroundLineWeightingFunctions.y.amplitude = surroundLineWeightingFunctions.y.amplitude / max(sensitivityRange);
    sensitivityRange = sensitivityRange / max(sensitivityRange);

    mRGCMosaic.renderSubregionConePoolingLineWeightingFunctions(theAxes{1,2}, ...
            centerLineWeightingFunctions.x, surroundLineWeightingFunctions.x, ...
            sensitivityRange, 'x', ...
            'withFigureFormat', ff, ...
            'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
            'tickSeparationArcMin', tickSeparationArcMin, ...
            'plotTitle', '', ...
            'noYTicks', ~true, ...
            'xAxisTickAngleRotationDegs', 0);

    mRGCMosaic.renderSubregionConePoolingLineWeightingFunctions(theAxes{1,3}, ...
            centerLineWeightingFunctions.y, surroundLineWeightingFunctions.y, ...
            sensitivityRange, 'y', ...
            'withFigureFormat', ff, ...
            'spatialSupportRangeArcMin', spatialSupportRangeArcMin, ...
            'tickSeparationArcMin', tickSeparationArcMin, ...
            'plotTitle', '', ...
            'noYLabel', true, ...
            'noYTicks', true, ...
            'xAxisTickAngleRotationDegs', 0);

end