%
% RGCMosaicAnalyzer.compute.inputConeMosaicSTFsForStimulusChromaticityAndOptics
%
function inputConeMosaicSTFsForStimulusChromaticityAndOptics(...
    theMRGCMosaic, opticsForSTFresponses, customRefractionDiopters, ...
    STFchromaticity, coneFundamentalsOptimizedForStimPosition, ...
    theInputConeMosaicSTFResponsesFullFileName, ...
    theMRGCMosaicSTFResponsesFullFileName, ...
    visualizeInputConeMosaicResponses, ...
    visualizePSFonTopOfConeMosaic, ...
    varargin)


    p = inputParser;
    p.addParameter('mRGCNonLinearityParams', [], @(x)(isempty(x))||(isstruct(x)));
    p.addParameter('customTemporalFrequencyAndContrast', [], @(x)(isempty(x))||(isstruct(x)));
    p.addParameter('debugInputConeMosaicPcurrentResponse', false, @islogical);
    % Execute the parser
    p.parse(varargin{:});
    mRGCNonLinearityParams = p.Results.mRGCNonLinearityParams;
    customTemporalFrequencyAndContrast = p.Results.customTemporalFrequencyAndContrast;
    debugInputConeMosaicPcurrentResponse = p.Results.debugInputConeMosaicPcurrentResponse;

    % Generate the optics
    [theOI, thePSF] = RGCMosaicAnalyzer.compute.opticsForResponses(...
        theMRGCMosaic, opticsForSTFresponses, customRefractionDiopters, visualizePSFonTopOfConeMosaic);

    % Determine the stimulus pixel resolution to be a fraction of the minimum cone aperture or cone spacing in the mosaic
    % here, half of the cone spacing
    theMetric = 'cone aperture';  % choose from {'cone aperture' or cone spacing'}
    mosaicRadialEcc = sqrt(sum(theMRGCMosaic.eccentricityDegs.^2,2));
    if ((strcmp(opticsForSTFresponses, 'adaptiveOptics6MM')) || (strcmp(opticsForSTFresponses, 'adaptiveOptics6MMwithLCA')))
        theFraction = 0.1;
    else
        theFraction = 0.25;
    end
    targetRGCindices =  1:theMRGCMosaic.rgcsNum;
    stimulusResolutionDegs = RGCMosaicConstructor.helper.simulateExperiment.stimulusResolutionFromConeApertureOrConeSpacing(...
                theMRGCMosaic, targetRGCindices, theFraction, theMetric);

    sfSupport = logspace(log10(0.01), log10(120), 20);
    orientationDeltaDegs = 30;
    spatialPhaseIncrementDegs = 30;

    STFparamsStruct = struct(...
        'backgroundChromaticity', [0.301 0.301], ...
        'backgroundLuminanceCdM2', 40.0, ...
        'chromaticity', STFchromaticity, ...
        'coneFundamentalsOptimizedForStimPosition', coneFundamentalsOptimizedForStimPosition, ...
        'resolutionDegs', stimulusResolutionDegs, ...                       % to be determined separately for each optimization position
        'sfSupport', sfSupport, ...
        'orientationDeltaDegs', orientationDeltaDegs, ...
        'spatialPhaseIncrementDegs', spatialPhaseIncrementDegs, ...
        'positionDegs', theMRGCMosaic.eccentricityDegs, ...  
        'sizeDegs', 1.1*max(theMRGCMosaic.inputConeMosaic.sizeDegs));

    RGCMosaicConstructor.helper.simulateExperiment.spatialTransferFunction(...
        theMRGCMosaic, theOI, ...
        STFparamsStruct, ...
        theInputConeMosaicSTFResponsesFullFileName, ...
        theMRGCMosaicSTFResponsesFullFileName, ...
        'mRGCNonLinearityParams', mRGCNonLinearityParams, ...
        'customTemporalFrequencyAndContrast', customTemporalFrequencyAndContrast, ...
        'debugInputConeMosaicPcurrentResponse', debugInputConeMosaicPcurrentResponse, ...
        'computeInputConeMosaicResponses', true, ...
        'computeMRGCMosaicResponses', false, ...
        'visualizeResponse', visualizeInputConeMosaicResponses);
end

