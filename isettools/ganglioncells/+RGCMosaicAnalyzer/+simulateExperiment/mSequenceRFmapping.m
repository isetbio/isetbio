function mSequenceRFmapping(theMRGCMosaic, theOI, ...
	RFmappingParamsStruct, theInputConeMosaicRFmappingResponsesFullFileName, ...
	theMRGCMosaicRFmappingResponsesFullFileName, ...
    varargin)

	% Parse input
    p = inputParser;
    % Optional params
    p.addParameter('computeInputConeMosaicResponses', false, @islogical);
    p.addParameter('computeMRGCMosaicResponses', false, @islogical);
    p.addParameter('visualizeInputConeMosaicResponses', false, @islogical);
    p.parse(varargin{:});

    computeInputConeMosaicResponses = p.Results.computeInputConeMosaicResponses;
    computeMRGCMosaicResponses = p.Results.computeMRGCMosaicResponses;
    visualizeInputConeMosaicResponses = p.Results.visualizeInputConeMosaicResponses;

    if (computeInputConeMosaicResponses)
    	inputConeMosaicMsequenceRFmapping(...
    		theMRGCMosaic, theOI, ...
        	RFmappingParamsStruct, ...
        	theInputConeMosaicRFmappingResponsesFullFileName, ...
        	visualizeInputConeMosaicResponses);
  	end

  	if (computeMRGCMosaicResponses)
	    mRGCMosaicMsequenceRFmapping(...
	    	theMRGCMosaic, ...
	        theInputConeMosaicRFmappingResponsesFullFileName, ...
	        theMRGCMosaicRFmappingResponsesFullFileName, ...
	        visualizeInputConeMosaicResponses);
  end
end

function mRGCMosaicMsequenceRFmapping(thePassedMRGCMosaic, theInputConeMosaicResponsesFullFileName, theMRGCMosaicResponsesFullFileName, visualizeInputConeMosaicResponses)

	fprintf('Loading computed input cone mosaic m-sequence responses from %s.\n', theInputConeMosaicResponsesFullFileName);
  	load(theInputConeMosaicResponsesFullFileName, ...
	    'theMRGCMosaic', ...
	    'RFmappingParamsStruct', ...
	    'stimParams', ...
	    'spatialSupportDegs', ...
	    'mSequenceIndicatorFunctions', ...
	    'theInputConeMosaicResponses');

	% Assert that the input cone mosaic in the stored mRGC mosaic is the same as the input cone mosaic of the passed mRGC Mosaic
	assert(thePassedMRGCMosaic.inputConeMosaic.conesNum == theMRGCMosaic.inputConeMosaic.conesNum, ...
	    'Number of cones in the loaded input cone mosaic STF responses file is not identicial to the that of input cone mosaic of the passed mRGC mosaic');
	assert(all(thePassedMRGCMosaic.inputConeMosaic.coneTypes == theMRGCMosaic.inputConeMosaic.coneTypes), ...
	    'Cone types in the loaded input cone mosaic STF responses file are not identicial to those of the input cone mosaic of the passed mRGC mosaic');

	% Input cone mosaics are identical so switch to the passed mRGC mosaic which may have different characteristics of the mRGCs but identical
  	% input cone mosaic
  	clear 'theMRGCMosaic'
  	theMRGCMosaic = thePassedMRGCMosaic;

  	% The temporal support in seconds. This is currently equal to frameIndex * inputConeMosaic.integrationTime
  	theConeMosaicResponseTemporalSupportSeconds = stimParams.temporalSupportSeconds;

  	% Reshape to the size expected by mRGCMosaic.compute(): [nTrials x nTimePoints x nCones]
  	coneMosaicResponseSize = [1 numel(stimParams.temporalSupportSeconds) theMRGCMosaic.inputConeMosaic.conesNum];
  	theNoiseFreeConeMosaicSpatioTemporalExcitationsResponse = reshape(theInputConeMosaicResponses, coneMosaicResponseSize);

  	% Compute the noise-free mRGCMosaic response
  	[theNoiseFreeSpatioTemporalMRCMosaicResponse, ~, theMRGCMosaicResponseTemporalSupportSeconds] = ...
  		theMRGCMosaic.compute(theNoiseFreeConeMosaicSpatioTemporalExcitationsResponse, theConeMosaicResponseTemporalSupportSeconds);

    % Normalize for contrast
    theNoiseFreeSpatioTemporalMRCMosaicResponse = theNoiseFreeSpatioTemporalMRCMosaicResponse /stimParams.contrast;

    % Visualize response
  	if (visualizeInputConeMosaicResponses)
  		mRGCMosaicActivationRange = [-1 1];
        hFig = figure(10);
        ax = subplot(1,1,1);
        for iTimeBin = 1:numel(theMRGCMosaicResponseTemporalSupportSeconds)
	        theFrameResponse = theNoiseFreeSpatioTemporalMRCMosaicResponse(1,iTimeBin,:);
	        theMRGCMosaic.visualize(...
	            'figureHandle', hFig, ...
	            'axesHandle', ax, ...
	            'activation', theFrameResponse, ...
	            'activationRange', mRGCMosaicActivationRange, ...
                'plotTitle', sprintf('frame %d of %d', iTimeBin, numel(theMRGCMosaicResponseTemporalSupportSeconds)));
	        drawnow;
        end
    end

 	save(theMRGCMosaicResponsesFullFileName, 'theMRGCMosaic', 'stimParams', 'RFmappingParamsStruct', ...
 		'spatialSupportDegs', ...
	    'mSequenceIndicatorFunctions', ...
 		'theNoiseFreeSpatioTemporalMRCMosaicResponse', ...
        'theMRGCMosaicResponseTemporalSupportSeconds', ...
 		'-v7.3');

end


function inputConeMosaicMsequenceRFmapping(theMRGCMosaic, theOI, RFmappingParamsStruct, ...
	theInputConeMosaicResponsesFullFileName, visualizeInputConeMosaicResponses)

	fprintf('Will save input cone mosaic M-sequence responses to\n\t%s\n', theInputConeMosaicResponsesFullFileName);

	% Compute cone contrasts for desired chromaticity
    [coneContrasts, totalContrast] = ...
        visualStimulusGenerator.coneContrastsFromChromaticity(RFmappingParamsStruct.chromaticity);

    rfPixelSizeDegs = max(RFmappingParamsStruct.sizeDegs(:))/RFmappingParamsStruct.rfPixelsAcross;
    rfPixelRetinalPixelsWithin = max([1 floor(rfPixelSizeDegs/RFmappingParamsStruct.optimalResolutionDegs)]);
    RFmappingParamsStruct.resolutionDegs = rfPixelSizeDegs/rfPixelRetinalPixelsWithin;

    fprintf('\nTo probe RFs using a patch size of %2.3f degs with %d x %d RF pixels\neach RF pixel will be %2.3f degs and contain %d retinal pixels (retinal res of :%2.3f arc min, optimal retinal res: %2.3f arc min).\n', ...
        RFmappingParamsStruct.sizeDegs(1), RFmappingParamsStruct.rfPixelsAcross, RFmappingParamsStruct.rfPixelsAcross, rfPixelSizeDegs, ...
        rfPixelRetinalPixelsWithin, RFmappingParamsStruct.resolutionDegs*60, RFmappingParamsStruct.optimalResolutionDegs*60);

    % Form stimParams struct from RFmappingParams
    stimParams = RFmappingParamsStruct;
    stimParams.contrast = totalContrast;
    stimParams.coneContrasts = coneContrasts;
    stimParams.rfPixelSizeDegs = rfPixelSizeDegs;
    stimParams.rfPixelRetinalPixelsWithin = rfPixelRetinalPixelsWithin;
    stimParams.sizeDegs =  max(RFmappingParamsStruct.sizeDegs(:));
	stimParams.coneMosaicModulationBasedResponse = true;
	stimParams.temporalSupportSeconds = [];   % Filling this later

	% Visualize the mRGCmosaic with a scale bar equl to the RFmaping pixel size
	theMRGCMosaic.visualize(...
        'centerSubregionContourSamples', 40, ...
        'plottedRFoutlineLineWidth', 1.0, ...
        'plottedRFoutlineFaceAlpha', 0.75, ...
        'scaleBarDegs', rfPixelSizeDegs, ...
        'identifyPooledCones', true, ...
        'plotTitle', sprintf('scale bar: %2.3f degs (rf pixel size)', stimParams.rfPixelSizeDegs));

	% Generate presentation display
    viewingDistanceMeters = 4;
    thePresentationDisplay = visualStimulusGenerator.presentationDisplay(...
            theMRGCMosaic.inputConeMosaic.wave, RFmappingParamsStruct.resolutionDegs, ...
            viewingDistanceMeters, ...
            'displayType', 'CRT-Sony-HorwitzLab');

    if (stimParams.coneFundamentalsOptimizedForStimPosition)
        % Compute custom cone fundamentals
        maxConesNumForAveraging = 3;
        customConeFundamentals = visualStimulusGenerator.coneFundamentalsForPositionWithinConeMosaic(...
            theMRGCMosaic.inputConeMosaic, theOI, stimParams.positionDegs, stimParams.sizeDegs, maxConesNumForAveraging);
    else
        customConeFundamentals = [];
    end

    % Compute the M-sequence spatial patterns
    visualizePatterns = ~true;

    % Compute the m-sequence frame modulation patterns
    mSequenceIndicatorFunctions = visualStimulusGenerator.mSequenceModulationPatterns(...
       	stimParams.rfPixelsAcross, ...
        'ternaryInsteadOfBinaryMsequence', RFmappingParamsStruct.ternaryInsteadOfBinaryMsequence, ...
        'mSequenceBitLength', RFmappingParamsStruct.mSequenceBitLength, ...
        'visualizePatterns', visualizePatterns);

    nFrames = size(mSequenceIndicatorFunctions,1);
    theInputConeMosaicResponses = zeros(...
        nFrames, ...
        theMRGCMosaic.inputConeMosaic.conesNum, ...
        'single');

    % Resolution equal to the integration time of the mosaic.
    stimParams.temporalSupportSeconds = (0:nFrames-1)*theMRGCMosaic.inputConeMosaic.integrationTime;

    % Compute theNullStimulusScene
    spatialModulationPattern = visualStimulusGenerator.expandFrame(squeeze(mSequenceIndicatorFunctions(1,:,:)), stimParams.rfPixelRetinalPixelsWithin);
    spatialModulationPatternSize = [1 size(spatialModulationPattern,1) size(spatialModulationPattern,2)];
 	[~, theNullStimulusScene, spatialSupportDegs,  theConeFundamentalsStruct] = visualStimulusGenerator.stimulusFramesScenes(...
            thePresentationDisplay, stimParams, reshape(spatialModulationPattern, spatialModulationPatternSize), ...
            'frameIndexToCompute', 0, ... % [] field indicates that all stimulus frame scenes must be computed
            'customConeFundamentals', customConeFundamentals, ...
            'validateScenes', false);

 	% Compute responses to the test stimuli in small batches to make sure we dont saturate the RAM
 	startingIndex = 1;
    endingIndex = 0;
    while (endingIndex < nFrames)
        if (startingIndex > 1)
            % Only visualize the first batch
            visualizeInputConeMosaicResponses = false;
        end

        endingIndex = min([startingIndex+RFmappingParamsStruct.frameBatchSize-1 nFrames]);
        fprintf('Computing input cone mosaic responses to m-sequence frames %d - %d\n', startingIndex, endingIndex);
        subsequenceFrameIndices = (startingIndex:endingIndex);
        startingIndex = endingIndex+1;

        % Compute theMSequenceFramesSceneSubsequence
        theMSequenceFramesSceneSubsequence = cell(1, numel(subsequenceFrameIndices));


        parfor iFrame = 1:numel(subsequenceFrameIndices)
            theFrameIndex = subsequenceFrameIndices(iFrame);
            % Expand the m-sequence indicator function
            spatialModulationPattern = visualStimulusGenerator.expandFrame(...
            	squeeze(mSequenceIndicatorFunctions(theFrameIndex,:,:)), stimParams.rfPixelRetinalPixelsWithin);

            % Compute a single scene for this m-sequence frame and add it to theMSequenceFramesSceneSubsequence
            theSceneSequence = visualStimulusGenerator.stimulusFramesScenes(...
                thePresentationDisplay, stimParams, reshape(spatialModulationPattern, spatialModulationPatternSize), ...
                'frameIndexToCompute', 1, ...
                'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct, ...
                'validateScenes', false);
            theMSequenceFramesSceneSubsequence{iFrame} = theSceneSequence{1};
        end % iFrame

        % Compute input cone mosaic response to theMSequenceFramesSceneSubsequence
        stimulusPosition = 'mosaic-centered';
        theInputConeMosaicResponses(subsequenceFrameIndices, :) = ...
          RGCMosaicConstructor.helper.simulateExperiment.inputConeMosaicResponseToStimulusFrameSequence(...
            theMRGCMosaic, theOI, theNullStimulusScene, theMSequenceFramesSceneSubsequence, ...
            stimulusPosition, stimParams.coneMosaicModulationBasedResponse, ...
            'visualizeResponse', visualizeInputConeMosaicResponses, ...
            'thePresentationDisplayForVisualizingOpticalSceneOrImage', thePresentationDisplay, ...
            'stimulusInfoString', sprintf('frames: %d - %d', subsequenceFrameIndices(1), subsequenceFrameIndices(end)));

    end % while (endingIndex < nFrames)

     % Save results
  	fprintf('Saving computed input cone mosaic mSequence RF mapping responses to %s.\n', theInputConeMosaicResponsesFullFileName);

    save(theInputConeMosaicResponsesFullFileName, ...
        'theMRGCMosaic', ...
        'RFmappingParamsStruct', ...
        'stimParams', ...
        'mSequenceIndicatorFunctions', ...
        'spatialSupportDegs', ...
        'theInputConeMosaicResponses', ...
        '-v7.3');
end