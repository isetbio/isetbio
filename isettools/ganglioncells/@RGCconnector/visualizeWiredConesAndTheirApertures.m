function [xSupport, ySupport, rfProfile2D, xTicks, yTicks] = ...
    visualizeWiredConesAndTheirApertures(obj, iRGC, axConeWiring, axConeApertures, ...
    xSupport, ySupport, xTicks, yTicks, visualizedFieldOfViewMicrons, visualizedConesNum, colorString)

    % Indices and weights of non-overlapping & overlapping input cones
    connectedNonOverlappingConeIndices = find(squeeze(obj.coneConnectivityMatrix(:, iRGC))>0);
    connectedOverlappingConeIndices = find(squeeze(obj.coneConnectivityMatrix(:, iRGC))<0);
    connectedNonOverlappingConeWeights = full(obj.coneConnectivityMatrix(connectedNonOverlappingConeIndices, iRGC));
    connectedOverlappingConeWeights = full(obj.coneConnectivityMatrix(connectedOverlappingConeIndices, iRGC));

    % The centroid of the RGC
    theRGCCentroidMicrons = obj.RGCRFcentroidsFromInputs(iRGC,:);


    % Find neigboring cones 
    [~, nearbyConeIndices] = RGCconnector.pdist2(...
            obj.inputConeMosaic.coneRFpositionsMicrons, ...
            theRGCCentroidMicrons, '', ...
            'smallest', visualizedConesNum);

    allConnectedConeIndices = [ ...
        connectedNonOverlappingConeIndices(:); ...
        connectedOverlappingConeIndices(:)
        ];

    neighboringNonConnectedConeIndices = setdiff(nearbyConeIndices, allConnectedConeIndices);

    % The cone outline
    coneOutline(:,1) = cosd(0:10:360);
    coneOutline(:,2) = sind(0:10:360);
    

    % The cone wiring diagram with weights
    hold(axConeWiring, 'on');
    [xSupport, ySupport] = renderPooledConesDiagram(axConeWiring, ...
        theRGCCentroidMicrons, ...
        obj.inputConeMosaic.coneRFpositionsMicrons(neighboringNonConnectedConeIndices,:), ...
        obj.inputConeMosaic.coneRFspacingsMicrons(neighboringNonConnectedConeIndices), ...
        obj.inputConeMosaic.coneTypes(neighboringNonConnectedConeIndices), ...
        obj.inputConeMosaic.coneRFpositionsMicrons(connectedNonOverlappingConeIndices, :),...
        obj.inputConeMosaic.coneRFpositionsMicrons(connectedOverlappingConeIndices, :),...
        obj.inputConeMosaic.coneRFspacingsMicrons(connectedNonOverlappingConeIndices), ...
        obj.inputConeMosaic.coneRFspacingsMicrons(connectedOverlappingConeIndices), ...
        obj.inputConeMosaic.coneTypes(connectedNonOverlappingConeIndices), ...
        obj.inputConeMosaic.coneTypes(connectedOverlappingConeIndices), ...
        connectedNonOverlappingConeWeights, ...
       -connectedOverlappingConeWeights, ...
        coneOutline, ...
        xSupport, ySupport, ...
        visualizedFieldOfViewMicrons ...
        );

    % Compute the 2D profile
    [X,Y] = meshgrid(xSupport, ySupport);
    rfProfile2D = computeRFprofile(...
        obj.inputConeMosaic.coneRFpositionsMicrons(connectedNonOverlappingConeIndices, :),...
        obj.inputConeMosaic.coneRFpositionsMicrons(connectedOverlappingConeIndices, :),...
        obj.inputConeMosaic.coneRFspacingsMicrons(connectedNonOverlappingConeIndices), ...
        obj.inputConeMosaic.coneRFspacingsMicrons(connectedOverlappingConeIndices), ...
        connectedNonOverlappingConeWeights, ...
       -connectedOverlappingConeWeights, ...
        X,Y);

    % Superimpose contour of 2Dprofile
    zLevels = [0.07 0.999];
    cmapMain = brewermap(1024, 'greys');
    alphaMain = 0.25;
    contourLineColorMain = [0 0 0];

    zData = (rfProfile2D/max(rfProfile2D(:))).^0.5;
    cMosaic.semiTransparentContourPlot(axConeWiring, xSupport, ySupport, ...
        zData, zLevels, cmapMain, alphaMain, contourLineColorMain, ...
        'lineWidth', 2.0);


    % Finalize plot
    if (isempty(xTicks))
        if (visualizedFieldOfViewMicrons < 30)
            deltaTick = 5;
        elseif (visualizedFieldOfViewMicrons < 60)
            deltaTick = 10;
        elseif (visualizedFieldOfViewMicrons < 100)
            deltaTick = 20;
        else
            deltaTick = 40;
        end
        
        xTicks = round(theRGCCentroidMicrons(1)/10)*10+(-visualizedFieldOfViewMicrons:deltaTick:visualizedFieldOfViewMicrons);
        yTicks = round(theRGCCentroidMicrons(2)/10)*10+(-visualizedFieldOfViewMicrons:deltaTick:visualizedFieldOfViewMicrons);
    end

    axis(axConeWiring,'equal');
    set(axConeWiring, 'XLim', [xSupport(1) xSupport(end)], 'YLim', [ySupport(1) ySupport(end)], 'FontSize', 15);
    set(axConeWiring, 'XTick', xTicks, ...
            'YTick', yTicks);
    box(axConeWiring, 'on'); grid(axConeWiring, 'on');
    title(axConeWiring, sprintf('\\color{%s} RGC #%d (connected cones)', colorString, iRGC));   
    xlabel(axConeWiring, 'space, x (microns)');
    ylabel(axConeWiring, 'space, y (microns)');
    
    % The weighted cone apertures
    if (~isempty(axConeApertures))
        hold(axConeApertures, 'on');
        renderWeightedConeAperturesDiagram(axConeApertures, ...
            obj.inputConeMosaic.coneRFpositionsMicrons(connectedNonOverlappingConeIndices, :),...
            obj.inputConeMosaic.coneRFpositionsMicrons(connectedOverlappingConeIndices, :),...
            obj.inputConeMosaic.coneRFspacingsMicrons(connectedNonOverlappingConeIndices), ...
            obj.inputConeMosaic.coneRFspacingsMicrons(connectedOverlappingConeIndices), ...
            obj.inputConeMosaic.coneTypes(connectedNonOverlappingConeIndices), ...
            obj.inputConeMosaic.coneTypes(connectedOverlappingConeIndices), ...
            connectedNonOverlappingConeWeights, ...
           -connectedOverlappingConeWeights, ...
            xSupport, ySupport);

        % Finalize plot
        axis(axConeApertures,'square');
        set(axConeApertures, 'XLim', [xSupport(1) xSupport(end)], 'YLim', [0 1.02], 'FontSize', 15);
        set(axConeApertures, 'XTick', xTicks, ...
                'YTick', 0:0.1:1.0);
        box(axConeApertures, 'on'); grid(axConeApertures, 'on');
        title(axConeApertures, sprintf('\\color{%s} RGC #%d (weighted cone apertures)', colorString, iRGC)); 
        xlabel(axConeApertures, 'space, x (microns)');
        ylabel(axConeApertures, 'pooling weight');
    end
end


function renderWeightedConeAperturesDiagram(ax, ...
        connectedNonOverlappingConeRFpositionsMicrons,...
        connectedOverlappingConeRFpositionsMicrons,...
        connectedNonOverlappingConeRFspacingsMicrons,...
        connectedOverlappingConeRFspacingsMicrons,...
        connectedNonOverlappingConeTypes, ...
        connectedOverlappingConeTypes, ...
        connectedNonOverlappingConeWeights, ...
        connectedOverlappingConeWeights, ...
        xSupport, ySupport)


    % The non-overlapping cone apertures
    renderWeightedConeApertures(ax, xSupport, ...
        connectedNonOverlappingConeRFpositionsMicrons, ...
        connectedNonOverlappingConeRFspacingsMicrons, ...
        connectedNonOverlappingConeTypes, ...
        connectedNonOverlappingConeWeights, ...
        '-');

    % The overlapping cone apertures
    renderWeightedConeApertures(ax, xSupport, ...
        connectedOverlappingConeRFpositionsMicrons, ...
        connectedOverlappingConeRFspacingsMicrons, ...
        connectedOverlappingConeTypes, ...
        connectedOverlappingConeWeights, ...
        '--');

end


function renderWeightedConeApertures(ax, xSupport, coneRFpositions, ...
    coneRFspacings, coneTypes, coneWeights, lineStyle)

    for iCone = 1:numel(coneRFspacings)
        switch (coneTypes(iCone))
            case cMosaic.LCONE_ID
                coneColor = [1 0.1000 0.5000];
            case cMosaic.MCONE_ID
                coneColor = [0.1000 1 0.5000];
            case cMosaic.SCONE_ID
                coneColor = [0.6000 0.1000 1];
        end
        coneRc = 0.204*sqrt(2.0)*coneRFspacings(iCone);
        gaussianProfile = exp(-((xSupport-coneRFpositions(iCone,1))/coneRc).^2);
        shadedAreaPlot(ax, xSupport, coneWeights(iCone)*gaussianProfile, 0, ...
            coneColor*0.5, [0 0 0], 0.5, 1.0, lineStyle); 
    end

end

