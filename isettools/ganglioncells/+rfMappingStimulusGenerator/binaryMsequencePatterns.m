function indicatorH = binaryMsequencePatterns(rfPixelsAcross, varargin)
    % Parse optional input
    p = inputParser;
    p.addParameter('visualizePatterns', false, @islogical);
    p.addParameter('mSequenceBitLength', 10, @(x)(isscalar(x)&&(x>0)));
    p.addParameter('ternaryInsteadOfBinaryMsequence', @false, @islogical);
    p.parse(varargin{:});
    visualizePatterns = p.Results.visualizePatterns;
    ternaryInsteadOfBinaryMsequence = p.Results.ternaryInsteadOfBinaryMsequence;
    mSequenceBitLength = p.Results.mSequenceBitLength;
    
    % Binary m-sequence
    if (ternaryInsteadOfBinaryMsequence)
        nLevels = 3;
    else
        nLevels = 2;
    end

    mseq = generateMsequence(nLevels, mSequenceBitLength)/2.0;
    mseq = 0.5+mseq;
    nTimePoints = length(mseq);
    fprintf('Sequence length: %d\n', nTimePoints);

    % Shift msequence signal for each pixel
    pixelsNum = rfPixelsAcross^2;
    spatioTemporalActivation = zeros(nTimePoints, pixelsNum, 'single');
    mSequenceShift = numel(mseq)/pixelsNum;
    if (mSequenceShift < 1.0)
        error('M-sequence shift is %f. Either decrease the spatial resolution or increase the m-sequence length.\n', mSequenceShift);
    end

    shiftStep = round(mSequenceShift);
    for pixelIndex = 1:pixelsNum
        spatioTemporalActivation(:,pixelIndex) = single(shiftMseq(mseq, (pixelIndex-1)*shiftStep));
    end

    spatioTemporalActivation = (2*(spatioTemporalActivation-0.5));

    if (visualizePatterns)
        crossCorrelationMap = zeros(pixelsNum, pixelsNum);
        for pixelIndex1 = 1:pixelsNum
        for pixelIndex2 = 1:pixelsNum
            x1 = spatioTemporalActivation(:,pixelIndex1);
            x2 = spatioTemporalActivation(:,pixelIndex2);
            crossCorrelationMap(pixelIndex1, pixelIndex2) = dot(x1,x2);
        end
        end
        crossCorrelationMap = crossCorrelationMap / max(abs(crossCorrelationMap(:)));
        figure(1);
        imagesc(crossCorrelationMap)
        set(gca, 'CLim', [-1 1])
        axis 'image'
        title(sprintf('cross correlation range: %f - %f', min(crossCorrelationMap(:)), max(crossCorrelationMap(:))));
        colormap(gray);
    end

    % Generate 2D patterns
    indicatorH = zeros(nTimePoints, rfPixelsAcross, rfPixelsAcross, 'single');
    for iTimePoint = 1:nTimePoints
        indicatorH(iTimePoint,:,:) = reshape(spatioTemporalActivation(iTimePoint,:), [rfPixelsAcross rfPixelsAcross]);
    end

    if (visualizePatterns)
        for i = 1:size(indicatorH,1)
            figure(2);
            imagesc(squeeze(indicatorH(i,:,:)));
            axis 'image'
            set(gca, 'CLim', [-2 2]);
            colormap(gray)
            pause
        end
    end

end

function mseq = shiftMseq(mseq, shift)
    if (shift > 0)
        shift = rem(shift, length(mseq));
        mseq = [mseq(shift+1:end); mseq(1:shift)];
    end
end

function mseq = generateMsequence(levelsNum, expR, varargin)
    % Validation function for levelsNum
    levelsNumValidationFcn = @(x) isnumeric(x) && ((x==2) || (x==3) || (x==5));
    
    % Validation function for expR
    expRNumValidationFcn = @(x) isnumeric(x);
    
    % values for optional params, 'sequenceIndex' and 'shift'
    defaultSequenceIndex = 1;
    defaultShift = 1;

    p = inputParser;
    p.addRequired('levelsNum', levelsNumValidationFcn);
    p.addRequired('expR', expRNumValidationFcn);
    p.addParameter('shift', defaultShift);
    p.addParameter('sequenceIndex', defaultSequenceIndex);
    p.parse(levelsNum, expR, varargin{:});

    levelsNum = p.Results.levelsNum;
    expR = p.Results.expR;
    shift = p.Results.shift;
    sequenceIndex = p.Results.sequenceIndex;

    sequenceLength = levelsNum^expR - 1;
    register = ones(expR,1);
    taps = retrieveTapNos(levelsNum, expR, sequenceIndex);
    weights = zeros(1, expR);
    if (levelsNum == 2)
        weights(taps) = 1;
    elseif (levelsNum > 2)
        weights = taps;
    end

    fprintf('\nGenerating sequence of length %d. Please wait ...', sequenceLength);
    tic
    mseq = zeros(sequenceLength,1);
    for i = 1:sequenceLength
        mseq(i)  = rem(weights*register+levelsNum,levelsNum);
        register = [mseq(i); register(1:expR-1)];
    end

    mseq = shiftMseq(mseq, shift);
    mseq = makeNlevel(mseq, levelsNum);
    fprintf('Done after %2.2f seconds\n', toc);

end

function mseq = makeNlevel(mseq, levelsNum)
    switch (levelsNum)
        case 2
            mseq = mseq*2 - 1;
        case 3
            mseq(mseq == 2) = -1;
        case 5
            mseq(mseq == 4) = -1;
            mseq(mseq == 3) = -2;
        otherwise
            error('Base must be 2,3 or 5');
    end
end

function taps = retrieveTapNos(levelsNum, expR, sequenceIndex)
    if (levelsNum == 2)
        taps = retrieveTapNosForBinaryMsequence(expR, sequenceIndex);
    elseif (levelsNum == 3)
        taps = retrieveTapNosForTernaryMsequence(expR, sequenceIndex);
    elseif (levelsNum == 5)
        taps = retrieveTapNosForPentaryMsequence(expR, sequenceIndex);
    end
end

function taps = retrieveTapNosForBinaryMsequence(expR, sequenceIndex)

    if (expR < 2) || (expR > 30)
        error('Binary m-sequence with exponent: %d is not defined\n', expR)
    end
    
    switch expR 
        case 2 
            taps = { ...
                [1 2] ...
                };
            
        case 3 
            taps = { ...
                [1 3] ...
                [2 3] ...
                };
        case 4 
            taps = { ...
                [1 4] ...
                [1 4] ...
                };
            
        case 5
            taps = { ...
                [2,5] ...
                [3,5] ...
                [1,2,3,5] ...
                [2,3,4,5] ...
                [1,2,4,5] ...
                [1,3,4,5] ...
                };
            
        case 6
            taps = { ...
                [1,6] ...
                [5,6] ...
                [1,2,5,6] ...
                [1,4,5,6] ...
                [1,3,4,6] ...
                [2,3,5,6] ...
                };
            
        case 7 
             taps = { ...
                [1,7] ...
                [6,7] ...
                [3,7] ...
                [4,7] ...
                [1,2,3,7]  ...
                [4,5,6,7]  ...
                [1,2,5,7]  ...
                [2,5,6,7] ...
                [2,3,4,7] ...
                [3,4,5,7] ...
                [1,3,5,7] ...
                [2,4,6,7] ...
                [1,3,6,7] ...
                [1,4,6,7] ...
                [2,3,4,5,6,7] ...
                [1,2,3,4,5,7] ...
                [1,2,4,5,6,7] ...
                [1,2,3,5,6,7] ...
                 };
            
        case 8 
            taps = { ...
                [1,2,7,8] ...
                [1,6,7,8] ...
                [1,3,5,8] ...
                [3,5,7,8] ...
                [2,3,4,8] ...
                [4,5,6,8] ...
                [2,3,5,8] ...
                [3,5,6,8] ...
                [2,3,6,8] ...
                [2,5,6,8] ...
                [2,3,7,8] ...
                [1,5,6,8] ...
                [1,2,3,4,6,8] ...
                [2,4,5,6,7,8] ...
                [1,2,3,6,7,8] ...
                [1,2,5,6,7,8] ...
                };
            
        case 9
            taps = { ...
            	[4,9] ...
            	[5,9] ...
            	[3,4,6,9] ...
            	[3,5,6,9] ...
            	[4,5,8,9] ...
            	[1,4,5,9] ...
            	[1,4,8,9] ...
            	[1,5,8,9] ...
            	[2,3,5,9] ...
            	[4,6,7,9] ...
            	[5,6,8,9] ...
            	[1,3,4,9] ...
            	[2,7,8,9] ...
            	[1,2,7,9] ...
            	[2,4,7,9] ...
            	[2,5,7,9] ...
            	[2,4,8,9] ...
            	[1,5,7,9] ...
            	[1,2,4,5,6,9] ...
            	[3,4,5,7,8,9] ...
            	[1,3,4,6,7,9] ...
            	[2,3,5,6,8,9] ...
            	[3,5,6,7,8,9] ...
            	[1,2,3,4,6,9] ...
            	[1,5,6,7,8,9] ...
            	[1,2,3,4,8,9] ...
            	[1,2,3,7,8,9] ...
            	[1,2,6,7,8,9] ...
            	[1,3,5,6,8,9] ...
            	[1,3,4,6,8,9] ...
            	[1,2,3,5,6,9] ...
            	[3,4,6,7,8,9] ...
            	[2,3,6,7,8,9] ...
            	[1,2,3,6,7,9] ...
            	[1,4,5,6,8,9] ...
            	[1,3,4,5,8,9] ...
            	[1,3,6,7,8,9] ...
            	[1,2,3,6,8,9] ...
            	[2,3,4,5,6,9] ...
            	[3,4,5,6,7,9] ...
            	[2,4,6,7,8,9] ...
            	[1,2,3,5,7,9] ...
            	[2,3,4,5,7,9] ...
            	[2,4,5,6,7,9] ...
            	[1,2,4,5,7,9] ...
            	[2,4,5,6,7,9] ...
            	[1,3,4,5,6,7,8,9] ...
            	[1,2,3,4,5,6,8,9] ...
            };
        
        case 10
            taps = { ...
            	[3,10] ...
            	[7,10] ...
            	[2,3,8,10] ...
            	[2,7,8,10] ...
            	[1,3,4,10] ...
            	[6,7,9,10] ...
            	[1,5,8,10] ...
            	[2,5,9,10] ...
            	[4,5,8,10] ...
            	[2,5,6,10] ...
            	[1,4,9,10] ...
            	[1,6,9,10] ...
            	[3,4,8,10] ...
            	[2,6,7,10] ...
            	[2,3,5,10] ...
            	[5,7,8,10] ...
            	[1,2,5,10] ...
            	[5,8,9,10] ...
            	[2,4,9,10] ...
            	[1,6,8,10] ...
            	[3,7,9,10] ...
                [1,3,7,10] ...
            	[1,2,3,5,6,10] ...
            	[4,5,7,8,9,10] ...
            	[2,3,6,8,9,10] ...
            	[1,2,4,7,8,10] ...
            	[1,5,6,8,9,10] ...
            	[1,2,4,5,9,10] ...
            	[2,5,6,7,8,10] ...
            	[2,3,4,5,8,10] ...
            	[2,4,6,8,9,10] ...
            	[1,2,4,6,8,10] ...
            	[1,2,3,7,8,10] ...
            	[2,3,7,8,9,10] ...
            	[3,4,5,8,9,10] ...
            	[1,2,5,6,7,10] ...
            	[1,4,6,7,9,10] ...
            	[1,3,4,6,9,10] ...
            	[1,2,6,8,9,10] ...
            	[1,2,4,8,9,10] ...
            	[1,4,7,8,9,10] ...
            	[1,2,3,6,9,10] ...
            	[1,2,6,7,8,10] ...
            	[2,3,4,8,9,10] ...
            	[1,2,4,6,7,10] ...
            	[3,4,6,8,9,10] ...
            	[2,4,5,7,9,10] ...
            	[1,3,5,6,8,10] ...
            	[3,4,5,6,9,10] ...
            	[1,4,5,6,7,10] ...
            	[1,3,4,5,6,7,8,10] ...
            	[2,3,4,5,6,7,9,10] ...
            	[3,4,5,6,7,8,9,10] ...
            	[1,2,3,4,5,6,7,10] ...
            	[1,2,3,4,5,6,9,10] ...
            	[1,4,5,6,7,8,9,10] ...
            	[2,3,4,5,6,8,9,10] ...
            	[1,2,4,5,6,7,8,10] ...
            	[1,2,3,4,6,7,9,10] ...
            	[1,3,4,6,7,8,9,10] ...
            };
        
        case 11
            taps = { [9,11] };
            
        case 12
            taps = { [6,8,11,12] };
            
        case 13
            taps = { [9,10,12,13] };
            
        case 14  
            taps = { [4,8,13,14] };
            
        case 15 
            taps = { [14,15] };
            
        case 16 
            taps = { [4,13,15,16] };
            
        case 17 
            taps = { [14,17] };
            
        case 18 
            taps = { [11,18] };
            
        case 19 
            taps = { [14,17,18,19] };
            
        case 20 
            taps = { [17,20] };
            
        case 21 
            taps = { [19,21] };
            
        case 22 
            taps = {[21,22] };
            
        case 23 
            taps = {[18,23] };
            
        case 24 
            taps = {[17,22,23,24] };
            
        case 25 
            taps = {[22,25] };
            
        case 26 
            taps = {[20,24,25,26] };
            
        case 27 
            taps = {[22,25,26,27] };
            
        case 28 
            taps = {[25,28] };
            
        case 29 
            taps = {[27,29] };
            
        case 30
            taps = {[7,28,29,30] };
    end % switch expR
    
    if (sequenceIndex > numel(taps))
        error('Binary m-sequence with exponent: %d and sequence index: %d is not defined\n', expR, sequenceIndex)
    end
    taps = taps{sequenceIndex};
end



function taps = retrieveTapNosForTernaryMsequence(expR, sequenceIndex)  
    if (expR < 2) || (expR > 8)
        error('Ternary m-sequence with exponent: %d is not defined\n', expR);
    end
   
    switch (expR)
        case 2
            taps = { ...
                [2,1] ...
                [1,1] ...
                };
            
        case 3
            taps = { ...
                [0,1,2] ...
                [1,0,2] ...
                [1,2,2] ...
                [2,1,2] ...
                };
            
        case 4
            taps = { ...
                [0,0,2,1], ...
                [0,0,1,1], ...
                [2,0,0,1], ...
                [2,2,1,1], ...
                [2,1,1,1], ...
                [1,0,0,1], ...
                [1,2,2,1], ...
                [1,1,2,1], ...
           };
       
        case 5
            taps = { ...
                [0,0,0,1,2] ...
                [0,0,0,1,2] ...
                [0,0,1,2,2] ...
                [0,2,1,0,2] ...
                [0,2,1,1,2] ...
                [0,1,2,0,2] ...
                [0,1,1,2,2] ...
                [2,0,0,1,2] ...
                [2,0,2,0,2] ...
                [2,0,2,2,2] ...
                [2,2,0,2,2] ...
                [2,2,2,1,2] ...
                [2,2,1,2,2] ...
                [2,1,2,2,2] ...
                [2,1,1,0,2] ...
                [1,0,0,0,2] ...
                [1,0,0,2,2] ...
                [1,0,1,1,2] ...
                [1,2,2,2,2] ...
                [1,1,0,1,2] ...
                [1,1,2,0,2] ...
                };
            
        case 6
            taps = {...
                [0,0,0,0,2,1] ...
                [0,0,0,0,1,1] ...
                [0,0,2,0,2,1] ...
                [0,0,1,0,1,1] ...
                [0,2,0,1,2,1] ...
                [0,2,0,1,1,1] ...
                [0,2,2,0,1,1] ...
                [0,2,2,2,1,1] ...
                [2,1,1,1,0,1] ...
                [1,0,0,0,0,1] ...
                [1,0,2,1,0,1] ...
                [1,0,1,0,0,1] ...
                [1,0,1,2,1,1] ...
                [1,0,1,1,1,1] ...
                [1,2,0,2,2,1] ...
                [1,2,0,1,0,1] ...
                [1,2,2,1,2,1] ...
                [1,2,1,0,1,1] ...
                [1,2,1,2,1,1] ...
                [1,2,1,1,2,1] ...
                [1,1,2,1,0,1] ...
                [1,1,1,0,1,1] ...
                [1,1,1,2,0,1] ...
                [1,1,1,1,1,1] ...
                };
            
        case 7
            taps = {...
                [0,0,0,0,2,1,2] ...
                [0,0,0,0,1,0,2] ...
                [0,0,0,2,0,2,2] ...
                [0,0,0,2,2,2,2] ...
                [0,0,0,2,1,0,2] ...
                [0,0,0,1,1,2,2] ...
                [0,0,0,1,1,1,2] ...
                [0,0,2,2,2,0,2] ...
                [0,0,2,2,1,2,2] ...
                [0,0,2,1,0,0,2] ...
                [0,0,2,1,2,2,2] ...
                [0,0,1,0,2,1,2] ...
                [0,0,1,0,1,1,2] ...
                [0,0,1,1,0,1,2] ...
                [0,0,1,1,2,0,2] ...
                [0,2,0,0,0,2,2] ...
                [0,2,0,0,1,0,2] ...
                [0,2,0,0,1,1,2] ...
                [0,2,0,2,2,0,2] ...
                [0,2,0,2,1,2,2] ...
                [0,2,0,1,1,0,2] ...
                [0,2,2,0,2,0,2] ...
                [0,2,2,0,1,2,2] ...
                [0,2,2,2,2,1,2] ...
                [0,2,2,2,1,0,2] ...
                [0,2,2,1,0,1,2] ...
                [0,2,2,1,2,2,2] ...
            };
    end % switch expR
    
    if (sequenceIndex > numel(taps))
        error('Ternary m-sequence with exponent: %d and sequence index: %d is not defined\n', expR, sequenceIndex)
    end
    taps = taps{sequenceIndex};
end

function taps = retrieveTapNosForPentaryMsequence(expR, sequenceIndex)  

    if (expR < 2) || (expR > 4)
        error('Pentary m-sequence with exponent: %d is not defined\n', expR)
    end
    
    switch (expR)
        case 2
            taps = { ...
                [4,3] ...
                [3,2] ...
                [2,2] ...
                [1,3] ...
             };
            
        case 3
            taps = { ...
                [0,2,3] ...
                [4,1,2] ...
                [3,0,2] ...
                [3,4,2] ...
                [3,3,3] ...
                [3,3,2] ...
                [3,1,3] ...
                [2,0,3] ...
                [2,4,3] ...
                [2,3,3] ...
                [2,3,2] ...
                [2,1,2] ...
                [1,0,2] ...
                [1,4,3] ...
                [1,1,3] ...
            };
        case 4
            taps = { ...
                [0,4,3,3];
                [0,4,3,2];
                [0,4,2,3];
                [0,4,2,2];
                [0,1,4,3];
                [0,1,4,2];
                [0,1,1,3];
                [0,1,1,2];
                [4,0,4,2];
                [4,0,3,2];
                [4,0,2,3];
                [4,0,1,3];
                [4,4,4,2];
                [4,3,0,3];
                [4,3,4,3];
                [4,2,0,2];
                [4,2,1,3];
                [4,1,1,2];
                [3,0,4,2];
                [3,0,3,3];
                [3,0,2,2];
                [3,0,1,3];
                [3,4,3,2];
                [3,3,0,2];
                [3,3,3,3];
                [3,2,0,3];
                [3,2,2,3];
                [3,1,2,2];
                [2,0,4,3];
                [2,0,3,2];
                [2,0,2,3];
                [2,0,1,2];
                [2,4,2,2];
                [2,3,0,2];
                [2,3,2,3];
                [2,2,0,3];
                [2,2,3,3];
                [2,1,3,2];
                [1,0,4,3];
                [1,0,3,3];
                [1,0,2,2];
                [1,0,1,2];
                [1,4,1,2];
                [1,3,0,3];
                [1,3,1,3];
                [1,2,0,2];
                [1,2,4,3];
                [1,1,4,2] ...
            };
    end % switch expR
    
    if (sequenceIndex > numel(taps))
        error('Pentary m-sequence with exponent: %d and sequence index: %d is not defined\n', expR, sequenceIndex)
    end
    taps = taps{sequenceIndex};
        
end