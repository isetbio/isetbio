%
% RGCMosaicConstructor.visualize.opticsAtOptimizationPositions
%
function opticsAtOptimizationPositions(...
        theOptimizationNodePSFs, theOptimizationNodeCroppedMosaics, ...
        theOptimizationPositionsGrid, ...
        theOptimizationSizeGrid, ...
        mosaicEccDegs, mosaicSizeDegs, ...
        mosaicSizeVisualized, ...
        whichZernikeDataBase, ...
        whichSubjectID, ...
        whichEye)


    domainVisualizationLimits(1:2) = mosaicEccDegs(1) + 0.51*mosaicSizeDegs(1) * [-1 1];
    domainVisualizationLimits(3:4) = mosaicEccDegs(2) + 0.51*mosaicSizeDegs(2) * [-1 1];
    domainVisualizationTicks = struct(...
        'x', -30:1:30, ...
        'y', -30:1:30);

    hFig = figure(56); clf;
    ff = PublicationReadyPlotLib.figureComponents('1x1 giant square mosaic');
    theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
    theAxes = theAxes{1,1};
    x = mosaicEccDegs(1) + 0.5*mosaicSizeDegs(1)*[-1 -1 1 1 -1];
    y = mosaicEccDegs(2) + 0.5*mosaicSizeDegs(2)*[-1 1 1 -1 -1];
    vertices = [x(:) y(:)];
    patch(theAxes, ...
        'faces', 1:size(vertices,1), ...
        'vertices',vertices, ...
        'faceColor',[0.1 0.1 0.1], ...
        'edgeColor', [0.8 0.8 0.8], ...
        'faceAlpha', 0.0, ...
        'edgeAlpha', 1.0, ...
        'LineWidth', 1.5, ...
        'LineStyle', '--');
    set(theAxes, 'XLim', domainVisualizationLimits(1:2));
    set(theAxes, 'YLim', domainVisualizationLimits(3:4));
    set(theAxes, 'XTick', domainVisualizationTicks.x, 'YTick', domainVisualizationTicks.y);
    xlabel(theAxes, 'eccentricity, x (degs)');
    ylabel(theAxes, 'eccentricity, y (degs)');
    hold(theAxes, 'on')

    
    for iNode = 1:numel(theOptimizationNodePSFs)
        thePSF = theOptimizationNodePSFs{iNode};
        theMRGCmosaic = theOptimizationNodeCroppedMosaics{iNode};

        vLambdaWeightedPSF.data = RGCMosaicAnalyzer.compute.vLambdaWeightedPSF(thePSF);
        vLambdaWeightedPSF.supportXdegs = thePSF.supportX/60;
        vLambdaWeightedPSF.supportYdegs = thePSF.supportY/60;

        theROI = regionOfInterest('geometryStruct', struct(...
            'units', 'degs', ...
            'shape', 'rect', ...
            'center', theMRGCmosaic.eccentricityDegs, ...
            'width', mosaicSizeVisualized, ...
            'height', mosaicSizeVisualized, ...
            'rotation', 0.0...
        ));
        visualizedRGCindices = theROI.indicesOfPointsInside(theMRGCmosaic.rgcRFpositionsDegs);
    
       
        theMRGCmosaic.visualize(...
            'figureHandle', hFig, ...
            'axesHandle', theAxes, ...
            'clearAxesBeforeDrawing', false, ...
            'identifyInputCones', false, ...
            'identifyPooledCones', false, ...
            'visualizedRGCindices', visualizedRGCindices, ...
            'plottedRFoutlineLineWidth', 1.0, ...
            'plottedRFoutlineFaceAlpha', 0.75, ...
            'plottedRFoutlineFaceColor',  [0 1 0.4], ...
            'minConeWeightVisualized', mRGCMosaic.sensitivityAtPointOfOverlap, ...
            'centerSubregionContourSamples', 24, ...
            'domainVisualizationLimits', domainVisualizationLimits, ...
            'domainVisualizationTicks', domainVisualizationTicks, ...
            'withSuperimposedPSF', vLambdaWeightedPSF, ...
            'withSuperimposedPSFcontourLineColor', [1 1 1], ...
            'backgroundColor', [0 0 0]);

        hold(theAxes, 'on');

        superimposeOptimizationGrid = false;
        if (superimposeOptimizationGrid)
            xo = theOptimizationPositionsGrid(iNode,1);
            yo = theOptimizationPositionsGrid(iNode,2);
            width = theOptimizationSizeGrid(iNode,1);
            height = theOptimizationSizeGrid(iNode,2);
            x = xo + 0.5*width*[-1 -1 1 1 -1];
            y = yo + 0.5*height*[-1 1 1 -1 -1];
    
            vertices = [x(:) y(:)];
            patchColor = [1 0 0];
            patch(theAxes, ...
                    'faces', 1:size(vertices,1), ...
                    'vertices',vertices, ...
                    'faceColor', patchColor, ...
                    'edgeColor', [0.7 0.7 0.7], ...
                    'faceAlpha', .1, ...
                    'LineWidth', 1.0);
        end

    end % for iNode

    ff.box = 'on';
    ff.backgroundColor = [0 0 0];
    PublicationReadyPlotLib.applyFormat(theAxes,ff);


    exportVisualizationPDF = true;
    exportVisualizationPNG = true;

    % Subdirectory for exporting the generated PDFs
    exportVisualizationPDFdirectory = 'mosaicVisualizationPDFs';

    if ((exportVisualizationPDF) || (exportVisualizationPNG))

        % Generate figure filename
        opticsString = sprintf('%s_subjectID_%d_%s', whichZernikeDataBase, whichSubjectID, strrep(whichEye, ' ', '_'));
        thePDFfileName = sprintf('%sOpticsAtOptimizationGrid_EccDegs_%2.1f_%2.1f_SizeDegs_%2.2f_%2.2f.pdf', ...
            opticsString, mosaicEccDegs(1), mosaicEccDegs(2), mosaicSizeDegs(1), mosaicSizeDegs(2));

        pdfExportRootDir = RGCMosaicConstructor.filepathFor.rawFigurePDFsDir;
        theVisualizationPDFfilename = fullfile(exportVisualizationPDFdirectory, thePDFfileName);
            
        % Generate the path if we need to
        RGCMosaicConstructor.filepathFor.augmentedPathWithSubdirs(...
             pdfExportRootDir, theVisualizationPDFfilename, ...
            'generateMissingSubDirs', true);
        
        thePDFFullFileName = fullfile(pdfExportRootDir, theVisualizationPDFfilename);
                
        if (exportVisualizationPDF)
            % Export to PDF
            NicePlot.exportFigToPDF(thePDFFullFileName, hFig,  300, 'beVerbose');
        end

        if (exportVisualizationPNG)
            % Eexport to PNG for better color saturation
            NicePlot.exportFigToPNG(strrep(thePDFFullFileName, 'pdf', 'png'),hFig,  300, 'beVerbose');
        end
    end
end


