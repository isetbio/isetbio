%
% RGCMosaicConstructor.helper.simulateExperiment.spatialTransferFunction
%
%
function spatialTransferFunction(theMRGCMosaic, theOI, ...
    STFparamsStruct, theInputConeMosaicSTFResponsesFullFileName, ...
    theMRGCMosaicSTFResponsesFullFileName, varargin)

    p = inputParser;
    p.addParameter('computeInputConeMosaicResponses', false, @islogical);
    p.addParameter('computeInputConeMosaicResponsesBasedOnConeExcitations', true, @islogical);
    p.addParameter('computeInputConeMosaicResponsesBasedOnPhotocurrents', true, @islogical);
    p.addParameter('inspectInputConeMosaicResponses', false, @islogical);
    p.addParameter('computeMRGCMosaicResponses', false, @islogical);
    p.addParameter('debugInputConeMosaicPcurrentResponse', false, @islogical);
    p.addParameter('visualizeResponse', false, @islogical);
    p.addParameter('visualizeStimulusSequence', false, @islogical);
    p.addParameter('mRGCNonLinearityParams', [], @(x)(isempty(x))||(isstruct(x)));
    p.addParameter('customTemporalFrequencyAndContrast', [], @(x)(isempty(x))||(isstruct(x)));
    p.addParameter('validateScenes', false, @islogical);
    p.addParameter('visualizeCustomConeFundamentals', false, @islogical);
    
    % Execute the parser
    p.parse(varargin{:});
    computeInputConeMosaicResponses = p.Results.computeInputConeMosaicResponses;
    computeInputConeMosaicResponsesBasedOnConeExcitations = p.Results.computeInputConeMosaicResponsesBasedOnConeExcitations;
    computeInputConeMosaicResponsesBasedOnPhotocurrents = p.Results.computeInputConeMosaicResponsesBasedOnPhotocurrents;
    inspectInputConeMosaicResponses = p.Results.inspectInputConeMosaicResponses;
    computeMRGCMosaicResponses = p.Results.computeMRGCMosaicResponses;
    mRGCNonLinearityParams = p.Results.mRGCNonLinearityParams;
    customTemporalFrequencyAndContrast = p.Results.customTemporalFrequencyAndContrast;
    visualizeResponse = p.Results.visualizeResponse;
    visualizeStimulusSequence = p.Results.visualizeStimulusSequence;
    debugInputConeMosaicPcurrentResponse = p.Results.debugInputConeMosaicPcurrentResponse;
    validateScenes = p.Results.validateScenes;
    visualizeCustomConeFundamentals = p.Results.visualizeCustomConeFundamentals;

    if (computeInputConeMosaicResponses)
    
        if (computeInputConeMosaicResponsesBasedOnConeExcitations)
            pCurrentTemporalResolutionSeconds = [];
            osBiophysicalModelWarmUpTimeSeconds = [];
            osBiophysicalModelTimeStep = [];
    
            computeInputConeMosaicSTF(theMRGCMosaic, theOI, STFparamsStruct, ...
                theInputConeMosaicSTFResponsesFullFileName, ...
                pCurrentTemporalResolutionSeconds, osBiophysicalModelWarmUpTimeSeconds, osBiophysicalModelTimeStep, ...
                customTemporalFrequencyAndContrast, ...
                visualizeResponse, visualizeStimulusSequence, debugInputConeMosaicPcurrentResponse, ...
                validateScenes, visualizeCustomConeFundamentals, ...
                'cone excitations');
        end
    
    
        if (computeInputConeMosaicResponsesBasedOnPhotocurrents) && ...
           (~isempty(mRGCNonLinearityParams)) && (strcmp(mRGCNonLinearityParams.type, 'photocurrent'))
    
            osBiophysicalModelWarmUpTimeSeconds = mRGCNonLinearityParams.osBiophysicalModelWarmUpTimeSeconds;
            osBiophysicalModelTimeStep = mRGCNonLinearityParams.osBiophysicalModelTemporalResolutionSeconds;
            pCurrentTemporalResolutionSeconds = mRGCNonLinearityParams.pCurrentTemporalResolutionSeconds;
    
            computeInputConeMosaicSTF(theMRGCMosaic, theOI, STFparamsStruct, ...
                theInputConeMosaicSTFResponsesFullFileName, ...
                pCurrentTemporalResolutionSeconds, osBiophysicalModelWarmUpTimeSeconds, osBiophysicalModelTimeStep, ...
                customTemporalFrequencyAndContrast, ...
                visualizeResponse, visualizeStimulusSequence, debugInputConeMosaicPcurrentResponse, ...
                validateScenes, visualizeCustomConeFundamentals, ...
                'photocurrents');
        end
    end % if (computeInputConeMosaicResponses)


    if (computeMRGCMosaicResponses)
        computeMRGCMosaicSTF(theMRGCMosaic, ...
            theInputConeMosaicSTFResponsesFullFileName, ...
            theMRGCMosaicSTFResponsesFullFileName, ...
            visualizeResponse, ...
            mRGCNonLinearityParams, ...
            inspectInputConeMosaicResponses);
    end
end



function computeInputConeMosaicSTF(theMRGCMosaic, theOI, STFparamsStruct, theInputConeMosaicSTFResponsesFullFileName, ...
    pCurrentTemporalResolutionSeconds, photocurrentModelWarmUpTimeSeconds, osTimeStep, ...
    customTemporalFrequencyAndContrast, ...
    visualizeResponse, visualizeStimulusSequence, debugInputConeMosaicPcurrentResponse, ...
    validateScenes, visualizeCustomConeFundamentals, theSignal)

    % Compute the cone excitations
    if (strcmp(theSignal,'cone excitations'))
        fprintf('Input cone mosaic STF responses will be saved in: \n%s\n', theInputConeMosaicSTFResponsesFullFileName);
        % Determine spatial frequencies examined
        minPixelsPerSpatialPeriod = 6;
    
        % Add the maxSF given the stimulus resolution, but only if this is <= 120CPD
        maxSF = min([120 1/(minPixelsPerSpatialPeriod*STFparamsStruct.resolutionDegs)]);
    
        spatialFrequenciesExamined = STFparamsStruct.sfSupport(STFparamsStruct.sfSupport <= maxSF);
        if (max(spatialFrequenciesExamined) < maxSF - 0.01)
            spatialFrequenciesExamined(numel(spatialFrequenciesExamined)+1) = maxSF;
        end
    
        % Orientations examined
        orientationsExamined = 0:STFparamsStruct.orientationDeltaDegs:(180-STFparamsStruct.orientationDeltaDegs);
    
        % Compute cone contrasts for desired chromaticity
        coneContrasts = ...
            visualStimulusGenerator.coneContrastsFromChromaticity(STFparamsStruct.chromaticity);
    
        % The defaults TF and achromatic contrast
        if (isempty(customTemporalFrequencyAndContrast))
            temporalFrequencyHz = 1.0;
            totalContrast = 0.75;
        else
            temporalFrequencyHz = customTemporalFrequencyAndContrast.temporalFrequencyHz;
            totalContrast = customTemporalFrequencyAndContrast.totalContrast;
        end

        stimParams = struct(...
            'displayType', STFparamsStruct.displayType, ...
            'backgroundChromaticity', STFparamsStruct.backgroundChromaticity, ...
            'backgroundLuminanceCdM2', STFparamsStruct.backgroundLuminanceCdM2, ...
            'contrast', totalContrast, ...
            'coneContrasts', coneContrasts, ...
            'sizeDegs', STFparamsStruct.sizeDegs, ...
            'positionDegs', STFparamsStruct.positionDegs, ...
            'resolutionDegs', STFparamsStruct.resolutionDegs, ...
            'spatialPhaseIncrementDegs', STFparamsStruct.spatialPhaseIncrementDegs, ...
            'temporalFrequencyHz', temporalFrequencyHz, ...
            'durationSeconds', 1.0/temporalFrequencyHz, ...
            'orientationDegs', orientationsExamined(1), ...
            'spatialFrequencyCPD', spatialFrequenciesExamined(1), ...
            'coneMosaicModulationBasedResponse',  true ...
            );

        % Generate presentation display, 20% luminance headroom
        viewingDistanceMeters = 4;
    
        thePresentationDisplay = visualStimulusGenerator.presentationDisplay(...
            theMRGCMosaic.inputConeMosaic.wave, ...
            STFparamsStruct.resolutionDegs, ...
            viewingDistanceMeters, ...
            'displayType', STFparamsStruct.displayType, ...
            'bitDepth', 20, ...
            'meanLuminanceCdPerM2', STFparamsStruct.backgroundLuminanceCdM2, ...
            'luminanceHeadroom', STFparamsStruct.displayLuminanceHeadroomPercentage);


        % Allocate memory (Single precision responses) to store all the cone mosaic responses
        [~, ~, spatialPhasesDegs, stimulusFrameSequenceTemporalSupportSeconds] = ...
            visualStimulusGenerator.driftingGratingModulationPatterns(stimParams);
    
        theInputConeMosaicSTFresponses = zeros(...
            numel(orientationsExamined), ...
            numel(spatialFrequenciesExamined), ...
            numel(spatialPhasesDegs), ...
            theMRGCMosaic.inputConeMosaic.conesNum, ...
            'single');
    
        if (STFparamsStruct.coneFundamentalsOptimizedForStimPosition)
            % Compute custom cone fundamentals
            maxConesNumForAveraging = 3;
            customConeFundamentals = visualStimulusGenerator.coneFundamentalsForPositionWithinConeMosaic(...
                theMRGCMosaic.inputConeMosaic, theOI, stimParams.positionDegs, stimParams.sizeDegs, maxConesNumForAveraging);
        end

        for iOri = 1:numel(orientationsExamined)
        for iSF = 1:numel(spatialFrequenciesExamined)

            % Get stim params
            stimParams.orientationDegs = orientationsExamined(iOri);
            stimParams.spatialFrequencyCPD = spatialFrequenciesExamined(iSF);

            % Feedback
            fprintf('Computing input cone mosaic STF (cone excitations-based) for ORI = %d degrees and SF = %2.3f c/deg\n', ...
                stimParams.orientationDegs, stimParams.spatialFrequencyCPD);

            % Generate the spatial modulation patterns for all spatial phases of the drifting grating
            [theDriftingGratingSpatialModulationPatterns, spatialSupportDegs, spatialPhasesDegs, ...
                temporalSupportSeconds, temporalRamp] = visualStimulusGenerator.driftingGratingModulationPatterns(stimParams);

            if (STFparamsStruct.coneFundamentalsOptimizedForStimPosition)
                if ((iOri==1)&&(iSF==1))
                    % Generate scenes for the different frames of the drifting grating and for the null stimulus
                    [theDriftingGratingFrameScenes, theNullStimulusScene, ~, theConeFundamentalsStruct] = visualStimulusGenerator.stimulusFramesScenes(...
                        thePresentationDisplay, stimParams, theDriftingGratingSpatialModulationPatterns, ...
                        'frameIndexToCompute', [], ... % [] field indicates that all stimulus frame scenes must be computed
                        'customConeFundamentals', customConeFundamentals, ...
                        'announceEmployedConeFundamentals', true, ...
                        'validateScenes', validateScenes, ...
                        'visualizeCustomConeFundamentals', visualizeCustomConeFundamentals);
                else
                    [theDriftingGratingFrameScenes, theNullStimulusScene] = visualStimulusGenerator.stimulusFramesScenes(...
                        thePresentationDisplay, stimParams, theDriftingGratingSpatialModulationPatterns, ...
                        'frameIndexToCompute', [], ... % [] field indicates that all stimulus frame scenes must be computed
                        'withPreviouslyComputedConeFundamentalsStruct', theConeFundamentalsStruct, ...
                        'announceEmployedConeFundamentals', true, ...
                        'validateScenes', ~true);
                end

            else
                % Generate scenes for the different frames of the drifting grating and for the null stimulus
                [theDriftingGratingFrameScenes, theNullStimulusScene] = visualStimulusGenerator.stimulusFramesScenes(...
                    thePresentationDisplay, stimParams, theDriftingGratingSpatialModulationPatterns, ...
                    'frameIndexToCompute', [], ... % [] field indicates that all stimulus frame scenes must be computed
                    'validateScenes', ~true);
            end

            % Compute input cone mosaic response to this orientation & spatial frequency
            stimulusPosition = 'mosaic-centered';

            % Set the mosaic integration time equal to the duration of one stimulus frame
            theMRGCMosaic.inputConeMosaic.integrationTime = temporalSupportSeconds(2)-temporalSupportSeconds(1);

            % Compute cone mosaic responses to each stimulus frame
            [theInputConeMosaicSTFresponses(iOri, iSF,:,:), theConeMosaicNullResponse] = ...
                RGCMosaicConstructor.helper.simulateExperiment.inputConeMosaicResponseToStimulusFrameSequence(...
                theMRGCMosaic, theOI, theNullStimulusScene, theDriftingGratingFrameScenes, ...
                stimulusPosition, stimParams.coneMosaicModulationBasedResponse, ...
                'visualizeResponse', visualizeResponse, ...
                'visualizeStimulusSequence', visualizeStimulusSequence, ...
                'thePresentationDisplayForVisualizingOpticalSceneOrImage', thePresentationDisplay, ...
                'stimulusInfoString', sprintf('ORI:%d degs, SF:%2.2f c/deg', stimParams.orientationDegs, stimParams.spatialFrequencyCPD));

        end % iSF
        end % iORI

        % Save results
        fprintf('Saving computed input cone mosaic STF cone excitation responses to %s.\n', theInputConeMosaicSTFResponsesFullFileName);
        stimParams.orientationDegs = orientationsExamined;
        stimParams.spatialFrequencyCPD = spatialFrequenciesExamined;
        stimParams.spatialPhasesDegs = spatialPhasesDegs;
        stimParams.temporalSupportSeconds = temporalSupportSeconds;
        stimParams.temporalRamp = temporalRamp;

        save(theInputConeMosaicSTFResponsesFullFileName, ...
            'theMRGCMosaic', ...
            'STFparamsStruct', ...
            'stimParams', ...
            'theInputConeMosaicSTFresponses', ...
            'theConeMosaicNullResponse', ...
            '-v7.3');
    end % if (strcmp(theSignal,'cone excitations'))


    % Compute the photocurrents
    if (strcmp(theSignal, 'photocurrents'))
    
        load(theInputConeMosaicSTFResponsesFullFileName, ...
            'theMRGCMosaic', ...
            'STFparamsStruct', ...
            'stimParams', ...
            'theInputConeMosaicSTFresponses', ...
            'theConeMosaicNullResponse');
    
        stimulusPeriodDuration = 1/stimParams.temporalFrequencyHz;
        nWarmUpPeriods = ceil(photocurrentModelWarmUpTimeSeconds/stimulusPeriodDuration);
    
        for iOri = 1:numel(stimParams.orientationDegs)
        for iSF = 1:numel(stimParams.spatialFrequencyCPD)
    
            theConeMosaicResponseSequence = squeeze(theInputConeMosaicSTFresponses(iOri, iSF,:,:));

            % Transform cone modulations to cone excitations
            if (stimParams.coneMosaicModulationBasedResponse)
                theConeMosaicNullResponse = squeeze(theConeMosaicNullResponse);
                theConeMosaicNullResponse = reshape(theConeMosaicNullResponse, [1 numel(theConeMosaicNullResponse)]);

                % Transform from modulations to excitations
                %Rmod = (Recx-Ro)/Ro -> (Rmod+1)*Ro = RExc
                theConeMosaicResponseSequence = theConeMosaicResponseSequence  + 1;
                theConeMosaicResponseSequence = bsxfun(@times, theConeMosaicResponseSequence, theConeMosaicNullResponse);
            end

            % Compute the photocurrent response
            plotTitle = sprintf('ori: %d degs, sf: %2.1f cpd', stimParams.orientationDegs(iOri), stimParams.spatialFrequencyCPD(iSF));

            fprintf('Computing input cone mosaic STF (photocurrent-based) for ORI = %d degrees and SF = %2.3f c/deg\n', ...
                stimParams.orientationDegs(iOri), stimParams.spatialFrequencyCPD(iSF));

            [theInputConeMosaicPhotocurrentTemporalSupportSeconds, ...
                theInputConeMosaicPhotocurrents(iOri, iSF,:,:), ...
                theInputConeMosaicBackgroundPhotocurrents(iOri, iSF,:)] = RGCMosaicAnalyzer.compute.photocurrentsForOneStimulusPeriod(...
                    theMRGCMosaic.eccentricityDegs, ...
                    stimParams.temporalSupportSeconds(1:end-1,:), ...   % Get rid of last point which is a repeat of the first point 
                    theConeMosaicResponseSequence(1:end-1,:), ...       % Get rid of last point which is a repeat of the first point 
                    nWarmUpPeriods, ...
                    pCurrentTemporalResolutionSeconds, osTimeStep, ...
                    theMRGCMosaic.inputConeMosaic.coneTypes, ...
                    debugInputConeMosaicPcurrentResponse, ...
                    plotTitle);
        end % iSF
        end % iORI
    
        % Append photocurrents
        theInputConeMosaicPhotocurrents = single(theInputConeMosaicPhotocurrents);
        theInputConeMosaicBackgroundPhotocurrents = single(theInputConeMosaicBackgroundPhotocurrents);
    
        save(theInputConeMosaicSTFResponsesFullFileName, ...
            'theInputConeMosaicPhotocurrentTemporalSupportSeconds', ...
            'theInputConeMosaicPhotocurrents', ...
            'theInputConeMosaicBackgroundPhotocurrents', ...
            '-append');
    
    end %if (strcmp(theSignal, 'photocurrents'))

end


function computeMRGCMosaicSTF(...
    thePassedMRGCMosaic, ...
    theInputConeMosaicSTFResponsesFullFileName, ...
    theMRGCMosaicSTFResponsesFullFileName, ...
    visualizeResponse, ...
    mRGCNonLinearityParams, ...
    onlyInspectInputConeMosaicResponses)

    if (~isempty(mRGCNonLinearityParams)) && (strcmp(mRGCNonLinearityParams.type, 'photocurrent'))
        % Load cone excitation + photocurrent responses
    
        computedSTFs = who('-file', theInputConeMosaicSTFResponsesFullFileName);
        photocurrentBasedSTFsComputed = ismember('theInputConeMosaicPhotocurrents', computedSTFs);
    
        if (photocurrentBasedSTFsComputed)
            load(theInputConeMosaicSTFResponsesFullFileName, ...
                'theMRGCMosaic', 'stimParams', ...
                'theInputConeMosaicSTFresponses', ...
                'theInputConeMosaicPhotocurrentTemporalSupportSeconds', ...
                'theInputConeMosaicPhotocurrents', ...
                'theInputConeMosaicBackgroundPhotocurrents');
    
            % Check that all photocurrent response dimensions (other than time) agree with the cone excitation responses
            assert(size(theInputConeMosaicSTFresponses,1) == size(theInputConeMosaicPhotocurrents,1), ...
                'Mismatch in # of orientations');
    
            assert(size(theInputConeMosaicSTFresponses,2) == size(theInputConeMosaicPhotocurrents,2), ...
                'Mismatch in # of spatial frequencies');
    
            assert(size(theInputConeMosaicSTFresponses,4) == size(theInputConeMosaicPhotocurrents,4), ...
                'Mismatch in # of cones');
        else
            load(theInputConeMosaicSTFResponsesFullFileName, ...
                'theMRGCMosaic', 'stimParams', ...
                'theInputConeMosaicSTFresponses');
    
            theInputConeMosaicPhotocurrentTemporalSupportSeconds = [];
            theInputConeMosaicPhotocurrents = [];
            theInputConeMosaicBackgroundPhotocurrents = [];
        end

    else
        % Load only cone excitation responses
        fprintf('Loading computed input cone mosaic STF responses from %s.\n', theInputConeMosaicSTFResponsesFullFileName);
        load(theInputConeMosaicSTFResponsesFullFileName, ...
            'theMRGCMosaic', 'stimParams', ...
            'theInputConeMosaicSTFresponses');
    
        theInputConeMosaicPhotocurrentTemporalSupportSeconds = [];
        theInputConeMosaicPhotocurrents = [];
        theInputConeMosaicBackgroundPhotocurrents = [];
    end


    theConeMosaicResponseTemporalSupportSeconds = stimParams.temporalSupportSeconds;
    
    % Assert that the input cone mosaic in the stored mRGC mosaic is the same as the input cone mosaic of the passed mRGC Mosaic
    assert(thePassedMRGCMosaic.inputConeMosaic.conesNum == theMRGCMosaic.inputConeMosaic.conesNum, ...
        'Number of cones in the loaded input cone mosaic STF responses file is not identicial to the that of input cone mosaic of the passed mRGC mosaic');
    assert(all(thePassedMRGCMosaic.inputConeMosaic.coneTypes == theMRGCMosaic.inputConeMosaic.coneTypes), ...
        'Cone types in the loaded input cone mosaic STF responses file are not identicial to those of the input cone mosaic of the passed mRGC mosaic');
    
    % Input cone mosaics are identical so switch to the passed mRGC mosaic which may have different characteristics of the mRGCs but identical
    % input cone mosaic
    clear 'theMRGCMosaic'
    theMRGCMosaic = thePassedMRGCMosaic;

    if (onlyInspectInputConeMosaicResponses)
        inspectInputConeMosaicSpatioTemporalResponses(...
            stimParams, ...
            theMRGCMosaic.inputConeMosaic, ...
            theInputConeMosaicSTFresponses, ...
            theConeMosaicResponseTemporalSupportSeconds, ...
            theInputConeMosaicPhotocurrents, ...
            theInputConeMosaicBackgroundPhotocurrents, ...
            theInputConeMosaicPhotocurrentTemporalSupportSeconds);
        return;
    end


    % Continue with computation of mRGC mosaic responses
    
    % (1) Compute mRGC responses based on cone excitations
    [theNoiseFreeSpatioTemporalMRGCMosaicResponses2DSTF, ...
        theMRGCMosaicResponseTemporalSupportSeconds] = computeMRGCMosaicResponsesForInputConeMosaicSignal(...
        stimParams, ...
        theMRGCMosaic, ...
        theInputConeMosaicSTFresponses, ...
        theConeMosaicResponseTemporalSupportSeconds, ...
        mRGCNonLinearityParams, ...
        stimParams.contrast, ...
        'cone excitations based response', ...
        visualizeResponse);
    
    save(theMRGCMosaicSTFResponsesFullFileName, ...
        'theMRGCMosaic', 'stimParams', ...
        'theNoiseFreeSpatioTemporalMRGCMosaicResponses2DSTF', ...
        'theMRGCMosaicResponseTemporalSupportSeconds', '-v7.3');


    % (2) Compute mRGC responses based on photocurrents
    if (~isempty(theInputConeMosaicPhotocurrentTemporalSupportSeconds))
    
        [theNoiseFreeSpatioTemporalMRGCMosaicPcurrentBasedResponses2DSTF, ...
            theMRGCMosaicPcurrentBasedResponseTemporalSupportSeconds] = computeMRGCMosaicResponsesForInputConeMosaicSignal(...
            stimParams, ...
            theMRGCMosaic, ...
            theInputConeMosaicPhotocurrents, ...
            theInputConeMosaicPhotocurrentTemporalSupportSeconds, ...
            mRGCNonLinearityParams, ...
            stimParams.contrast, ...
            'photocurrents based response', ...
            visualizeResponse);
    
        % Append the photocurrent based responses
        save(theMRGCMosaicSTFResponsesFullFileName, ...
            'theNoiseFreeSpatioTemporalMRGCMosaicPcurrentBasedResponses2DSTF', ...
            'theMRGCMosaicPcurrentBasedResponseTemporalSupportSeconds', ...
            '-append');
    
    end %if (~isempty(theInputConeMosaicPhotocurrentTemporalSupportSeconds))
end


function [theSpatioTemporalMRGCMosaicResponses2DSTF, theMRGCMosaicResponseTemporalSupportSeconds] = ...
    computeMRGCMosaicResponsesForInputConeMosaicSignal(...
    stimParams, ...
    theMRGCMosaic, ...
    theResponses, ...
    theTemporalSupportSeconds, ...
    mRGCNonLinearityParams, ...
    stimulusContrast, ...
    inputConeMosaicSignalLabel, ...
    visualizeResponse)

    % Allocate memory
    coneMosaicResponseSize = [1 size(theResponses,3) size(theResponses,4)];
    theConeMosaicSpatioTemporalResponse = ...
        reshape(squeeze(theResponses(1, 1, :,:)), coneMosaicResponseSize);
    
    [~, ~, theMRGCMosaicResponseTemporalSupportSeconds] = theMRGCMosaic.compute( ...
        theConeMosaicSpatioTemporalResponse, theTemporalSupportSeconds, ...
        'nonLinearityParams', mRGCNonLinearityParams);
    
    theSpatioTemporalMRGCMosaicResponses2DSTF = zeros(...
        numel(stimParams.orientationDegs), numel(stimParams.spatialFrequencyCPD), ...
        numel(theMRGCMosaicResponseTemporalSupportSeconds), theMRGCMosaic.rgcsNum);


    for iOri = 1:numel(stimParams.orientationDegs)
        fprintf('Computing mRGC responses for orientation: %d\n', stimParams.orientationDegs(iOri));
        parfor iSF = 1:numel(stimParams.spatialFrequencyCPD)
    
            theConeMosaicSpatioTemporalResponse = ...
                reshape(squeeze(theResponses(iOri, iSF, :,:)), coneMosaicResponseSize);
    
            [theSpatioTemporalMRCMosaicResponse, ~, ...
                theMRGCMosaicResponseTemporalSupportSeconds] = theMRGCMosaic.compute( ...
                theConeMosaicSpatioTemporalResponse, theTemporalSupportSeconds, ...
                'nonLinearityParams', mRGCNonLinearityParams);
    
            % Normalize for contrast
            theSpatioTemporalMRCMosaicResponse = theSpatioTemporalMRCMosaicResponse / stimulusContrast;
    
            % Save response
            theSpatioTemporalMRGCMosaicResponses2DSTF(iOri, iSF, :,:) = reshape(...
                theSpatioTemporalMRCMosaicResponse, [1 1 numel(theMRGCMosaicResponseTemporalSupportSeconds) theMRGCMosaic.rgcsNum]);
        end % parcomputeMRGCMosaicSTF
    end % for iOri

    if (visualizeResponse)
        hFig = figure(55);
        set(hFig, 'Position', [10 10 900, 900]);
        clf;
        ax = subplot(1,1,1);
    
        mRGCMosaicActivationRange = [min(theSpatioTemporalMRGCMosaicResponses2DSTF(:)) max(theSpatioTemporalMRGCMosaicResponses2DSTF(:))];
    
        for iOri = 1:numel(stimParams.orientationDegs)
            for iSF = 1:numel(stimParams.spatialFrequencyCPD)
    
                theSpatioTemporalMRCMosaicResponse = squeeze(theSpatioTemporalMRGCMosaicResponses2DSTF(iOri, iSF, :,:));
    
                for iTimeBin = 1:numel(theMRGCMosaicResponseTemporalSupportSeconds)
                    if (iTimeBin == 1)
                        clearAxesBeforeDrawing = true;
                    else
                        clearAxesBeforeDrawing = false;
                    end
                    theFrameResponse = reshape(theSpatioTemporalMRCMosaicResponse(iTimeBin,:), [1 1 theMRGCMosaic.rgcsNum]);
    
                    theMRGCMosaic.visualize(...
                        'clearAxesBeforeDrawing', clearAxesBeforeDrawing, ...
                        'figureHandle', hFig, ...
                        'axesHandle', ax, ...
                        'activation', theFrameResponse, ...
                        'activationRange', mRGCMosaicActivationRange, ...
                        'clearAxesBeforeDrawing', false, ...
                        'plotTitle', sprintf('%s, t: %2.1f msec (ori:%2.0f, sf:%2.1f cpd)', inputConeMosaicSignalLabel, theMRGCMosaicResponseTemporalSupportSeconds(iTimeBin)*1e3, stimParams.orientationDegs(iOri), stimParams.spatialFrequencyCPD(iSF)));
    
                    drawnow;
                end % for iTimeBin
            end
        end
    end  % if (visualizeResponse)
end


function inspectInputConeMosaicSpatioTemporalResponses(...
    stimParams, theInputConeMosaic, ...
    theInputConeMosaicSTFresponses, ...
    theInputConeMosaicResponseTemporalSupportSeconds, ...
    theInputConeMosaicPhotocurrentSTFresponses, ...
    theInputConeMosaicBackgroundPhotocurrents, ...
    theInputConeMosaicPhotocurrentResponseTemporalSupportSeconds)

    orientationsNum = size(theInputConeMosaicSTFresponses,1);
    sfsNum = size(theInputConeMosaicSTFresponses,2);
    
    coneMosaicResponseSize = [1 numel(theInputConeMosaicResponseTemporalSupportSeconds) theInputConeMosaic.conesNum];
    coneMosaicPhotocurrentResponseSize = [1 numel(theInputConeMosaicPhotocurrentResponseTemporalSupportSeconds) theInputConeMosaic.conesNum];
    
    coneExcitationsResponseRange = [min(theInputConeMosaicSTFresponses(:)) max(theInputConeMosaicSTFresponses(:))];
    photocurrentResponseRange = [min(theInputConeMosaicPhotocurrentSTFresponses(:)) max(theInputConeMosaicPhotocurrentSTFresponses(:))];
    
    exemplarConeIndex = find(theInputConeMosaic.coneTypes == cMosaic.LCONE_ID);
    exemplarLConeIndex = exemplarConeIndex(1);
    
    exemplarConeIndex = find(theInputConeMosaic.coneTypes == cMosaic.MCONE_ID);
    exemplarMConeIndex = exemplarConeIndex(1);
    
    exemplarConeIndex = find(theInputConeMosaic.coneTypes == cMosaic.SCONE_ID);
    exemplarSConeIndex = exemplarConeIndex(1);


    if (~isempty(exemplarLConeIndex))
        hFig{1} = figure(40); clf;
        set(hFig{1}, 'Position', [10 10 500 1150], 'Color', [1 1 1]);
    end
    
    if (~isempty(exemplarMConeIndex))
        hFig{2} = figure(50); clf;
        set(hFig{2}, 'Position', [510 10 500 1150], 'Color', [1 1 1]);
    end
    
    if (~isempty(exemplarSConeIndex))
        hFig{3} = figure(60); clf;
        set(hFig{3}, 'Position', [1020 10 500 1150], 'Color', [1 1 1]);
    end
    
    orientationsNum = size(theInputConeMosaicSTFresponses, 1);
    sfsNum = size(theInputConeMosaicSTFresponses, 2);

    for iOri = 1:orientationsNum
    for iSF = 1:sfsNum

        theConeMosaicSpatioTemporalExcitationsResponses = ...
            reshape(squeeze(theInputConeMosaicSTFresponses(iOri, iSF, :,:)), coneMosaicResponseSize);

        if (~isempty(theInputConeMosaicPhotocurrentSTFresponses))
            theConeMosaicSpatioTemporalPhotocurrentResponses = ...
                reshape(squeeze(theInputConeMosaicPhotocurrentSTFresponses(iOri, iSF, :,:)), coneMosaicPhotocurrentResponseSize);
            theConeMosaicBackgroundPhotocurrents = theInputConeMosaicBackgroundPhotocurrents(iOri, iSF,:);
        end


        coneExcitationsTransformedIntoResponseModulations = true;

        plotTitle = sprintf('<cL,cM,cS> = <%1.2f,%1.2f,%1.2f>\nori: %d (degs), sf: %2.2f (c/deg)', ...
            stimParams.coneContrasts(1)*stimParams.contrast, ...
            stimParams.coneContrasts(2)*stimParams.contrast, ...
            stimParams.coneContrasts(3)*stimParams.contrast, ...
            stimParams.orientationDegs(iOri), stimParams.spatialFrequencyCPD(iSF));

        if (~isempty(exemplarLConeIndex))
            RGCMosaicAnalyzer.visualize.coneExcitationsVsPhotocurrentResponse(...
                hFig{1}, ...
                plotTitle, ...
                theInputConeMosaic.coneTypes(exemplarLConeIndex), ...
                theInputConeMosaicResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalExcitationsResponses(1,:,exemplarLConeIndex)), ...
                coneExcitationsTransformedIntoResponseModulations, ...
                theInputConeMosaicPhotocurrentResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalPhotocurrentResponses(1,:,exemplarLConeIndex)), ...
                theConeMosaicBackgroundPhotocurrents(exemplarConeIndex), ...
                [], [], ...
                [], [], []);
        end


        if (~isempty(exemplarMConeIndex))
            RGCMosaicAnalyzer.visualize.coneExcitationsVsPhotocurrentResponse(...
                hFig{2}, ...
                plotTitle, ...
                theInputConeMosaic.coneTypes(exemplarMConeIndex), ...
                theInputConeMosaicResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalExcitationsResponses(1,:,exemplarMConeIndex)), ...
                coneExcitationsTransformedIntoResponseModulations, ...
                theInputConeMosaicPhotocurrentResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalPhotocurrentResponses(1,:,exemplarMConeIndex)), ...
                theConeMosaicBackgroundPhotocurrents(exemplarConeIndex), ...
                [], [], ...
                [], [], []);
        end


        if (~isempty(exemplarSConeIndex))
            RGCMosaicAnalyzer.visualize.coneExcitationsVsPhotocurrentResponse(...
                hFig{3}, ...
                plotTitle, ...
                theInputConeMosaic.coneTypes(exemplarSConeIndex), ...
                theInputConeMosaicResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalExcitationsResponses(1,:,exemplarSConeIndex)), ...
                coneExcitationsTransformedIntoResponseModulations, ...
                theInputConeMosaicPhotocurrentResponseTemporalSupportSeconds, ...
                squeeze(theConeMosaicSpatioTemporalPhotocurrentResponses(1,:,exemplarSConeIndex)), ...
                theConeMosaicBackgroundPhotocurrents(exemplarConeIndex), ...
                [], [], ...
                [], [], []);
        end

        fprintf('\n\n----> Hit enter to continue with next stimulus ...\n\n')
        pause;

        visualizeAllResponseFrames = false;
        if (visualizeAllResponseFrames)
            hFig = figure(44);clf;
            ax1 = subplot(1,2,1);
            ax2 = subplot(1,2,2);

            for iTimeBin = 1:numel(theInputConeMosaicResponseTemporalSupportSeconds)
                theFrameResponse = theConeMosaicSpatioTemporalExcitationsResponses(1,iTimeBin,:);
                theInputConeMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', ax1, ...
                    'activation', theFrameResponse, ...
                    'activationRange', coneExcitationsResponseRange, ...
                    'plotTitle', sprintf('cone excitations (%d msec)', 1000*theInputConeMosaicResponseTemporalSupportSeconds(iTimeBin)));

                if (~isempty(theInputConeMosaicPhotocurrentSTFresponses))
                    theFrameResponse = theConeMosaicSpatioTemporalPhotocurrentResponses(1,iTimeBin,:);
                    theInputConeMosaic.visualize(...
                        'figureHandle', hFig, ...
                        'axesHandle', ax2, ...
                        'activation', theFrameResponse, ...
                        'activationRange', photocurrentResponseRange, ...
                        'plotTitle', 'photocurrents');
                end
                drawnow;
            end % for iTimeBin
        end % if (visualizeAllResponseFrames)

    end % for iSF
    end % for iOri

end

