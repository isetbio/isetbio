% Script to generate center-connected mRGC mosaics for different values of
% spatialChromaticUniformityTradeoff at different eccentricities. 
% The script is also used to generate 
% materials for the center-connectivity figures of our PLOS2024 paper
%
% Usage:
%{
    t_testRGCMosaicConstructorCenterConnectivity    
%}

% Initialize session
close all; clear all;

% Configure a conservative parpool manager. This gives at least 8 GB RAM/core
ASPPManager = AppleSiliconParPoolManager('conservative');

% Examined spatialChromaticUniformityTradeoff  values 
% [0: maximize RF center chromatic uniformity, 1: maximize RF center spatial uniformity]
tradeOffValues = [1.0]; 

% Default search within neighboring RFs 
maxNeighborsNum = MosaicConnector.maxNeighborsNum;
maxNeighborNormDistance = MosaicConnector.maxNeighborNormDistance;


% Optimization center: detemines the order in which RFs are optimized
optimizationCenter = 'localSpacing'; % 'origin'; % localSpacing'; 'localConeToRGCdensityRatio'

% Do not recompute local spacing  based on current RF centroids (use the input RGC position lattice instead)
localSpacingFromCurrentCentroids = true;


% Valid eccentricity strings are:
% rgcMosaicName: choose between {...
%   'VSS2024TalkTemporal3DegsMosaic' ...
%   'PLOSpaperFovealMosaic' ...
%   'PLOSpaperTemporal2DegsMosaic' ...
%   'PLOSpaperTemporal4DegsMosaic' ...
%   'PLOSpaperTemporal7DegsMosaic' ...
%   'PLOSpaperTemporal10DegsMosaic' ...
%   'PLOSpaperTemporal14DegsMosaic' ...
%   'PLOSpaperTemporal19DegsMosaic' ...
%   'PLOSpaperTemporal25DegsMosaic' ...
%   'PLOSpaperTemporal32DegsMosaic' ...
%   }

% Initialize RGCMosaic generation params
% Human mosaic 
rgcMosaicName = 'PLOSpaperTemporal10DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal14DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal19DegsMosaic';

% Run with mRGCMosaic.amplificationInCenterOnlySensitivityCausedByInactiveSurrounds set to 0.7 (from 0.85)
%rgcMosaicName = 'PLOSpaperTemporal32DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal25DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal19DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal14DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal10DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal7DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal4DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal4DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperTemporal2DegsMosaicLowerOverlap';
%rgcMosaicName = 'PLOSpaperFovealMosaicLowerOverlap';


% Run with
% mRGCMosaic.amplificationInCenterOnlySensitivityCausedByInactiveSurrounds 0.6 
% (best agreement in RF center overlap with Gauthier)

%rgcMosaicName = 'PLOSpaperTemporal32DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal25DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal19DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal14DegsMosaic';
rgcMosaicName = 'PLOSpaperTemporal10DegsMosaic';
%rgcMosaicName = 'PLOSpaperTemporal7DegsMosaic';
%rgcMosaicName = 'PLOSpaperTemporal4DegsMosaic';
%rgcMosaicName = 'PLOSpaperTemporal2DegsMosaic';
%rgcMosaicName = 'PLOSpaperFovealMosaic';

opticsSubjectName = 'PLOSpaperDefaultSubject';
coneMosaicSpecies = 'human';
targetVisualSTFdescriptorToOptimizeFor = '';  % Irrelevant for center connectivity
pStruct = RGCMosaicConstructor.helper.utils.initializeRGCMosaicGenerationParameters(...
    coneMosaicSpecies, opticsSubjectName, rgcMosaicName, targetVisualSTFdescriptorToOptimizeFor);

if (1==2)
% Macaque mosaic
rgcMosaicName = 'VSS2024TalkTemporal3DegsMosaic';
rgcMosaicName = 'VSS2024TalkTemporal7DegsMosaic';
opticsSubjectName = 'VSS2024TalkFirstSubject';
coneMosaicSpecies = 'macaque';
targetVisualSTFdescriptorToOptimizeFor = '';  % Irrelevant for center connectivity
pStruct = RGCMosaicConstructor.helper.utils.initializeRGCMosaicGenerationParameters(...
    coneMosaicSpecies, opticsSubjectName, rgcMosaicName, targetVisualSTFdescriptorToOptimizeFor);
end
      
% Determine the max number of cones that can be
% transferred or swapped between nearby RF centers, depending on
% the mosaic eccentricity
[maxConeInputsPerRGCToConsiderTransferToNearbyRGCs, ...
 maxConeInputsPerRGCToConsiderSwappingWithNearbyRGCs] = ...
    MosaicConnector.coneTransferAndSwapLimits(pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs);

    
% RandomSeed so we get same cone assignments in the inputConeMosaic
randomSeedForFreezingCmosaicConeAssignment = 1;

% Cone types included in RF center (exclusive)
coneTypesIncludedInRFcenter = [cMosaic.LCONE_ID cMosaic.MCONE_ID];

% RF center overlap params
rfCenterOverlapParams = struct(...
    'sensitivityAtPointOfOverlap', mRGCMosaic.sensitivityAtPointOfOverlap, ...  
    'minSensitivityForInclusion', mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections, ...
    'maxNumberOfConesOutsideContour', 0, ...
    'overlappingWeightsDivergencePattern', 'inLineWithExclusiveConnections', ...  % choose from {'isotropic', 'inLineWithExclusiveConnections', 'orthogonalToExclusiveConnections'}
    'coneTypesIncluded', coneTypesIncludedInRFcenter);


latticeParamsStruct = struct(...
        'neuronType', '', ...     
        'whichEye', pStruct.whichEye, ...
        'fovDegs', pStruct.sourceLatticeSizeDegs, ...
        'eccentricityLookUpTableSize', 512, ...
        'maxIterations', 8000, ...
        'exportHistoryToFile', true, ...
        'visualizeConvergence', true, ... 
        'useParfor', true);

% ------ RF position lattice generation ------
generateMRGCRFpositionsLattice = ~true;
generateConeRFpositionsLattice = ~true;

% ------ MOSAIC GENERATION ACTIONS ---------
% STEP1: Generate mosaic
generateNewMosaic = ~true;

% STEP2: Overlap in RF centers with RF center overlap from an existing center-only connected mosaic
generateRFcenterOverlappingMosaicFromCenterOnlyConnectedMosaic = ~true;
visualizeGenerationOfOverlappingRFcenterWeights = ~true;


% ------ MOSAIC VISUALIZATION ACTIONS ---------
% Visualize the full mosaic
visualizeFullMosaic = true;
identifyInputConesInFullMosaic = ~true;
identifyPooledConesInFullMosaic = ~true;

% Whether to visualize a small patch within the mosaic
% If empty, we are visualizing the entire mosaic
visualizedPatchWithinMosaic = [];

% Otherwise visualize a 3 x 0.6 deg patch
visualizedMaxEcc = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1)+2.2;
visualizedMaxEcc = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1)+2.5;

visualizedMaxEcc = -16.5; % Fig panel C with 'PLOSpaperTemporal19DegsMosaic'
visualizedMaxEcc = -12;  % Fig panel B with 'PLOSpaperTemporal19DegsMosaic'
visualizedMaxEcc = -8.5;  % Fig panel A with 'PLOSpaperTemporal10DegsMosaic'
visualizedPatchWithinMosaic =  [visualizedMaxEcc-3.0-0.1  visualizedMaxEcc-0.1  -0.3 0.3];
%visualizedPatchWithinMosaic =  [visualizedMaxEcc-3.0-1.4  visualizedMaxEcc-1.4  -0.3 0.3];
%visualizedPatchWithinMosaic =  [visualizedMaxEcc-3.0+0.1  visualizedMaxEcc+0.1  -0.3 0.3];


% Determine spatial extent to be visualized based on minConeWeight
%minConeWeightVisualized = mRGCMosaic.sensitivityAtPointOfOverlapFromGauthierRFmappingExperiment

% Fig panel D
minConeWeightVisualized =  mRGCMosaic.sensitivityAtPointOfOverlap; % default

%  Fig panels A, B, & C
minConeWeightVisualized = mRGCMosaic.minRFcenterConeWeightIncludedToMatchFigure4OfFieldEtAl2010

%minConeWeightVisualized = mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections


visualizeSpatialCompactnessSpectralPurityHistograms = ~true;

% Visualize patches (use this to also visualize intermediate stages of connectivity)
visualizeMosaicsPatches = ~true;

% Visualize intermediate stages of connectivity
visualizeIntermediateConnectivityStage = ~true;
if (visualizeIntermediateConnectivityStage)
    visualizeMosaicsPatches = true;
end
visualizeSourceLatticeInsteadOfConnectedRFcenters = ~true;
theVisualizedIntermediateConnectivityStage = 2;
theVisualizedIntermediateConnectivityStage = []; 


% Visualize patches at different eccentricities along the horizontal raphe
visualizeRFoverlapWithConeInputs = ~true;

% Visualize 4 deg wide patches at different eccentricities along the horizontal raphe
% Color-code each according each RGC according to the # of cones pooled within its RF center
visualizeMosaicBandAlongRaphe = ~true;

% Color-code each RGC according to the uniformity of the cone input types in its RF center
visualizeSpectralUniformity = ~true;

% Visualize separately each of the #center cones band
visualizeRFcenterConeBands = ~true;

% Params for different MOSAIC-VISUALIZATION actiions
pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1)

switch (round(pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1)))
    case num2cell([0 -1 -2])
        xo = -1.8;
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.8, ...
            'halfHeight', 0.6, ...
            'visualizedWidth', 1.25/3, ...
            'visualizedHeight', 0.8/3, ...
            'tickIncrementDegs', 0.2, ...
            'maxNumberOfConesOutsideContour', 0 ...
            );

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 1.5, ...
            'rapheBandHeight', 1.5, ...
            'minConesNum', 1, ...
            'maxConesNum', 10, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', [0 -1.5 -2.0], ...
            'rapheYo', [0  0.0 -2.0], ...
            'panelFormat', '1x1 full width medium height figure', ...
            'includeHistogramInsets', true);

        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 5, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 15, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', [0], ...
            'rapheYo', [0], ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 7, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 25, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', 0, ...
            'rapheYo', 0, ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{1} = [1];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{2} = [2];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{3} = [3];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{4} = [4];

    case num2cell([-3 -4])
        xo = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1);
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.8, ...
            'halfHeight', 0.6, ...
            'visualizedWidth', 1.25/3, ...
            'visualizedHeight', 0.8/3, ...
            'tickIncrementDegs', 0.2, ...
            'maxNumberOfConesOutsideContour', 0 ...
            );

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 2.2, ...
            'rapheBandHeight', 2.2, ...
            'minConesNum', 1, ...
            'maxConesNum', 4, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', xo, ...
            'rapheYo', [0 0  0 0 0], ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{1} = [1];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{2} = [2];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{3} = [3];

    case num2cell([-6 -7 -10])
        xo = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1);
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.8, ...
            'halfHeight', 0.6, ...
            'visualizedWidth', 1.25/3, ...
            'visualizedHeight', 0.8/3, ...
            'tickIncrementDegs', 0.2, ...
            'maxNumberOfConesOutsideContour', 0 ...
            );

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 4, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 15, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', [-6], ...
            'rapheYo', [0 0 0], ...
            'panelFormat', '1x1 full width medium height figure');

        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 7, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 15, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', [-6], ...
            'rapheYo', [0 0  0 0 0], ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{1} = [1];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{2} = [2];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{3} = [3];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{4} = [4];

    case num2cell([-12 -13 -14])
        % Params for visualizeMosaicsPatches
        xo = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs(1);
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.4, ...
            'halfHeight', 0.2, ...
            'visualizedWidth', 0.4, ...
            'visualizedHeight', 0.2, ...
            'tickIncrementDegs', 0.1 ...
            );

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 4, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 25, ...
            'maxNumberOfConesOutsideContour', 1, ...
            'rapheXo', [-6 -9 -12 -15 -18], ...
            'rapheYo', [0   0   0   0   0], ...
            'panelFormat', '1x1 full width medium height figure');

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();...
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{1} = [1];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{2} = [2];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{3} = [3];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{4} = [4];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{5} = [5];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{6} = [6];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{7} = [7];
        visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{8} = [8];

    case num2cell([-19 -20])
        % Params for visualizeMosaicsPatches
        xo = -12;
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.8, ...
            'halfHeight', 0.6, ...
            'visualizedWidth', 1.25/3, ...
            'visualizedHeight', 0.8/3, ...
            'tickIncrementDegs', 0.2, ...
            'maxNumberOfConesOutsideContour', 0 ...
            );

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 6, ...
            'rapheBandHeight', 3, ...
            'minConesNum', 1, ...
            'maxConesNum', 25, ...
            'rapheXo', -8:-5:-31, ...
            'rapheYo', (-8:-5:-31)*0, ...
            'panelFormat', '1x1 full width medium height figure');

        % Params for visualizeMosaicBandAlongRaphe
        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 4, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 25, ...
            'maxNumberOfConesOutsideContour', 2, ...
            'rapheXo', -20, ...
            'rapheYo', 0, ...
            'panelFormat', '1x1 standard figure');

        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 7, ...
            'rapheBandHeight', 2, ...
            'minConesNum', 1, ...
            'maxConesNum', 45, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', [-26 -19 -12]-1, ...
            'rapheYo', [0 0  0 0 0], ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();...
        for iConesNumInRFcenter = 1:10
            visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{iConesNumInRFcenter} = [iConesNumInRFcenter];
        end

     case num2cell([-25 -29 -32])
        % Params for visualizeMosaicsPatches
        xo = -25;
        visualizeMosaicsPatchesParamsStruct = struct(...
            'xo', xo, ...
            'yo', xo*0, ...
            'halfWidth', 0.8, ...
            'halfHeight', 0.6, ...
            'visualizedWidth', 1.25/3, ...
            'visualizedHeight', 0.8/3, ...
            'tickIncrementDegs', 0.2, ...
            'maxNumberOfConesOutsideContour', 0 ...
            );

        visualizeMosaicBandAlongRapheParamsStruct = struct(...
            'rapheBandWidth', 3, ...
            'rapheBandHeight', 3, ...
            'minConesNum', 1, ...
            'maxConesNum', 45, ...
            'maxNumberOfConesOutsideContour', 0, ...
            'rapheXo', -25, ...
            'rapheYo', 0, ...
            'panelFormat', '1x1 giant square mosaic', ...
            'includeHistogramInsets', false);

        % Params for visualizeRFcenterConeBands
        visualizeRFcenterConeBandsParamsStruct = struct();...
        for iConesNumInRFcenter = 1:10
            visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{iConesNumInRFcenter} = [iConesNumInRFcenter];
        end

    otherwise
        error('No visualization data for mosaicEcc(x): %f', mosaicEccDegs(1));
end



% GO !
if (generateConeRFpositionsLattice) || (generateMRGCRFpositionsLattice)

    if (generateConeRFpositionsLattice)
        latticeParamsStruct.neuronType = 'cones';
    else
        latticeParamsStruct.neuronType = 'midget ganglion cells';
    end

    if (1==2)
    retinalattice.generatePatch(latticeParamsStruct);
    end

    retinalattice.savePositionsAtIteration(...
        latticeParamsStruct.fovDegs, ...
        latticeParamsStruct.neuronType, ...
        latticeParamsStruct.whichEye);

    return;
end

for iTradeOff = 1:numel(tradeOffValues)
    % Tradeoff value
    theExaminedSpatialChromaticUniformityTradeoff = tradeOffValues(iTradeOff);

    % Update the visualizeMosaicBandAlongRapheParamsStruct
    visualizeMosaicBandAlongRapheParamsStruct.spatialChromaticUniformityTradeoff =  theExaminedSpatialChromaticUniformityTradeoff;

    if (generateNewMosaic)
        % Assemble struct with all cone-rf center connectivity params
    
        % Compose struct with params that control how cones get connected to the RGC RF centers
        rfCenterConnectivityParams = struct(...
            'optimizationCenter', optimizationCenter, ...
            'spatialChromaticUniformityTradeoff',  theExaminedSpatialChromaticUniformityTradeoff, ...
            'coneTypesToBeConnected', coneTypesIncludedInRFcenter, ...
            'maxNeighborNormDistance', maxNeighborNormDistance, ...
            'maxNeighborsNum', maxNeighborsNum, ...
            'localSpacingFromCurrentCentroids', localSpacingFromCurrentCentroids, ...
            'maxConeInputsPerRGCToConsiderTransferToNearbyRGCs', maxConeInputsPerRGCToConsiderTransferToNearbyRGCs, ...
            'maxConeInputsPerRGCToConsiderSwappingWithNearbyRGCs', maxConeInputsPerRGCToConsiderSwappingWithNearbyRGCs, ...
            'maxPassesNum', 10, ...
            'visualizeIntermediateStagesOfCenterConnectivityOptimization', ~true, ...
            'saveIntermediateStagesOfCenterConnectivityOptimization', true);
    
        % Generate the center-connected (no RF center ovelap) mRGCMosaic
        [theCenterConnectedMRGCMosaicFullFileName, ...
         theIntermediateConnectivityStageMetaDataFile, ...
         theCenterConnectedMRGCMosaicFileName] = RGCMosaicConstructor.compute.centerConnectedMosaic(...
            pStruct.whichEye, ...
            pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs, ...
            pStruct.rgcMosaicSurroundOptimization.mosaicSizeDegs, ...
            rfCenterConnectivityParams,  ...
            pStruct.sourceLatticeSizeDegs, ...
            'randomSeed', randomSeedForFreezingCmosaicConeAssignment, ...
            'customLMSconeDensities', pStruct.customLMSconeDensities);
    end %  if (generateNewMosaic)


    if (visualizeIntermediateConnectivityStage) || ...
       (visualizeMosaicsPatches) || (visualizeFullMosaic) || (visualizeSpatialCompactnessSpectralPurityHistograms) || (visualizeRFoverlapWithConeInputs) ||...
       (visualizeMosaicBandAlongRaphe) || (visualizeRFcenterConeBands) ||  (visualizeSpectralUniformity) || ...
       (generateRFcenterOverlappingMosaicFromCenterOnlyConnectedMosaic)

        % Retrieve filename from params
        centerConnectedParamsStruct.whichEye = pStruct.whichEye;
        centerConnectedParamsStruct.eccentricityDegs = pStruct.rgcMosaicSurroundOptimization.mosaicEccDegs;
        centerConnectedParamsStruct.sizeDegs = pStruct.rgcMosaicSurroundOptimization.mosaicSizeDegs;
        centerConnectedParamsStruct.spatialChromaticUniformityTradeoff =  theExaminedSpatialChromaticUniformityTradeoff;
        centerConnectedParamsStruct.customLMSconeDensities = pStruct.customLMSconeDensities;

        if (generateRFcenterOverlappingMosaicFromCenterOnlyConnectedMosaic)
            [theCenterConnectedMRGCMosaicFullFileName, ~, theCenterConnectedMRGCMosaicFileName] = ...
                RGCMosaicConstructor.filepathFor.exportedMosaicFileName(...
                    centerConnectedParamsStruct, 'center connected');

            fprintf('Loading center-connected MRGC mosaic from\n\t%s\n', theCenterConnectedMRGCMosaicFullFileName);
            % Load the center-connected mRGCMosaic
            load(theCenterConnectedMRGCMosaicFullFileName, 'theMRGCMosaic');

            % Generate filename for exported mosaic
            [theCenterConnectedMRGCMosaicFullFileName, ~, ...
                 theCenterConnectedMRGCMosaicFileName] = RGCMosaicConstructor.filepathFor.exportedMosaicFileName(...
                        centerConnectedParamsStruct, 'center connected with overlap');
            fprintf('Center-connected MRGC mosaic with RF center overlap will be exported to: \n\t%s\n', theCenterConnectedMRGCMosaicFullFileName);

            % Generate RF center overlap
            theMRGCMosaic.generateRFcenterOverlap(rfCenterOverlapParams, ...
                'visualizeGenerationOfOverlappingRFcenterWeights', visualizeGenerationOfOverlappingRFcenterWeights, ...
                'minConeWeightVisualized', exp(-4), ...
                'visualizeMinSensitivityForInclusion', false, ...
                'visualizeSensitivityAtPointOfOverlap', false, ...
                'visualizeGauthierSensitivityAtPointOfOverlap', false);


            % Export the RF center overlapping mosaic
            save(theCenterConnectedMRGCMosaicFullFileName, 'theMRGCMosaic', '-v7.3');
            fprintf('The center-connected MRGC mosaic with RF center overlap was saved to: \n\t%s\n', theCenterConnectedMRGCMosaicFullFileName);
        end
        
        % Generate filepath for center-connected mosaic
        if (pStruct.rgcMosaic.employRFCenterOverlappingMosaic)
            [theCenterConnectedMRGCMosaicFullFileName, ~, ...
             theCenterConnectedMRGCMosaicFileName] = RGCMosaicConstructor.filepathFor.exportedMosaicFileName(...
                    centerConnectedParamsStruct, 'center connected with overlap');
        else
            [theCenterConnectedMRGCMosaicFullFileName, ~, ...
             theCenterConnectedMRGCMosaicFileName] = RGCMosaicConstructor.filepathFor.exportedMosaicFileName(...
                    centerConnectedParamsStruct, 'center connected');
        end


        if (visualizeSpectralUniformity)
            RGCMosaicConstructor.visualize.spectralUniformityOfMosaic(...
                theCenterConnectedMRGCMosaicFullFileName, ...
                theCenterConnectedMRGCMosaicFileName, ...
                minConeWeightVisualized, ...
                visualizeMosaicBandAlongRapheParamsStruct);
        end

        if (visualizeMosaicBandAlongRaphe)
            RGCMosaicConstructor.visualize.spatialCompactnessOfMosaic(...
                theCenterConnectedMRGCMosaicFullFileName, ...
                theCenterConnectedMRGCMosaicFileName, ...
                minConeWeightVisualized, ...
                visualizeMosaicBandAlongRapheParamsStruct);
        end % if (visualizeMosaicBandAlongRaphe)

        if (visualizeMosaicsPatches)
            if (visualizeIntermediateConnectivityStage)
                 [~, theIntermediateConnectivityStageMetaDataFile] = RGCMosaicConstructor.filepathFor.exportedMosaicFileName(...
                        centerConnectedParamsStruct, 'center connected');
                load(theIntermediateConnectivityStageMetaDataFile, 'intermediateMetaDataStructs');
            else
                intermediateMetaDataStructs = [];
                theVisualizedIntermediateConnectivityStage = [];
            end

            RGCMosaicConstructor.visualize.mosaicPatchesDuringOptimizationAndCosts(...
                theCenterConnectedMRGCMosaicFullFileName, ...
                theCenterConnectedMRGCMosaicFileName, ...
                minConeWeightVisualized, ...
                visualizeMosaicsPatchesParamsStruct, ...
                intermediateMetaDataStructs, ...
                theVisualizedIntermediateConnectivityStage, ...
                visualizeSourceLatticeInsteadOfConnectedRFcenters, ...
                theExaminedSpatialChromaticUniformityTradeoff);
        end % if (visualizeMosaicPatches)

        if (visualizeFullMosaic)
            if (~isempty(visualizedPatchWithinMosaic))
                RGCMosaicConstructor.visualize.fullMosaic(...
                    theCenterConnectedMRGCMosaicFullFileName, ...
                    theCenterConnectedMRGCMosaicFileName, ...
                    minConeWeightVisualized, ...
                    visualizeMosaicBandAlongRapheParamsStruct, ...
                    'identifyInputCones', identifyInputConesInFullMosaic, ...
                    'identifyPooledCones', identifyPooledConesInFullMosaic, ...
                    'domainVisualizationLimits', visualizedPatchWithinMosaic, ...
                    'domainVisualizationTicks', struct('x', -50:0.5:50, 'y', -50:0.5:50));

            else
                % All RGCs
                visualizeRGCsAroundPositionAndWithingPositionDegs = [];

                % Some RGCs within a target region
                %visualizedPositionDegs = mosaicEccDegs;
                %visualizeRGCsAroundPositionAndWithingPositionDegs = [visualizedPositionDegs 6.0 0.15]

                RGCMosaicConstructor.visualize.fullMosaic(...
                                theCenterConnectedMRGCMosaicFullFileName, ...
                                theCenterConnectedMRGCMosaicFileName, ...
                                minConeWeightVisualized, ...
                                visualizeMosaicBandAlongRapheParamsStruct, ...
                                'visualizeRGCsAroundPositionAndWithingPositionDegs', visualizeRGCsAroundPositionAndWithingPositionDegs);
            end
        end % visualizeFullMosaic
        
        if (visualizeSpatialCompactnessSpectralPurityHistograms)
            % Load the mosaic
            load(theCenterConnectedMRGCMosaicFullFileName, 'theMRGCMosaic');
            RGCMosaicConstructor.visualize.spectralUniformitySpectralCompactnessHistograms(theMRGCMosaic);
        end

        if (visualizeRFcenterConeBands)
            for iRange = 1:numel(visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange)
                % Reload the mosaic so we can crop it (to accelerate plotting)
                theImportedData = load(theCenterConnectedMRGCMosaicFullFileName, 'theMRGCMosaic');

                targetCenterConesNumRange = visualizeRFcenterConeBandsParamsStruct.conesNumInRFcenterRange{iRange};
                targetCenterConesNumRGCindices = theImportedData.theMRGCMosaic.indicesOfRGCsWithTargetCenterConesNumInRange(targetCenterConesNumRange);

                if (numel(targetCenterConesNumRGCindices)>0)
                    targetRGCRFpositions = theImportedData.theMRGCMosaic.rgcRFpositionsDegs(targetCenterConesNumRGCindices,:);
                    minXY = min(targetRGCRFpositions,[],1);
                    maxXY = max(targetRGCRFpositions,[],1);
                    extraDegsMargin = 0.5;
                    cropRegionCenter = 0.5*[minXY(1)+maxXY(1) minXY(2)+maxXY(2)];
                    cropRegionSize = [maxXY(1)-minXY(1)+2*extraDegsMargin maxXY(2)-minXY(2)+2*extraDegsMargin];

                    % Domain visualization limits and ticks
                    domainVisualizationLimits(1:2) = theImportedData.theMRGCMosaic.eccentricityDegs(1) + ...
                            theImportedData.theMRGCMosaic.sizeDegs(1)*[-0.5  0.5] + extraDegsMargin*[-1 1];
                    domainVisualizationLimits(3:4) = theImportedData.theMRGCMosaic.eccentricityDegs(2) + ...
                            theImportedData.theMRGCMosaic.sizeDegs(2)*[-0.5 0.5] + extraDegsMargin*[-1 1];
                    domainVisualizationTicks = struct('x', -50:1:50, 'y', -50:0.5:50);

                    % Crop it so as to included all the targetCenterConesNumRGCindices.
                    % This makes visualization faster
                    theCroppedMRGCMosaic = theImportedData.theMRGCMosaic.cropToSizeAtEccentricity(...
                                cropRegionSize, cropRegionCenter);
                    targetCenterConesNumRGCindices = theCroppedMRGCMosaic.indicesOfRGCsWithTargetCenterConesNumInRange(targetCenterConesNumRange);
                    clear 'theImportedData';
    
                    % Compute spatial and chromatic costs
                    [theSpatialCompactnessCosts, theSpectralUniformityCosts] = theCroppedMRGCMosaic.rfCenterSpatioChromaticCosts();
    
                    if (numel(targetCenterConesNumRange) == 1)
                        if (targetCenterConesNumRange(1) == 1)
                            plotTitle = sprintf('RF center: %d cone', targetCenterConesNumRange(1));
                        else
                            plotTitle = sprintf('RF center: %d cones', targetCenterConesNumRange(1));
                        end
                    else
                        plotTitle = sprintf('RF center: %d-%d cones', targetCenterConesNumRange(1), targetCenterConesNumRange(2));
                    end

                    hFig = figure(100+iRange); clf;
                    %ff = PublicationReadyPlotLib.figureComponents('1x1 narrow full height figure');
                    ff = PublicationReadyPlotLib.figureComponents('1x1 giant square mosaic');
                    theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);

                    theCroppedMRGCMosaic.visualize(...
                        'figureHandle', hFig, ...
                        'axesHandle', theAxes{1,1}, ...
                        'domainVisualizationLimits', domainVisualizationLimits, ...
                        'domainVisualizationTicks', domainVisualizationTicks, ...
                        'visualizedRGCindices', targetCenterConesNumRGCindices, ...
                        'plottedRFoutlineFaceColor', [0.7 0.7 0.7], ...
                        'plottedRFoutlineFaceAlpha', 0.5, ...
                        'minConeWeightVisualized', minConeWeightVisualized, ...
                        'identifyInputCones', false, ...
                        'identifyPooledCones', false, ...
                        'centerSubregionContourSamples', 20, ...
                        'plottedRFoutlineLineWidth', 1.0, ...
                        'plotTitle', sprintf('%s (mosaic \\chi = %2.3f, \\lambda = %2.3f)', plotTitle, mean(theSpatialCompactnessCosts, 'omitnan'), mean(theSpectralUniformityCosts, 'omitnan')));
                end % if (numel(targetCenterConesNumRGCindices)>0)
            end % iRange
        end % if (visualizeRFcenterConeBands)


        if (visualizeRFoverlapWithConeInputs)
            while(1)
                visualizeMosaicRFoverlapParamsStruct.xo = input('Enter visualized region xo: ');
                visualizeMosaicRFoverlapParamsStruct.yo = input('Enter visualized region yo: ');
                visualizeMosaicRFoverlapParamsStruct.width = input('Enter visualized region width: ');
                visualizeMosaicRFoverlapParamsStruct.height = input('Enter visualized region height: ');
                visualizeMosaicRFoverlapParamsStruct.minConeWeightVisualized = input('Enter minConeWeightVisualized: ')
                visualizeMosaicRFoverlapParamsStruct

            for iXo = 1:numel(visualizeMosaicRFoverlapParamsStruct.xo)
                bandWidth = visualizeMosaicRFoverlapParamsStruct.width;
                bandHeight = visualizeMosaicRFoverlapParamsStruct.height;

                bandXo = visualizeMosaicRFoverlapParamsStruct.xo(iXo);
                bandYo = visualizeMosaicRFoverlapParamsStruct.yo(iXo);

                hFig = figure(100); clf;
                ff = PublicationReadyPlotLib.figureComponents('1x1 standard figure');
                theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
                
                % Reload the mosaic so we can crop it (to accelerate plotting)
                theCenterConnectedMRGCMosaicFullFileName
                theImportedData = load(theCenterConnectedMRGCMosaicFullFileName, 'theMRGCMosaic');
                
                % Crop it
                theCroppedMRGCMosaic = theImportedData.theMRGCMosaic.cropToSizeAtEccentricity(...
                            [bandWidth bandHeight], [bandXo bandYo]);
                clear 'theImportedData';

                % Compute theSpatialCompactnessCosts, theSpectralUniformityCosts
                [theSpatialCompactnessCostsPatch, theSpectralUniformityCostsPatch] = theCroppedMRGCMosaic.rfCenterSpatioChromaticCosts();
              
                xyMin = min(theCroppedMRGCMosaic.rgcRFpositionsDegs,[],1);
                xyMax = max(theCroppedMRGCMosaic.rgcRFpositionsDegs,[],1);
                domainVisualizationLimits = [bandXo-bandWidth/2 bandXo+bandWidth/2 bandYo-bandHeight/2 bandYo+bandHeight/2];
                domainVisualizationTicks = struct('x', -50:1:50, 'y', -50:1:50);

                theCroppedMRGCMosaic.visualize(...
                    'figureHandle', hFig, ...
                    'axesHandle', theAxes{1,1}, ...
                    'domainVisualizationLimits', domainVisualizationLimits, ...
                    'domainVisualizationTicks', domainVisualizationTicks, ...
                    'plottedRFoutlineFaceAlpha', 0.5, ...
                    'minConeWeightVisualized', visualizeMosaicRFoverlapParamsStruct.minConeWeightVisualized, ...
                    'identifiedConeAperture', 'lightCollectingAreaCharacteristicDiameter', ...
                    'identifiedConeApertureThetaSamples', 32, ...
                    'identifyInputCones', ~true, ...
                    'identifyPooledCones', ~true, ...
                    'pooledConesLineWidth', [], ...
                    'centerSubregionContourSamples', 32, ...
                    'plottedRFoutlineLineWidth', 1.0, ...
                    'plotTitle', sprintf('mosaic Costs: \\chi = %2.3f, \\lambda = %2.3f', mean(theSpatialCompactnessCostsPatch), mean( theSpectralUniformityCostsPatch)));
                % Finalize figure using the Publication-Ready format
                ff.box = 'on';
                PublicationReadyPlotLib.applyFormat(theAxes{1,1},ff);
                
                % Export figure
                theRawFiguresDir = RGCMosaicConstructor.filepathFor.rawFigurePDFsDir();
                thePDFfileName = fullfile(theRawFiguresDir, strrep(theCenterConnectedMRGCMosaicFileName, '.mat', sprintf('_RapheBand_%2.1fDegs_%2.1fDegs.pdf',bandXo, bandYo) ));
                NicePlot.exportFigToPDF(thePDFfileName,hFig,  300);
            end % iXo
            end % while
            
        end % if (visualizeRFoverlapWithConeInputs)

    end % if (visualizeDifferentStagesOfCenterConnectivityAlgorithm) || (visualizeCenterConnectedMosaic) || (visualizeMosaicsPatches) || (visualizeFullMosaic)

end % for iTradeOff
