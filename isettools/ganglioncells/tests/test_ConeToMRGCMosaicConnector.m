function test_ConeToMRGCMosaicConnector()

    sourceLatticeSizeDegs = 60;
    customDegsToMMsConversionFunction = @(x)RGCmodels.Watson.convert.rhoDegsToMMs(x);
    customMMsToDegsConversionFunction = @(x)RGCmodels.Watson.convert.rhoMMsToDegs(x);

    % Generate the input cone mosaic (the source)
    eccDegs = [-4 0]; 
    sizeDegs = 0.5+(max(abs(eccDegs))+1)*0.4*[0.5 0.25];
    whichEye = 'right eye';

    theOpticsParams = struct(...
        'positionDegs', eccDegs, ... 
        'ZernikeDataBase', 'Artal2012', ...
        'examinedSubjectRankOrder', 10, ...
        'refractiveErrorDiopters', 0.0, ... 
        'analyzedEye', whichEye, ...
        'subjectRankingEye', 'right eye', ...
        'pupilDiameterMM', 3.0, ...
        'psfUpsampleFactor', 1, ...
        'wavefrontSpatialSamples', 501 ...
        );

    % Set cone aperture modifiers
    % Use a Gaussian cone aperture with
    % sigma equal to 0.204 x inner segment diameter (cone diameter)
    sigmaGaussian = 0.204;  % From McMahon et al, 2000
    coneApertureModifiers = struct(...
            'smoothLocalVariations', true, ...
            'sigma',  sigmaGaussian, ...
            'shape', 'Gaussian');

    theInputConeMosaic = cMosaic(...
       'sourceLatticeSizeDegs', sourceLatticeSizeDegs, ...
       'eccentricityDegs', eccDegs, ...
       'sizeDegs', sizeDegs, ...
       'whichEye', whichEye, ...
       'coneDensities', [0.6 0.3 0.1], ...
       'overlappingConeFractionForElimination', 0.5, ...
       'rodIntrusionAdjustedConeAperture', true, ...
       'coneApertureModifiers', coneApertureModifiers, ...
       'customDegsToMMsConversionFunction', customDegsToMMsConversionFunction, ...
       'customMMsToDegsConversionFunction', customMMsToDegsConversionFunction);

    
    % Source lattice (i.e. cone mosaic lattice) meta data, here cone types
    % If the cone types are not passed in the metaData, the @coneToMidgetRGCConnector
    % will not use be able to bias toward cone-specific wiring in RGCs with
    % multiple inputs
    metaDataStruct.coneTypes = theInputConeMosaic.coneTypes;
    metaDataStruct.coneTypeIDs = [theInputConeMosaic.LCONE_ID theInputConeMosaic.MCONE_ID theInputConeMosaic.SCONE_ID];
    metaDataStruct.coneColors = [theInputConeMosaic.lConeColor; theInputConeMosaic.mConeColor; theInputConeMosaic.sConeColor];

    surroundRadiusDegs = estimateRsAtMaxEccentricity(theInputConeMosaic, theOpticsParams);
    metaDataStruct.midgetRGCSurroundRadiusMicronsAtMaxEccentricityGivenOptics = ...
        1e3 * customDegsToMMsConversionFunction(surroundRadiusDegs);

    % Source lattice (i.e. cone mosaic lattice) struct
    sourceLatticeStruct = struct(...
        'name', 'cone RFs', ...
        'DegsToMMsConversionFunction', customDegsToMMsConversionFunction, ...
        'MMsToDegsConversionFunction', customMMsToDegsConversionFunction, ...
        'RFpositionsMicrons', theInputConeMosaic.coneRFpositionsMicrons, ...
        'metaData', metaDataStruct ...
        ); 
    

    % Import mRGC RF positions (destination) 
    mRGCRFposMicrons = retinalattice.import.finalMRGCPositions(...
                 sourceLatticeSizeDegs, ...
                 mean(sourceLatticeStruct.RFpositionsMicrons,1), ... 
                 max(max(sourceLatticeStruct.RFpositionsMicrons,[], 1)-min(sourceLatticeStruct.RFpositionsMicrons,[], 1)), ...
                 theInputConeMosaic.whichEye, ...
                 customDegsToMMsConversionFunction);


    % Destination lattice struct
    destinationLatticeStruct = struct(...
        'name', 'mRGC RFs', ...
        'DegsToMMsConversionFunction', customDegsToMMsConversionFunction, ...
        'MMsToDegsConversionFunction', customMMsToDegsConversionFunction, ...
        'RFpositionsMicrons', mRGCRFposMicrons ...
        );

    % Instantiate a coneToMidgetRGCConnector that will only connect
    % L and M-cones to RGCs
    lmConeIndices = [...
        theInputConeMosaic.lConeIndices(:); ...
        theInputConeMosaic.mConeIndices(:)];

    % [0: minimize chromatic variance 1: minimize spatial variance]
    chromaticSpatialVarianceTradeoff = 1.0;

    theMidgetRGCconnectorOBJ = coneToMidgetRGCConnector(...
        sourceLatticeStruct, destinationLatticeStruct, ...
        'optimizationCenter', 'origin', ...
        'chromaticSpatialVarianceTradeoff',chromaticSpatialVarianceTradeoff, ...
        'coneIndicesToBeConnected', lmConeIndices, ...
        'visualizeConnectivityAtIntermediateStages', true, ...
        'generateProgressVideo', ~true);
  

    figNo = 999;
    hFig = theMidgetRGCconnectorOBJ.visualizeCurrentConnectivity(figNo);
    pdfFileName = sprintf('ConnectedMosaicEccDegs_%2.1f_%2.1f_ChromaticSpatialVariance_%2.2f.pdf',...
        eccDegs(1), eccDegs(2), chromaticSpatialVarianceTradeoff);
    NicePlot.exportFigToPDF(pdfFileName,hFig, 300);
end


function surroundRadiusDegs = estimateRsAtMaxEccentricity(theConeMosaic, theOpticsParams)

    psfWavelengthSupport = [];
    thePSFData = RetinaToVisualFieldTransformer.computeVlambdaWeightedPSF(theOpticsParams, theConeMosaic, psfWavelengthSupport);

    % Estimate mean anatomical cone aperture from the 6 closest (to the
    % cone with the max position.
    [~,idx] = MosaicConnector.pdist2(theConeMosaic.coneRFpositionsDegs, [], ...
        'fromPosition', 'maxAbsPosition', ...
        'smallest', 6 ...
        );

    meanConeApertureDegs = mean(theConeMosaic.coneApertureDiametersDegs(idx));
    
    anatomicalConeCharacteristicRadiusDegs = theConeMosaic.coneApertureToConeCharacteristicRadiusConversionFactor  * meanConeApertureDegs;
    simulateCronerKaplanEstimation = false;
    hFig = figure(1); clf;
    visualConeCharacteristicRadiusDegs = RetinaToVisualFieldTransformer.analyzeVisuallyProjectedConeAperture(...
                 anatomicalConeCharacteristicRadiusDegs, thePSFData, simulateCronerKaplanEstimation, hFig);

    RsRcRatio = 6.7;
    characteristicRadiiLimit = 2;
    surroundRadiusDegs = characteristicRadiiLimit * (visualConeCharacteristicRadiusDegs*RsRcRatio);

end
