function test_ConeToMRGCMosaicConnector()

    sourceLatticeSizeDegs = 60;
    customDegsToMMsConversionFunction = @(x)RGCmodels.Watson.convert.rhoDegsToMMs(x);
    customMMsToDegsConversionFunction = @(x)RGCmodels.Watson.convert.rhoMMsToDegs(x);


    % Generate the input cone mosaic (the source)
    eccDegs = [-4 0]; 
    sizeDegs = 0.5+(max(abs(eccDegs))+1)*0.4*[0.5 0.25];

    eccDegs = [2 0]; 
    sizeDegs = 1.4*[1 0.7];

    whichEye = 'right eye';

    theOpticsParams = struct(...
        'positionDegs', eccDegs, ... 
        'ZernikeDataBase', 'Artal2012', ...
        'examinedSubjectRankOrder', 10, ...
        'refractiveErrorDiopters', 0.0, ... 
        'analyzedEye', 'right eye', ...
        'subjectRankingEye', whichEye, ...
        'pupilDiameterMM', 3.0, ...
        'wavefrontSpatialSamples', 801 ...
        );

    % Set cone aperture modifiers
    % Use a Gaussian cone aperture with
    % sigma equal to 0.204 x inner segment diameter (cone diameter)
    sigmaGaussian = 0.204;  % From McMahon et al, 2000
    coneApertureModifiers = struct(...
            'smoothLocalVariations', true, ...
            'sigma',  sigmaGaussian, ...
            'shape', 'Gaussian');

    theInputConeMosaic = cMosaic(...
       'sourceLatticeSizeDegs', sourceLatticeSizeDegs, ...
       'eccentricityDegs', eccDegs, ...
       'sizeDegs', sizeDegs, ...
       'whichEye', whichEye, ...
       'coneDensities', [0.6 0.3 0.1], ...
       'overlappingConeFractionForElimination', 0.5, ...
       'rodIntrusionAdjustedConeAperture', true, ...
       'coneApertureModifiers', coneApertureModifiers);

    
    % Source lattice (i.e. cone mosaic lattice) meta data, here cone types
    % If the cone types are not passed in the metaData, the @coneToMidgetRGCConnector
    % will not use be able to bias toward cone-specific wiring in RGCs with
    % multiple inputs
    metaDataStruct.coneTypes = theInputConeMosaic.coneTypes;
    metaDataStruct.coneTypeIDs = [theInputConeMosaic.LCONE_ID theInputConeMosaic.MCONE_ID theInputConeMosaic.SCONE_ID];
    metaDataStruct.coneColors = [theInputConeMosaic.lConeColor; theInputConeMosaic.mConeColor; theInputConeMosaic.sConeColor];


    surroundRadiusDegs = estimateRsAtMaxEccentricity(theInputConeMosaic, theOpticsParams);
    metaDataStruct.midgetRGCSurroundRadiusMicronsAtMaxEccentricityGivenOptics = ...
        1e3 * customDegsToMMsConversionFunction(surroundRadiusDegs);


    % Source lattice (i.e. cone mosaic lattice) struct
    sourceLatticeStruct = struct(...
        'name', 'cone RFs', ...
        'DegsToMMsConversionFunction', customDegsToMMsConversionFunction, ...
        'MMsToDegsConversionFunction', customMMsToDegsConversionFunction, ...
        'RFpositionsMicrons', theInputConeMosaic.coneRFpositionsMicrons, ...
        'metaData', metaDataStruct ...
        ); 
    

    % Import mRGC RF positions (destination) 
    mRGCRFposMicrons = retinalattice.import.finalMRGCPositions(...
                 sourceLatticeSizeDegs, ...
                 mean(sourceLatticeStruct.RFpositionsMicrons,1), ... 
                 max(max(sourceLatticeStruct.RFpositionsMicrons,[], 1)-min(sourceLatticeStruct.RFpositionsMicrons,[], 1)), ...
                 theInputConeMosaic.whichEye, ...
                 customDegsToMMsConversionFunction);


    % Destination lattice struct
    destinationLatticeStruct = struct(...
        'name', 'mRGC RFs', ...
        'DegsToMMsConversionFunction', customDegsToMMsConversionFunction, ...
        'MMsToDegsConversionFunction', customMMsToDegsConversionFunction, ...
        'RFpositionsMicrons', mRGCRFposMicrons ...
        );

    % Instantiate a coneToMidgetRGCConnector that will only connect
    % L and M-cones to RGCs
    lmConeIndices = [...
        theInputConeMosaic.lConeIndices(:); ...
        theInputConeMosaic.mConeIndices(:)];

    chromaticSpatialVarianceTradeoff = 0.75;
    theMidgetRGCconnectorOBJ = coneToMidgetRGCConnector(...
        sourceLatticeStruct, destinationLatticeStruct, ...
        'optimizationCenter', 'origin', ...
        'chromaticSpatialVarianceTradeoff',chromaticSpatialVarianceTradeoff, ...
        'coneIndicesToBeConnected', lmConeIndices, ...
        'visualizeConnectivityAtIntermediateStages', true, ...
        'generateProgressVideo', ~true);
  

    figNo = 999;
    hFig = theMidgetRGCconnectorOBJ.visualizeCurrentConnectivity(figNo);
    pdfFileName = sprintf('ConnectedMosaicEccDegs_%2.1f_%2.1f_ChromaticSpatialVariance_%2.2f.pdf',...
        eccDegs(1), eccDegs(2), chromaticSpatialVarianceTradeoff);
    NicePlot.exportFigToPDF(pdfFileName,hFig, 300);
end


function surroundRadiusDegs = estimateRsAtMaxEccentricity(theConeMosaic, theOpticsParams)

    psfWavelengthSupport = [];
    thePSFData = RetinaToVisualFieldTransformer.computeVlambdaWeightedPSF(theOpticsParams, theConeMosaic, psfWavelengthSupport);

    % Sort cones according to their distance to theTargetPosition
    [~,maxEccConeIdx] = max(sum(theConeMosaic.coneRFpositionsDegs.^2,2));
    theTargetPositionDegs = theConeMosaic.coneRFpositionsDegs(maxEccConeIdx,:);
    coneDistancesFromTargetPosition = sqrt(sum(bsxfun(@minus, theConeMosaic.coneRFpositionsDegs, theTargetPositionDegs).^2,2));
    [~,idx] = sort(coneDistancesFromTargetPosition, 'ascend');
    
    % Estimate mean anatomical cone aperture from the 6 closest (to the target position) cones
    conesNum = numel(idx);
    conesNumToUse = min([conesNum 6]);
    meanConeApertureDegs = mean(theConeMosaic.coneApertureDiametersDegs(idx(1:conesNumToUse)));
    
    anatomicalConeCharacteristicRadiusDegs = theConeMosaic.coneApertureToConeCharacteristicRadiusConversionFactor  * meanConeApertureDegs;
    simulateCronerKaplanEstimation = false;
    hFig = figure(1); clf;
    visualConeCharacteristicRadiusDegs = RetinaToVisualFieldTransformer.analyzeVisuallyProjectedConeAperture(...
                 anatomicalConeCharacteristicRadiusDegs, thePSFData, simulateCronerKaplanEstimation, hFig);

    RsRcRatio = 6.7;
    characteristicRadiiLimit = 2;
    surroundRadiusDegs = characteristicRadiiLimit * (visualConeCharacteristicRadiusDegs*RsRcRatio);

end
