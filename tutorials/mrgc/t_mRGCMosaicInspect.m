function t_mRGCMosaicInspect(options)
% Visualize prebaked mRGCMosaics and the cone pooling maps of individual cells
%
% Description:
%    Demonstrates the following:
%    (i)   how to load a pre-baked midget RGC mosaic, 
%    (ii)  visualize the mosaic of RF centers,
%    (iii) visualize the PSF of the optics used to build the mosaic
%    (iv)  visualize the RF center and surround cone pooling maps of
%          individual cells within the mosaic
%
%  This is set up with key/value pairs that demonstate how to select different
%  options. Different choices are illustrated in the examples
%  in the source code.
%
% Optional key/value pairs
%    See source code arguments block for a list of key/value pairs.

% History:
%    07/28/25  NPC  Wrote it.

% Examples:
%{
    t_mRGCMosaicInspect();

    % Visualize a mosaic synthesized at 10 deg along the temporal meridian
    t_mRGCMosaicInspect(...
        'rgcMosaicName', 'PLOSpaperTemporal10DegsMosaic', ...
        'opticsSubjectName', 'PLOSpaperDefaultSubject');

    % Visualize a mosaic synthesized at 4 deg along the temporal meridian
    t_mRGCMosaicInspect(...
        'rgcMosaicName', 'PLOSpaperTemporal4DegsMosaic', ...
        'opticsSubjectName', 'PLOSpaperDefaultSubject');

    % Visualize a mosaic synthesized at 2 deg along the temporal meridian
    t_mRGCMosaicInspect(...
        'rgcMosaicName', 'PLOSpaperTemporal2DegsMosaic', ...
        'opticsSubjectName', 'PLOSpaperDefaultSubject');

    % Visualize a mosaic synthesized at 10 deg along the temporal meridian
    % and the cone pooling maps of RGC with index 90
    t_mRGCMosaicInspect(...
        'rgcMosaicName', 'PLOSpaperTemporal10DegsMosaic', ...
        'opticsSubjectName', 'PLOSpaperDefaultSubject', ...
        'targetRGCindexForVisualizingConePoolingMaps', 490);

    % Visualize a mosaic synthesized at 4 deg along the temporal meridian
    % and the cone pooling maps of RGCs along the horizontal meridian
    t_mRGCMosaicInspect(...
        'rgcMosaicName', 'PLOSpaperTemporal10DegsMosaic', ...
        'opticsSubjectName', 'PLOSpaperDefaultSubject', ...
        'generateVideoOfRFpoolingMapsAlongHorizontalMeridian', true);

%}


arguments

    % ---- Mosaic specifiers for selecting a prebaked mRGC mosaic ---

    % See RGCMosaicConstructor.helper.utils.initializeRGCMosaicGenerationParameters
    % for what is available and to add new mosaics
    options.rgcMosaicName (1,:) char = 'PLOSpaperNasal2DegsTinyMosaic';


    % ---- Which species to employ ----
    % Choose between {'macaque', 'human'}. If 'macaque' is chosen, the input
    % cone mosaic has a 1:1 L/M cone ratio.
    options.coneMosaicSpecies  (1,:) char {mustBeMember(options.coneMosaicSpecies,{'human','macaque'})} = 'human';

     % ----- Which subject optics to employ -----
    options.opticsSubjectName (1,:) ...
        char ...
        {...
        mustBeMember(options.opticsSubjectName, ...
            { ...
            'PLOSpaperDefaultSubject' ...
            'PLOSpaperSecondSubject' ...
            'VSS2024TalkFirstSubject' ...
            'VSS2024TalkSecondSubject' ...
            'PLOSpaperStrehlRatio_0.87' ...
            'PLOSpaperStrehlRatio_0.72' ...
            'PLOSpaperStrehlRatio_0.59' ...
            'PLOSpaperStrehlRatio_0.60' ...
            'PLOSpaperStrehlRatio_0.27' ...
            'PLOSpaperStrehlRatio_0.23' ...
            'PLOSpaperStrehlRatio_0.21' ...
            'PLOSpaperStrehlRatio_0.19' ...
            'PLOSpaperStrehlRatio_0.09' ...
            } ...
            ) ...
        } ...
        = 'PLOSpaperSecondSubject';


    % ------ targetVisualSTF options ----
    % Options are : {'default', 'x1.3 RsRcRatio'}
    % These are with respect to the macaque data of the Croner & Kaplan '95 study
    % 'default': target the mean Rs/Rc, and the mean Ks/Kc (Rs/Rc)^2
    % See RGCMosaicConstructor.helper.surroundPoolingOptimizerEngine.generateTargetVisualSTFmodifiersStruct
    % for all existing options
    options.targetVisualSTFdescriptor (1,:) char = 'default';


    % ------ Visualization options ----
    % Visualize cone pooling maps for a target RGC
    options.targetRGCindexForVisualizingConePoolingMaps (1,:) double = [];

    % Whether to generate a video of RFpooling maps along the horizontal meridian
    options.generateVideoOfRFpoolingMapsAlongHorizontalMeridian (1,1) logical = false;

    % Whether to close previously open figures
    options.closePreviouslyOpenFigures (1,1) logical = true;
end


% Set flags from key/value pairs

% Mosaic specifiers for selecting a prebaked mRGC mosaic
rgcMosaicName = options.rgcMosaicName;
coneMosaicSpecies = options.coneMosaicSpecies;
opticsSubjectName = options.opticsSubjectName;
targetVisualSTFdescriptor = options.targetVisualSTFdescriptor;

% Visualization options
targetRGCindexForVisualizingConePoolingMaps = options.targetRGCindexForVisualizingConePoolingMaps;
generateVideoOfRFpoolingMapsAlongHorizontalMeridian = options.generateVideoOfRFpoolingMapsAlongHorizontalMeridian;


% Close previously open figures
closePreviouslyOpenFigures = options.closePreviouslyOpenFigures;
if (closePreviouslyOpenFigures)
    % Close any stray figs
    close all;
end


% Load the mRGCmosaic specified by the passed parameters:
%   coneMosaicSpecies, opticsSubjectName, rgcMosaicName, targetVisualSTFdescriptor
% and generate the optics that were used to synthesize the mosaic
[theMRGCmosaic, ~, thePSFatTheMosaicEccentricity] = mRGCMosaic.loadPrebakedMosaic(...
        coneMosaicSpecies, opticsSubjectName, rgcMosaicName, targetVisualSTFdescriptor, ...
        'computeTheMosaicOptics', true);


% Subdirectory for exporting the generated PDFs
exportVisualizationPDFdirectory = 'mosaicVisualizationPDFs';


% mRGC mosaic visualization limits and ticks (excluding the extent of the
% input cone mosaic)
visualizedWidthDegs = theMRGCmosaic.sizeDegs(1);
visualizedHeightDegs = theMRGCmosaic.sizeDegs(2);
domainVisualizationLimits(1:2) = theMRGCmosaic.eccentricityDegs(1) + 0.5 * visualizedWidthDegs * [-1 1];
domainVisualizationLimits(3:4) = theMRGCmosaic.eccentricityDegs(2) + 0.5 * visualizedHeightDegs * [-1 1];
domainVisualizationTicks = struct(...
    'x', theMRGCmosaic.eccentricityDegs(1) + 0.5 * visualizedWidthDegs * [-1 -0.5 0 0.5 1], ...
    'y', theMRGCmosaic.eccentricityDegs(2) + 0.5 * visualizedHeightDegs * [-1 -0.5 0 0.5 1]);


% Visualize RF centers using the spatial extent of cones whose RF center pooling weights
% are >= mRGCMosaic.sensitivityAtPointOfOverlap;
% This representation is like the representation used in visualizing 
% mosaics of RGCs in typical in-vitro experiments (e.g. by the Chichilnisky lab)
minCenterConeWeight = mRGCMosaic.sensitivityAtPointOfOverlap;

% Get ready for publication-quality visualization
ff = PublicationReadyPlotLib.figureComponents('1x1 giant rectangular-wide mosaic');

% Plot the mosaic of mRGC RF centers only
hFig = figure(1); clf;
theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
ax = theAxes{1,1};

theMRGCmosaic.visualize(...
    'figureHandle', hFig, ...
    'axesHandle', ax, ...
    'identifyInputCones', false, ...
    'identifyPooledCones', false, ...
    'inputConesAlpha', 0.5, ...
    'identifiedConeAperture', 'lightCollectingArea4sigma', ...
    'identifiedConeApertureThetaSamples', 16, ...
    'minConeWeightVisualized', minCenterConeWeight, ...
    'centerSubregionContourSamples', 32, ...
    'domainVisualizationLimits', domainVisualizationLimits, ...
    'domainVisualizationTicks', domainVisualizationTicks, ...
    'plotTitle', sprintf('min center weight visualized: %2.3f', minCenterConeWeight), ...
    'withFigureFormat', ff, ...
    'visualizationPDFfileName', sprintf('fullMRGCmosaicMinCenterConeWeight_%2.3f', minCenterConeWeight), ...
    'exportVisualizationPDF', true, ...
    'exportVisualizationPDFdirectory', exportVisualizationPDFdirectory);


% Visualize RF centers using the spatial extent of cones whose RF center pooling weights
% are > mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections
% (basically all cones connected to each RF center). This is useful for
% visualizing the degree of RF center overlap
minCenterConeWeight = mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections;

hFig = figure(2); clf;
theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
ax = theAxes{1,1};

theMRGCmosaic.visualize(...
    'figureHandle', hFig, ...
    'axesHandle', ax, ...
    'identifyInputCones', false, ...
    'identifyPooledCones', false, ...
    'inputConesAlpha', 0.5, ...
    'identifiedConeAperture', 'lightCollectingArea4sigma', ...
    'identifiedConeApertureThetaSamples', 16, ...
    'minConeWeightVisualized', minCenterConeWeight, ...
    'centerSubregionContourSamples', 32, ...
    'domainVisualizationLimits', domainVisualizationLimits, ...
    'domainVisualizationTicks', domainVisualizationTicks, ...
    'plotTitle', sprintf('min center weight visualized: %2.3f', minCenterConeWeight), ...
    'withFigureFormat', ff, ...
    'visualizationPDFfileName', sprintf('fullMRGCmosaicMinCenterConeWeight_%2.3f', minCenterConeWeight), ...
    'exportVisualizationPDF', true, ...
    'exportVisualizationPDFdirectory', exportVisualizationPDFdirectory);



% We will plot a smaller region of the mRGC mosaic 
narrowDomainVisualizationLimits(1:2) = theMRGCmosaic.eccentricityDegs(1) + [-0.5 0.5];
narrowDomainVisualizationLimits(3:4) = theMRGCmosaic.eccentricityDegs(2) + [-0.25 0.25];
narrowDomainVisualizationTicks = struct(...
    'x', -30:0.2:0, ...
    'y', -10:0.2:10);

% Generate a PSF visualization data struct (containing the vLambda-weighted PSF) for
% visualization purposes
PSFvisualizationOffset = theMRGCmosaic.eccentricityDegs - [mean(narrowDomainVisualizationLimits(1:2)) mean(narrowDomainVisualizationLimits(3:4))];
visualizedPSFData.data = RGCMosaicAnalyzer.compute.vLambdaWeightedPSF(thePSFatTheMosaicEccentricity);
visualizedPSFData.supportXdegs = thePSFatTheMosaicEccentricity.supportX/60 - PSFvisualizationOffset(1);
visualizedPSFData.supportYdegs = thePSFatTheMosaicEccentricity.supportY/60 - PSFvisualizationOffset(2);

% Visualize the mosaic, identifying input cones and 
% superimposing the PSF of the optics at the mosaic's eccentricity
hFig = figure(3); clf;
theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
ax = theAxes{1,1};
minCenterConeWeight = mRGCMosaic.sensitivityAtPointOfOverlap;
theMRGCmosaic.visualize(...
    'figureHandle', hFig, ...
    'axesHandle', ax, ...
    'identifyInputCones', true, ...
    'identifyPooledCones', ~true, ...
    'inputConesAlpha', 0.5, ...
    'identifiedConeAperture', 'lightCollectingArea4sigma', ...
    'identifiedConeApertureThetaSamples', 16, ...
    'minConeWeightVisualized', minCenterConeWeight, ...
    'centerSubregionContourSamples', 32, ...
    'domainVisualizationLimits', narrowDomainVisualizationLimits, ...
    'domainVisualizationTicks', narrowDomainVisualizationTicks, ...
    'withSuperimposedPSF', visualizedPSFData, ...
    'plotTitle', sprintf('min center weight visualized: %2.3f', minCenterConeWeight), ...
    'withFigureFormat', ff, ...
    'visualizationPDFfileName', sprintf('zoomedInMRGCmosaicWithPSFminCenterConeWeight_%2.3f', minCenterConeWeight), ...
    'exportVisualizationPDF', true, ...
    'exportVisualizationPDFdirectory', exportVisualizationPDFdirectory);


% Same as in figure (3), but now RF centers are visualized using the spatial extent of 
% cones whose RF center pooling weights
% are > mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections
% (basically all cones connected to each RF center). This is useful for
% visualizing the degree of RF center overlap
minCenterConeWeight = mRGCMosaic.minSensitivityForInclusionOfDivergentConeConnections;


hFig = figure(4); clf;
theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
ax = theAxes{1,1};

theMRGCmosaic.visualize(...
    'figureHandle', hFig, ...
    'axesHandle', ax, ...
    'identifyInputCones', true, ...
    'identifyPooledCones', ~true, ...
    'inputConesAlpha', 0.5, ...
    'identifiedConeAperture', 'lightCollectingArea4sigma', ...
    'identifiedConeApertureThetaSamples', 16, ...
    'minConeWeightVisualized', minCenterConeWeight, ...
    'centerSubregionContourSamples', 32, ...
    'domainVisualizationLimits', narrowDomainVisualizationLimits, ...
    'domainVisualizationTicks', narrowDomainVisualizationTicks, ...
    'withSuperimposedPSF', visualizedPSFData, ...
    'plotTitle', sprintf('min center weight visualized: %2.3f', minCenterConeWeight), ...
    'withFigureFormat', ff, ...
    'visualizationPDFfileName', sprintf('zoomedInMRGCmosaicWithPSFminCenterConeWeight_%2.3f', minCenterConeWeight), ...
    'exportVisualizationPDF', true, ...
    'exportVisualizationPDFdirectory', exportVisualizationPDFdirectory);



if (~isempty(targetRGCindexForVisualizingConePoolingMaps))
    % Visualize the mRGC mosaic and its entire input cone mosaic, 
    % identifying the location of the targetRGCindexForVisualizingConePoolingMaps
    
    hFig = figure(5); clf;
    theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
    ax = theAxes{1,1};    
    
    narrowDomainVisualizationLimits(1:2) = theMRGCmosaic.rgcRFpositionsDegs(targetRGCindexForVisualizingConePoolingMaps,1) + [-0.5 0.5];
    narrowDomainVisualizationLimits(3:4) = theMRGCmosaic.rgcRFpositionsDegs(targetRGCindexForVisualizingConePoolingMaps,2) + [-0.5 0.5];
    
    % Ticks every 1 deg
    narrowDomainVisualizationTicks = struct(...
        'x', -30:1:30, ...
        'y', -30:1:30);
    
    minCenterConeWeight = mRGCMosaic.sensitivityAtPointOfOverlap;


    theMRGCmosaic.visualize(...
        'figureHandle', hFig, ...
        'axesHandle', ax, ...
        'identifyInputCones', true, ...
        'identifyPooledCones', true, ...
        'inputConesAlpha', 0.5, ...
        'identifiedConeAperture', 'lightCollectingArea4sigma', ...
        'identifiedConeApertureThetaSamples', 16, ...
        'minConeWeightVisualized', minCenterConeWeight, ...
        'centerSubregionContourSamples', 32, ...
        'labelRGCsWithIndices', targetRGCindexForVisualizingConePoolingMaps, ...
        'labeledRGCsLineWidth', 2, ...
        'domainVisualizationLimits', narrowDomainVisualizationLimits, ...
        'domainVisualizationTicks', narrowDomainVisualizationTicks, ...
        'plotTitle', sprintf('min center weight visualized: %2.3f (target RGC: %d)', minCenterConeWeight, targetRGCindexForVisualizingConePoolingMaps), ...
        'withFigureFormat', ff, ...
        'visualizationPDFfileName', sprintf('mRGCmosaicMinCenterConeWeightWithLabeledMRGC_%2.3f_targetRGC_%d', minCenterConeWeight, targetRGCindexForVisualizingConePoolingMaps), ...
        'exportVisualizationPDF', true, ...
        'exportVisualizationPNG', true, ...
        'exportVisualizationPDFdirectory', exportVisualizationPDFdirectory);


        % Plot the cone pooling RF map of the exemplar mRGC
        figNo = 1000; figPos = [1000 500];
    
        % Add a scale bar, 0.15 degs in size
        scaleBarDegs = 0.15;
    
        % Include surround cones whose pooling weights are >= 0.001
        minSurroundConeWeight = 0.001;
        
        theMRGCmosaic.visualizeCenterSurroundConePoolingMap(targetRGCindexForVisualizingConePoolingMaps, ...
                'minConeWeightForVisualizingRFcenterPooling', minCenterConeWeight, ...
                'minConeWeightForVisualizingRFsurroundPooling', minSurroundConeWeight, ...
                'minSurroundConeWeightRelativity', 'center', ...
                'withLineWeightingFunctions', false, ...
                'scaleBarDegs', scaleBarDegs, ...
                'doNotLabelScaleBar', true, ...
                'plotTitle', sprintf('scale bar: %2.2f degs', scaleBarDegs), ...
                'figNo', figNo, ...
                'figPos', figPos, ...
                'exportVisualizationPDF', true, ...
                'exportVisualizationPNG', true, ...
                'exportToFigurePDFsDirWithPDFFileName', sprintf('RFmap%d.pdf', targetRGCindexForVisualizingConePoolingMaps), ...
                'pdfExportSubDir', exportVisualizationPDFdirectory);

        % Plot the cone pooling RF map of the exemplar mRGC along with
        % line weighting functions of the center and of the surround cone pooling weights
        % along the horizontal and vertical axes
        theMRGCmosaic.visualizeCenterSurroundConePoolingMap(targetRGCindexForVisualizingConePoolingMaps, ...
                'minConeWeightForVisualizingRFcenterPooling', minCenterConeWeight, ...
                'minConeWeightForVisualizingRFsurroundPooling', minSurroundConeWeight, ...
                'minSurroundConeWeightRelativity', 'center', ...
                'withLineWeightingFunctions', true, ...
                'scaleBarDegs', scaleBarDegs, ...
                'doNotLabelScaleBar', true, ...
                'plotTitle', sprintf('scale bar: %2.2f degs', scaleBarDegs), ...
                'figNo', figNo+1, ...
                'figPos', figPos, ...
                'exportVisualizationPDF', true, ...
                'exportVisualizationPNG', true, ...
                'exportToFigurePDFsDirWithPDFFileName', sprintf('RFmap%dWithLineWeightingFunctions.pdf', targetRGCindexForVisualizingConePoolingMaps), ...
                'pdfExportSubDir', exportVisualizationPDFdirectory);

end % if (~isempty(targetRGCindexForVisualizingConePoolingMaps))

if (generateVideoOfRFpoolingMapsAlongHorizontalMeridian)
    pdfRootDir = RGCMosaicConstructor.filepathFor.rawFigurePDFsDir();
    videoDir = fullfile(pdfRootDir, exportVisualizationPDFdirectory);

    % The video specs
    theVideoFileName = sprintf('%s/ConePoolingRFmapsAlongHorizontalMeridian',videoDir);
	videoOBJ = VideoWriter(theVideoFileName, 'MPEG-4'); 
	videoOBJ.FrameRate = 30;
	videoOBJ.Quality = 100;
	videoOBJ.open();

    % The desired ROI
    theROI = regionOfInterest(...
        'geometryStruct', struct(...
            'units', 'degs', ...
            'shape', 'rect', ...
            'center', theMRGCmosaic.eccentricityDegs, ...
            'width', theMRGCmosaic.sizeDegs(1), ...
            'height', 0.1, ...
            'rotation', 0.0...
        ));

    visualizedMRGCindices = theROI.indicesOfPointsInside(theMRGCmosaic.rgcRFpositionsDegs);
    [~,idx] = sort(sqrt(sum(theMRGCmosaic.rgcRFpositionsDegs(visualizedMRGCindices,:).^2,2)), 'ascend');
    visualizedMRGCindices = visualizedMRGCindices(idx);

    domainVisualizationLimits(1:2) = theMRGCmosaic.eccentricityDegs(1) + 0.5*theMRGCmosaic.sizeDegs(1)/2 * [-1 1];
    domainVisualizationLimits(3:4) = theMRGCmosaic.eccentricityDegs(2) + 0.5*theMRGCmosaic.sizeDegs(2)/2 * [-1 1];


    % Include surround cones whose pooling weights are >= 0.001
    minSurroundConeWeight = 0.001;

    % Generate the video
    hFig = figure(500); clf;
    theAxes = PublicationReadyPlotLib.generatePanelAxes(hFig,ff);
    ax = theAxes{1,1};


    for iRGC = 1:numel(visualizedMRGCindices)

        domainVisualizationTicks.x = theMRGCmosaic.rgcRFpositionsDegs(visualizedMRGCindices(iRGC),1);
        domainVisualizationTicks.y = theMRGCmosaic.rgcRFpositionsDegs(visualizedMRGCindices(iRGC),2);
        scaleBarDegs = 0;
        theMRGCmosaic.visualizeCenterSurroundConePoolingMap(visualizedMRGCindices(iRGC), ...
            'minConeWeightForVisualizingRFcenterPooling', minCenterConeWeight, ...
            'minConeWeightForVisualizingRFsurroundPooling', minSurroundConeWeight, ...
            'minSurroundConeWeightRelativity', 'center', ...
            'scaleBarDegs', scaleBarDegs, ...
            'doNotLabelScaleBar', true, ...
            'plotTitle', sprintf('RGC #%d', visualizedMRGCindices(iRGC)), ...
            'axesToRenderIn', ax, ...
            'withCustomFigureFormat', '1x1 giant rectangular-wide mosaic', ...
            'domainVisualizationLimits', domainVisualizationLimits, ...
            'domainVisualizationTicks', domainVisualizationTicks);
        drawnow;
		videoOBJ.writeVideo(getframe(hFig));
    end
    videoOBJ.close();

end % generateVideoOfRFpoolingMapsAlongHorizontalMeridian

end



