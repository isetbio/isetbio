
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>t_FFTinMatlab.m</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-04-13"><meta name="DC.source" content="t_codeFFTinMatlab.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>t_FFTinMatlab.m</h1><!--introduction--><p>Explains the Matlab conventions for transforming from space to the frequency domain.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialize</a></li><li><a href="#2">First an extremely small example</a></li><li><a href="#3">Inverse transform</a></li><li><a href="#4">FFT</a></li><li><a href="#5">PSF/OTF example</a></li><li><a href="#6">Image example</a></li><li><a href="#7">End</a></li></ul></div><h2>Initialize<a name="1"></a></h2><pre class="codeinput">ieInit;
</pre><h2>First an extremely small example<a name="2"></a></h2><pre class="codeinput">nSamples = 6;
</pre><h2>Inverse transform<a name="3"></a></h2><p>In the transform domain, t(1,1) represents the DC term.  You can prove this by calculating the inverse FFT for all zeros except t(1,1)</p><pre class="codeinput">t = zeros(nSamples,nSamples);
t(1,1) = 1;
ft = ifft2(t)
isreal(ft)  <span class="comment">% The entries are all 1/(6*6)</span>
</pre><pre class="codeoutput">
ft =

    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278
    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278
    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278
    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278
    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278
    0.0278    0.0278    0.0278    0.0278    0.0278    0.0278


ans =

     1

</pre><h2>FFT<a name="4"></a></h2><p>In the space domain, the s(1,1) position represents the center of the image.  You can prove this by calculation</p><pre class="codeinput">s = zeros(nSamples,nSamples);
s(1,1) = 1;
fft2(s)     <span class="comment">% This produces the output for an impulse at the center</span>
isreal(s)


<span class="comment">% The implications of these representations for using fft2</span>
<span class="comment">%</span>
<span class="comment">% See Matlab documentation on fft2, ifft2, fftshift and ifftshift</span>

<span class="comment">% Image centering</span>
<span class="comment">% The center of an image of size (N,N) is</span>
<span class="comment">%  when N is odd,         ceil(N/2) + 1,</span>
<span class="comment">%      so if N = 5, center is (4,4)</span>
<span class="comment">%  when N is even is also ceil(N/2) + 1 = N/2 + 1,</span>
<span class="comment">%      so if N = 6, center is (4,4)</span>
<span class="comment">%</span>
<span class="comment">% When we pad an image or a filter, we want to do so in a way that the</span>
<span class="comment">% value at the center remains the center.</span>
<span class="comment">%</span>
<span class="comment">% This leaves the center of the image at the same location as it was. So,</span>
<span class="comment">% if we have an odd size image, we pad it on the right and bottom.</span>
<span class="comment">%</span>
<span class="comment">% Suppose we have an even size image, say N=6, and we pad it to N=7. The</span>
<span class="comment">% new center will be at (5,5). To preserve the old center data, which was</span>
<span class="comment">% at (4,4) to be at (5,5), we must pad at the left and top first.</span>
<span class="comment">%</span>
<span class="comment">%  If we pad an odd dimension, first pad the right and bottom</span>
<span class="comment">%  If we pad an even dimension, first pad the left and top</span>
<span class="comment">%</span>
<span class="comment">% These commented out lines might be examples of ways to do things.</span>
<span class="comment">%   img = ones(64,64); img = padarray(img,[32 32]);</span>
<span class="comment">%   g = zeros(128,128); g(65,65) = 1;</span>
</pre><pre class="codeoutput">
ans =

     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1


ans =

     1

</pre><h2>PSF/OTF example<a name="5"></a></h2><p>Suppose we create a PSF.  In most coding, the natural way to create a PSF is as an image.  The center is not in (1,1), but in the center.</p><pre class="codeinput">g = fspecial(<span class="string">'gaussian'</span>,128,2); axis <span class="string">equal</span>
figure(1); colormap(gray); mesh(g)

<span class="comment">% To calculate the OTF of the point spread function, we should place the</span>
<span class="comment">% center of the image in the (1,1) position.  We do this using fftshift.</span>
<span class="comment">% We can then take the fft2 of the result to produce the OTF.</span>
gFT = fft2(fftshift(g));
figure(1); mesh(abs(gFT))
</pre><img vspace="5" hspace="5" src="t_codeFFTinMatlab_01.png" alt=""> <h2>Image example<a name="6"></a></h2><p>Again, the image center is not in (1,1).  It is in the center.</p><pre class="codeinput">tmp = load(<span class="string">'trees'</span>);
cmap = gray(128);
img = cmap(tmp.X);
img = img(1:128,1:128);
figure(1); colormap(gray); imagesc(img); axis <span class="string">image</span>

<span class="comment">% Before we transform the image, we want to place its center in the (1,1)</span>
<span class="comment">% position.</span>
imgC = fftshift(img);
figure(1); imagesc(imgC); axis <span class="string">image</span>

<span class="comment">% Then we compute the transform</span>
imgFT = fft2(imgC);

<span class="comment">% We are ready to multiply the transformed image and the OTF</span>
imgFTgFT = imgFT .* gFT;

<span class="comment">% We can return the transform to the space domain.</span>
imgConvG = ifft2(imgFTgFT);

<span class="comment">% When we do, the image center is in the (1,1) position.</span>
figure(1); colormap(gray); imagesc(imgConvG); axis <span class="string">image</span>

<span class="comment">% We want the center in the center.  So we apply the ifftshift</span>
imgConvGCentered = ifftshift(imgConvG);
figure(1); imagesc(imgConvGCentered); axis <span class="string">image</span>
</pre><img vspace="5" hspace="5" src="t_codeFFTinMatlab_02.png" alt=""> <h2>End<a name="7"></a></h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% t_FFTinMatlab.m
%
% Explains the Matlab conventions for transforming from space to the frequency domain.  

%% Initialize
ieInit;

%% First an extremely small example
nSamples = 6;

%% Inverse transform
%
% In the transform domain, t(1,1) represents the DC term.  You can prove
% this by calculating the inverse FFT for all zeros except t(1,1)
t = zeros(nSamples,nSamples);
t(1,1) = 1;
ft = ifft2(t)
isreal(ft)  % The entries are all 1/(6*6)

%% FFT
%
% In the space domain, the s(1,1) position represents the center of the
% image.  You can prove this by calculation
s = zeros(nSamples,nSamples);
s(1,1) = 1;
fft2(s)     % This produces the output for an impulse at the center
isreal(s)


% The implications of these representations for using fft2 
%
% See Matlab documentation on fft2, ifft2, fftshift and ifftshift

% Image centering
% The center of an image of size (N,N) is
%  when N is odd,         ceil(N/2) + 1, 
%      so if N = 5, center is (4,4)
%  when N is even is also ceil(N/2) + 1 = N/2 + 1, 
%      so if N = 6, center is (4,4)
%
% When we pad an image or a filter, we want to do so in a way that the
% value at the center remains the center.   
%
% This leaves the center of the image at the same location as it was. So,
% if we have an odd size image, we pad it on the right and bottom. 
%
% Suppose we have an even size image, say N=6, and we pad it to N=7. The
% new center will be at (5,5). To preserve the old center data, which was
% at (4,4) to be at (5,5), we must pad at the left and top first.
%
%  If we pad an odd dimension, first pad the right and bottom
%  If we pad an even dimension, first pad the left and top
%
% These commented out lines might be examples of ways to do things.
%   img = ones(64,64); img = padarray(img,[32 32]);
%   g = zeros(128,128); g(65,65) = 1;

%% PSF/OTF example
%
% Suppose we create a PSF.  In most coding, the natural way to create a
% PSF is as an image.  The center is not in (1,1), but in the center.  
g = fspecial('gaussian',128,2); axis equal
figure(1); colormap(gray); mesh(g)

% To calculate the OTF of the point spread function, we should place the
% center of the image in the (1,1) position.  We do this using fftshift.
% We can then take the fft2 of the result to produce the OTF.
gFT = fft2(fftshift(g));
figure(1); mesh(abs(gFT))

%% Image example
% Again, the image center is not in (1,1).  It is in the center.
tmp = load('trees');
cmap = gray(128);
img = cmap(tmp.X);
img = img(1:128,1:128);
figure(1); colormap(gray); imagesc(img); axis image

% Before we transform the image, we want to place its center in the (1,1)
% position.
imgC = fftshift(img);
figure(1); imagesc(imgC); axis image

% Then we compute the transform
imgFT = fft2(imgC);

% We are ready to multiply the transformed image and the OTF 
imgFTgFT = imgFT .* gFT;

% We can return the transform to the space domain.  
imgConvG = ifft2(imgFTgFT);

% When we do, the image center is in the (1,1) position.
figure(1); colormap(gray); imagesc(imgConvG); axis image

% We want the center in the center.  So we apply the ifftshift
imgConvGCentered = ifftshift(imgConvG);
figure(1); imagesc(imgConvGCentered); axis image

%% End

##### SOURCE END #####
--></body></html>