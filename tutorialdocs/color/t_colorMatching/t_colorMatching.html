
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>t_ColorMatching</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-17"><meta name="DC.source" content="t_colorMatching.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>t_ColorMatching</h1><!--introduction--><p>Tutorial on color matching</p><p>This tutorial  introduces several computational methods in color. These are:  * How to compute the XYZ values of a light source  * How to set a monitor output to achieve these XYZ levels  * How to manage the nonlinear relationship between frame buffer and    emitted light output  * How to compute and plot the xy chromaticity values of a display</p><p>There are a set of questions at the end that can help you deepen your understanding.</p><p>Class:       Psych 221 - Applied Vision and Image Systems Tutorial:    Color Matching on Displays Author:      Wandell Purpose:     Introduce SPDs, XYZ functions, gamma, matching calculations Last Update: 2015/1/5 (HJ) Duration:    45 minutes</p><p>Matlab 5:     Checked 01.06.98 BW Matlab 7:     Checked 01.06.06 GN/BW R2014b:       Updated 12.31.14, use display objects and ieReadSpectra DHB</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialize</a></li><li><a href="#2">Computing XYZ values of a monitor</a></li><li><a href="#3">Using the CMFs to Match a target (linear display, gamma = 1)</a></li><li><a href="#4">Nonlinearity in display - Gamma table and inverse gamma table</a></li><li><a href="#5">Invert the gamma table</a></li><li><a href="#6">Computing xy-chromaticity coordinates</a></li><li><a href="#7">TUTORIAL QUESTIONS</a></li><li><a href="#8">Optional questions</a></li></ul></div><h2>Initialize<a name="1"></a></h2><pre class="codeinput">ieInit;
</pre><h2>Computing XYZ values of a monitor<a name="2"></a></h2><p>We must measure the main functions that define the color properties of any display: these are the phosphor spectral power distributions (SPDs). We measure these functions using a spectral radiometer, a device that measures the power per nanometer emitted by the display.</p><p>The spectral power distributions of a monitor in the Wandell lab, measured when the monitor display intensity was set to full value, are stored in the corresponding display object.  We extract the phosphor spectral power distributions.</p><pre class="codeinput">d = displayCreate(<span class="string">'CRT-Dell'</span>);
wavelength = displayGet(d, <span class="string">'wave'</span>);
dWave = wavelength(2) - wavelength(1); <span class="comment">% wavelength bin size</span>
phosphors  = displayGet(d, <span class="string">'spd primaries'</span>);

<span class="comment">% plot spectral power distribution</span>
vcNewGraphWin; plot(wavelength,phosphors(:,3:-1:1))
xlabel(<span class="string">'Wavelength (nm)'</span>), ylabel(<span class="string">'Intensity'</span>)
title(<span class="string">'Spectral Power Distribution of Example Monitor'</span>);
set(gca, <span class="string">'xlim'</span>, [350 750]); grid <span class="string">on</span>;

<span class="comment">%  To measure the XYZ values of these phosphors, we load in the xbar,ybar,</span>
<span class="comment">%  zbar functions defined by the CIE. These are stored in the columns</span>
<span class="comment">%  of a matrix, called xyz.mat</span>
XYZ = ieReadSpectra(<span class="string">'XYZ'</span>,wavelength);

vcNewGraphWin; plot(wavelength, XYZ);
xlabel(<span class="string">'Wavelength (nm)'</span>); ylabel(<span class="string">'Responsivity'</span>);
legend(<span class="string">'xbar'</span>, <span class="string">'ybar'</span>, <span class="string">'zbar'</span>); title(<span class="string">'CIE XYZ Functions'</span>);
set(gca,<span class="string">'xlim'</span>,[350 750]); grid <span class="string">on</span>

<span class="comment">% Now, we can compute the (X,Y,Z) values of each of the phosphors by</span>
<span class="comment">% multiplying the phosphor matrix times the xyz matrix. Notice that the</span>
<span class="comment">% phosphors are in the columns of the matrix on the right, and the</span>
<span class="comment">% xbar,ybar,zbar functions are in the rows of the matrix on the left.</span>
maxXYZ = 683 * XYZ' * phosphors * dWave;

<span class="comment">% The luminance of each phosphor is given by the Y values. The maximum</span>
<span class="comment">% value is when the phosphors are set to maximum intensity</span>
disp([<span class="string">'Max luminance of phosphors: '</span> num2str(maxXYZ(2,:))]);

<span class="comment">% The total luminance the display can reach, with all three phosphors on,</span>
<span class="comment">% is given by the sum of these three values, 100 cd/m^2 is a typical</span>
<span class="comment">% luminance level for monitors.</span>
disp([<span class="string">'Total luminance:'</span> num2str(sum(maxXYZ(2,:)))]);

<span class="comment">% A simple way to compute XYZ from spectrum is using function</span>
<span class="comment">% ieXYZFromEnergy</span>
maxXYZ = ieXYZFromEnergy(phosphors', wavelength)';
</pre><pre class="codeoutput">Max luminance of phosphors: 21.494      67.1483      11.9829
Total luminance:100.6252
</pre><img vspace="5" hspace="5" src="t_colorMatching_01.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_02.png" style="width:717px;height:518px;" alt=""> <h2>Using the CMFs to Match a target (linear display, gamma = 1)<a name="3"></a></h2><pre>Suppose that you send a space ship to the surface of Mars. The spaceship
sends back a measurement of a spectral power distribution. Let's load
it up.</pre><p>ieReadSpectrum adjusts the wavelength sampling stored in the file to match what we pass it.  In this case, it extrapolate the value at long wavelength as zeros</p><pre class="codeinput">marsSPD = ieReadSpectra(<span class="string">'marsspectrum'</span>, wavelength);

vcNewGraphWin; plot(wavelength, marsSPD, <span class="string">'r-'</span>)
set(gca,<span class="string">'ylim'</span>,[0 1]); grid <span class="string">on</span>;
xlabel(<span class="string">'wavelength (nm)'</span>); ylabel(<span class="string">'Intensity'</span>);
title(<span class="string">'Spectral Power Distribution measurement from Mars'</span>);

<span class="comment">% Now, how do we set the monitor intensities so that what we see on a</span>
<span class="comment">% display is a visual match to the spectrum measured on Mars?  We use the</span>
<span class="comment">% XYZ color-matching functions. First, measure the values for the Martian</span>
<span class="comment">% spectrum</span>
marsXYZ = ieXYZFromEnergy(marsSPD', wavelength);

<span class="comment">% Now, recall that the monitor color properties are determined by the</span>
<span class="comment">% relative intensity of the outputs of the monitor phosphor SPDs. Suppose</span>
<span class="comment">% these intensities are [r,g,b]'. Then the monitor output is</span>
<span class="comment">% phosphors*[r,g,b]'. For example, when the red phosphor only is on the</span>
<span class="comment">% spectrum is</span>
vcNewGraphWin;
plot(wavelength, phosphors*[1 0 0]', <span class="string">'r-'</span>);
xlabel(<span class="string">'wavelength(nm)'</span>); ylabel(<span class="string">'Intensity'</span>)
title(<span class="string">'SPD of Red Phosphor'</span>);

<span class="comment">% When the red and blue are on, the output is</span>
plot(wavelength, phosphors*[1 0 1]',<span class="string">'m-'</span>);
xlabel(<span class="string">'wavelength(nm)'</span>); ylabel(<span class="string">'Intensity'</span>)
title(<span class="string">'SPD of Red and Blue Phosphors Combined'</span>);

<span class="comment">% To find the relationship between the [r,g,b] values and the monitor XYZ</span>
<span class="comment">% outputs, we only need to multiply the output times the XYZ functions.</span>
<span class="comment">% Hence, there is a matrix that maps the linear monitor intensities into</span>
<span class="comment">% the XYZ values.  This matrix is</span>
mon2XYZ = ieXYZFromEnergy(phosphors', wavelength); <span class="comment">%#ok</span>

<span class="comment">% Or we can use</span>
mon2XYZ = displayGet(d, <span class="string">'rgb2xyz'</span>);

<span class="comment">% Take a look at this matrix and think about its entries.  Notice that the</span>
<span class="comment">% first column contains the XYZ values associated with the red phosphor,</span>
<span class="comment">% the middle with the green, and the third column is associated with the</span>
<span class="comment">% blue. These values should make sense to you given the shapes of the XYZ</span>
<span class="comment">% functions we have already plotted.</span>

<span class="comment">% Now, to represent the Martian spectrum on our display, we need to compute</span>
<span class="comment">% only one more thing.  How do we set the [r,g,b] values when we know the</span>
<span class="comment">% XYZ values of the spectrum?  For this, we need a matrix that converts XYZ</span>
<span class="comment">% to monitor linear gun intensities, the inverse of the matrix that we</span>
<span class="comment">% have.  So, we calculate this new matrix as</span>
marsRGB = mon2XYZ \ marsXYZ(:);

<span class="comment">% The spectrum we should display, therefore, is equal to</span>
vcNewGraphWin;
subplot(2,1,1); plot(wavelength, phosphors * marsRGB)
title(<span class="string">'Output SPD of the monitor'</span>);
xlabel(<span class="string">'wavelength(nm)'</span>); ylabel(<span class="string">'Intensity'</span>)

<span class="comment">% This will be a visual match to the spectrum</span>
subplot(2,1,2)
plot(wavelength,marsSPD);
title(<span class="string">'SPD of original martian image'</span>);
xlabel(<span class="string">'wavelength(nm)'</span>);ylabel(<span class="string">'Intensity'</span>)

<span class="comment">% The principles are the same when we make a match on a normal monitor. The</span>
<span class="comment">% only difference, which is reviewed below, is that the frame-buffer</span>
<span class="comment">% entries and the intensity of the phosphor output are a nonlinearly</span>
<span class="comment">% related. Hence, we must set the frame-buffer entries so that we obtain</span>
<span class="comment">% the linear intensity outputs we have just calculated.  This process is</span>
<span class="comment">% called gamma correction.</span>
</pre><img vspace="5" hspace="5" src="t_colorMatching_03.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_04.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_05.png" style="width:717px;height:518px;" alt=""> <h2>Nonlinearity in display - Gamma table and inverse gamma table<a name="4"></a></h2><p>The relationship between the intensity emitted by a CRT phosphor and the frame-buffer value is generally a nonlinear function. An example of the function relating frame-buffer value to emitted light intensity is shown here.</p><pre class="codeinput"><span class="comment">% We pull the measured gamma functions out of the display object. This</span>
<span class="comment">% particular one was measured at a small number of levels.  Go figure.</span>
monitorGam = displayGet(d, <span class="string">'gamma'</span>);
nLevels = size(monitorGam,1);

vcNewGraphWin;
plot(1:nLevels,monitorGam(:,1)); grid <span class="string">on</span>;
xlabel(<span class="string">'Frame buffer'</span>);  ylabel(<span class="string">'Emitted intensity of red phoshor'</span>);
title(<span class="string">'Display Red "Gamma" function'</span>)

<span class="comment">% This is called the "gamma" function of the display. The reason for this</span>
<span class="comment">% title is that the function is roughly a simple power function and the</span>
<span class="comment">% exponent has historically been called "gamma." Here is a comparison of</span>
<span class="comment">% the gamma function of the red phosphor and a power function with an</span>
<span class="comment">% exponent of 2.2, the most common value.</span>
vcNewGraphWin;
frameBuffer = 1:nLevels;
pred = ((frameBuffer)/nLevels).^(2.2);
plot(frameBuffer,pred,<span class="string">'k-'</span>,frameBuffer,monitorGam(:,1),<span class="string">'r-'</span>)
xlim([0 256]); xlabel(<span class="string">'Frame buffer'</span>); ylabel(<span class="string">'Intensity'</span>);
title(<span class="string">'Comparison of Power function and red phosphor emission'</span>)
legend(<span class="string">'y = x^2^.^2'</span>, <span class="string">'Red phosphor'</span>,<span class="string">'Location'</span>, <span class="string">'NorthWest'</span>);
grid <span class="string">on</span>

<span class="comment">% For grins, you can see that the fit is different using a larger exponent.</span>
vcNewGraphWin;
frameBuffer = 1:nLevels;
pred = ((frameBuffer)/nLevels).^(2.7);
plot(frameBuffer,pred,<span class="string">'k-'</span>,frameBuffer,monitorGam(:,1),<span class="string">'r-'</span>)
xlim([0 256]); xlabel(<span class="string">'Frame buffer'</span>); ylabel(<span class="string">'Intensity'</span>);
title(<span class="string">'Comparison of Power function and red phosphor emission'</span>)
legend(<span class="string">'y = x^2^.^7'</span>, <span class="string">'Red phosphor'</span>,<span class="string">'Location'</span>, <span class="string">'NorthWest'</span>);
grid <span class="string">on</span>

<span class="comment">% Recall that we measured the emitted intensity using the maximum</span>
<span class="comment">% framebuffer value.  This corresponds to the column entries in phosphor,</span>
<span class="comment">% and these are the signals emitted when the relative intensity is one.</span>

<span class="comment">% To specify the intensity of the emitted light for any given frame-buffer</span>
<span class="comment">% level, we can use the simple gamma function.  For example, the spectral</span>
<span class="comment">% power distribution of the light emitted by the green phosphor at a frame</span>
<span class="comment">% buffer level of 130 is</span>
vcNewGraphWin;
emitted = phosphors(:,2)*monitorGam(130,2);
plot(wavelength,emitted), grid <span class="string">on</span>
xlabel(<span class="string">'Wavelength'</span>)
ylabel(<span class="string">'Intensity'</span>)
title(<span class="string">'SPD of Green Phosphor at fb = 130'</span>);

<span class="comment">% Frequently, we are interested in how to set the frame-buffer level in</span>
<span class="comment">% order to obtain a given linear output intensity.  To determine this, we</span>
<span class="comment">% must calculate the inverse of the "gamma" function.  If we have fit a</span>
<span class="comment">% simple polynomial to the gamma function, then we can calculate the</span>
<span class="comment">% frame-buffer setting by inverting the function.  So that given a linear</span>
<span class="comment">% intensity, l, we can calculate the frame-buffer value as frame-buffer =</span>
<span class="comment">% l^(1/gamma).</span>
vcNewGraphWin;
intensity = 0:.001:1;
predFB = intensity.^(1/2.2);
plot(intensity,predFB)
xlabel(<span class="string">'Intensity'</span>); ylabel(<span class="string">'Frame buffer level'</span>);
title(<span class="string">'Power Gamma Function Inverse'</span>);
grid <span class="string">on</span>

<span class="comment">% Another way to perform this calculation is by creating a look-up table</span>
<span class="comment">% that inverts the gamma function. Here is the ISETBIO way to do this.</span>
vcNewGraphWin;
invGamTable = ieLUTInvert(monitorGam);
nTableLevels = size(invGamTable, 1);
plot((1:nTableLevels)/nTableLevels,invGamTable/max(invGamTable));
grid <span class="string">on</span>; xlabel(<span class="string">'Relative intensity'</span>); ylabel(<span class="string">'Frame buffer level'</span>);
title(<span class="string">'Calibration Inverse Gamma Table Values'</span>);

<span class="comment">% (We make invGamTables with more than 8 bits of resolution because some of</span>
<span class="comment">% the frame buffers we have in the lab are 10 bits.)</span>
</pre><img vspace="5" hspace="5" src="t_colorMatching_06.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_07.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_08.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_09.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_10.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_11.png" style="width:717px;height:518px;" alt=""> <h2>Invert the gamma table<a name="5"></a></h2><p>The function ieLUTLinear inverts the gamma table. It produces its output in the integer range that was specified at display calibration time, but doesn't round.</p><pre class="codeinput">intensity = (.1:.2:.9);
fb = round(ieLUTLinear(intensity, invGamTable));

<span class="comment">% Now, let's see how well we did. Here are the intensities we will obtain</span>
<span class="comment">% with these frame buffer values.</span>
obtainedIntensity = monitorGam(fb,1);

<span class="comment">% We can plot the obtained and desired intensities in a graph We are close,</span>
<span class="comment">% but because of the quantization of the device we do not obtain the exact</span>
<span class="comment">% linear intensities.</span>
plot(intensity, obtainedIntensity, <span class="string">'o'</span>, intensity, intensity,<span class="string">'-'</span>); grid <span class="string">on</span>
axis <span class="string">equal</span>, axis <span class="string">square</span>, axis <span class="string">tight</span>
set(gca,<span class="string">'xtick'</span>,(0:.2:1),<span class="string">'ytick'</span>,(0:.2:1))
<span class="comment">%identityLine = line([0 1],[0 1]);</span>
legend(<span class="string">'Obtained Intensity'</span>, <span class="string">'Ideal Intensity'</span>, <span class="string">'Location'</span>, <span class="string">'NorthWest'</span>);
title(<span class="string">'Ideal vs Obtained Intensity'</span>);
</pre><img vspace="5" hspace="5" src="t_colorMatching_12.png" style="width:717px;height:518px;" alt=""> <h2>Computing xy-chromaticity coordinates<a name="6"></a></h2><p>The monitor is also described in terms of several different chromaticity coordinate measurements, namely its "white point" and the gamut of colors that it can reach.  The white point is the chromaticity coordinates of the display when all three phosphors are set to maximum intensity.  These can be computed as</p><pre class="codeinput">whitePoint = chromaticity(sum(maxXYZ, 2)')';

<span class="comment">% The (x,y) chromaticity coordinates of the phosphors can be computed</span>
<span class="comment">% individually as</span>
xyMonitor = chromaticity(maxXYZ')';

<span class="comment">% We can build a graph describing the chromaticity coordinates of the</span>
<span class="comment">% phosphors and the white point by first computing the xy coordinates of</span>
<span class="comment">% the spectrum.  Remember that the rows of xyz contain the XYZ values of</span>
<span class="comment">% each spectral light.  So, we can compute the chromaticity of the spectral</span>
<span class="comment">% lights as</span>
xySpectrum = chromaticity(XYZ)';

<span class="comment">% Now, we plot these values and turn on hold.  Any light is a mixture of</span>
<span class="comment">% spectral lights, so these values define an outer boundary for where any</span>
<span class="comment">% physical light can fall.</span>
plotSpectrumLocus;  <span class="comment">% Read this routine</span>
axis <span class="string">equal</span>, axis <span class="string">square</span>
grid <span class="string">on</span>, xlabel(<span class="string">'x-chromaticity'</span>), ylabel(<span class="string">'y-chromaticity'</span>)
title(<span class="string">'Spectrum Locus (gamut of visible light)'</span>);
hold <span class="string">on</span>

<span class="comment">% Overlay the xy coordinates of the three monitor phosphors on top of the</span>
<span class="comment">% graph</span>
plot(xyMonitor(1,1),xyMonitor(2,1),<span class="string">'ro'</span>);
plot(xyMonitor(1,2),xyMonitor(2,2),<span class="string">'go'</span>);
plot(xyMonitor(1,3),xyMonitor(2,3),<span class="string">'bo'</span>);

<span class="comment">% And place a patch over the region where sums of the phosphors can fall.</span>
<span class="comment">% This is called the "gamut" of the display</span>
p = patch(xyMonitor(1,:), xyMonitor(2,:), [.5 .5 .5]);

<span class="comment">% Finally, add in the chromaticity coordinate of the white point and label</span>
<span class="comment">% the axes.</span>
plot(whitePoint(1),whitePoint(2),<span class="string">'wo'</span>);
xlabel(<span class="string">'x chromaticity'</span>), ylabel(<span class="string">'y chromaticity'</span>)
hold <span class="string">off</span>

<span class="comment">% To plot gamut for a display, we can simply call</span>
displayPlot(d, <span class="string">'gamut'</span>);

<span class="comment">% Notice that the white point coordinates are not at the middle of the</span>
<span class="comment">% gamut. The position of the white point depends on the sum of the (X,Y,Z)</span>
<span class="comment">% values from each of the phosphors.  These are unequal, with the green and</span>
<span class="comment">% blue being the largest.  Hence, the white point is closer to these two</span>
<span class="comment">% corners of the gamut</span>
sum(maxXYZ)
</pre><pre class="codeoutput">
ans =

   1.0e+02 *

   0.629988328240694   1.101268068286888   1.585156584602907

</pre><img vspace="5" hspace="5" src="t_colorMatching_13.png" style="width:717px;height:518px;" alt=""> <img vspace="5" hspace="5" src="t_colorMatching_14.png" style="width:717px;height:518px;" alt=""> <h2>TUTORIAL QUESTIONS<a name="7"></a></h2><p>USING THE COLOR MATCHING FUNCTIONS</p><p>Consider a color matching experiment using a CRT monitor with phosphor spectral power distributions (SPD) given by 'phosphors' in cMatch/monitor.mat</p><p>a) Using the CIE-XYZ method, calculate what phosphor intensities you will need to match a monochrome light at 550nm.  What phosphor intensities are needed to match a monochrome light at 430nm?</p><p>b) Plot the SPD of the phosphors that would make this match.  Why are these intensities not physically realizable?</p><p>c) If you wanted to perform an experiment to test the predicted match, what could you do to arrange the viewing conditions?</p><p>COLOR MONITOR CALIBRATION AND CHROMATICITY</p><p>a) Let the SPDs of the three phosphors of a color monitor be R, G, and B. Let the value of a pixel be written as a vector x = [r,g,b], where r, g, and b are between 0 and 1.</p><p>Write the matrix equation that expresses the SPD of a monitor pixel displaying the pixel x.  (Ignore gamma correction)</p><p>b) How do the set of spectral power distributions emitted from a pixel compare with the spectral power distributions that are possible in the environment?</p><p>c) Typical monitors can modulate the linear phosphor intensity at 256 levels (8-bits). Suppose that you could modulate the phosphor intensities at 16-bit accuracy. Would this monitor produce better images?  If you are not sure, then state what you need to know about the human visual system to decide whether the improvement is worthwhile.</p><p>d) Suppose that you are able to build a monitor with a fourth phosphor, not just the three that are usually built. In what sense would this monitor be better than a three-primary monitor?  If you could set the x-y chromaticity of the phosphor, how would you design it to achieve the best monitor performance?  You may want to sketch or plot a chromaticity diagram to show what you mean.</p><h2>Optional questions<a name="8"></a></h2><p>Suppose you are an LCD manufacturer, and you know that if you had an ideal LCD, each of the R,G,B color channels would emit light according to the SPD given in monitors.mat.  We have already plotted the color gamut of such a monitor.</p><p>In a real LCD display, the LC gates are not able to block 100% of the light from the backlight.  Suppose that due to such leakage, the contrast ratio between a fully black and fully white display is 100:1. Plot the gamut of colors for this display and explain what happens.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% t_ColorMatching
%
% Tutorial on color matching
%
% This tutorial  introduces several computational methods in color. These
% are:
%  * How to compute the XYZ values of a light source
%  * How to set a monitor output to achieve these XYZ levels
%  * How to manage the nonlinear relationship between frame buffer and
%    emitted light output
%  * How to compute and plot the xy chromaticity values of a display
%
% There are a set of questions at the end that can help you deepen your
% understanding.
%
% Class:       Psych 221 - Applied Vision and Image Systems 
% Tutorial:    Color Matching on Displays
% Author:      Wandell 
% Purpose:     Introduce SPDs, XYZ functions, gamma, matching calculations 
% Last Update: 2015/1/5 (HJ)
% Duration:    45 minutes
%	
% Matlab 5:     Checked 01.06.98 BW
% Matlab 7:     Checked 01.06.06 GN/BW
% R2014b:       Updated 12.31.14, use display objects and ieReadSpectra DHB
%

%% Initialize
ieInit;

%% Computing XYZ values of a monitor
%
% We must measure the main functions that define the color properties of
% any display: these are the phosphor spectral power distributions (SPDs).
% We measure these functions using a spectral radiometer, a device that
% measures the power per nanometer emitted by the display.
%
% The spectral power distributions of a monitor in the Wandell lab,
% measured when the monitor display intensity was set to full value, are
% stored in the corresponding display object.  We extract the phosphor
% spectral power distributions.
d = displayCreate('CRT-Dell');
wavelength = displayGet(d, 'wave');
dWave = wavelength(2) - wavelength(1); % wavelength bin size
phosphors  = displayGet(d, 'spd primaries');

% plot spectral power distribution
vcNewGraphWin; plot(wavelength,phosphors(:,3:-1:1))
xlabel('Wavelength (nm)'), ylabel('Intensity')
title('Spectral Power Distribution of Example Monitor');
set(gca, 'xlim', [350 750]); grid on;

%  To measure the XYZ values of these phosphors, we load in the xbar,ybar,
%  zbar functions defined by the CIE. These are stored in the columns
%  of a matrix, called xyz.mat
XYZ = ieReadSpectra('XYZ',wavelength);

vcNewGraphWin; plot(wavelength, XYZ);
xlabel('Wavelength (nm)'); ylabel('Responsivity');
legend('xbar', 'ybar', 'zbar'); title('CIE XYZ Functions');
set(gca,'xlim',[350 750]); grid on

% Now, we can compute the (X,Y,Z) values of each of the phosphors by
% multiplying the phosphor matrix times the xyz matrix. Notice that the
% phosphors are in the columns of the matrix on the right, and the
% xbar,ybar,zbar functions are in the rows of the matrix on the left.
maxXYZ = 683 * XYZ' * phosphors * dWave;

% The luminance of each phosphor is given by the Y values. The maximum
% value is when the phosphors are set to maximum intensity
disp(['Max luminance of phosphors: ' num2str(maxXYZ(2,:))]);

% The total luminance the display can reach, with all three phosphors on,
% is given by the sum of these three values, 100 cd/m^2 is a typical
% luminance level for monitors.
disp(['Total luminance:' num2str(sum(maxXYZ(2,:)))]);

% A simple way to compute XYZ from spectrum is using function
% ieXYZFromEnergy
maxXYZ = ieXYZFromEnergy(phosphors', wavelength)';

%% Using the CMFs to Match a target (linear display, gamma = 1)
%  Suppose that you send a space ship to the surface of Mars. The spaceship
%  sends back a measurement of a spectral power distribution. Let's load
%  it up.
%
% ieReadSpectrum adjusts the wavelength sampling stored in the file to
% match what we pass it.  In this case, it extrapolate the value at long
% wavelength as zeros
marsSPD = ieReadSpectra('marsspectrum', wavelength);

vcNewGraphWin; plot(wavelength, marsSPD, 'r-')
set(gca,'ylim',[0 1]); grid on;
xlabel('wavelength (nm)'); ylabel('Intensity');
title('Spectral Power Distribution measurement from Mars');

% Now, how do we set the monitor intensities so that what we see on a
% display is a visual match to the spectrum measured on Mars?  We use the
% XYZ color-matching functions. First, measure the values for the Martian
% spectrum
marsXYZ = ieXYZFromEnergy(marsSPD', wavelength);

% Now, recall that the monitor color properties are determined by the
% relative intensity of the outputs of the monitor phosphor SPDs. Suppose
% these intensities are [r,g,b]'. Then the monitor output is
% phosphors*[r,g,b]'. For example, when the red phosphor only is on the
% spectrum is
vcNewGraphWin;
plot(wavelength, phosphors*[1 0 0]', 'r-');
xlabel('wavelength(nm)'); ylabel('Intensity')
title('SPD of Red Phosphor');

% When the red and blue are on, the output is
plot(wavelength, phosphors*[1 0 1]','m-');
xlabel('wavelength(nm)'); ylabel('Intensity')
title('SPD of Red and Blue Phosphors Combined');

% To find the relationship between the [r,g,b] values and the monitor XYZ
% outputs, we only need to multiply the output times the XYZ functions.
% Hence, there is a matrix that maps the linear monitor intensities into
% the XYZ values.  This matrix is
mon2XYZ = ieXYZFromEnergy(phosphors', wavelength); %#ok

% Or we can use
mon2XYZ = displayGet(d, 'rgb2xyz');

% Take a look at this matrix and think about its entries.  Notice that the
% first column contains the XYZ values associated with the red phosphor,
% the middle with the green, and the third column is associated with the
% blue. These values should make sense to you given the shapes of the XYZ
% functions we have already plotted.

% Now, to represent the Martian spectrum on our display, we need to compute
% only one more thing.  How do we set the [r,g,b] values when we know the
% XYZ values of the spectrum?  For this, we need a matrix that converts XYZ
% to monitor linear gun intensities, the inverse of the matrix that we
% have.  So, we calculate this new matrix as
marsRGB = mon2XYZ \ marsXYZ(:);

% The spectrum we should display, therefore, is equal to
vcNewGraphWin;
subplot(2,1,1); plot(wavelength, phosphors * marsRGB)
title('Output SPD of the monitor');
xlabel('wavelength(nm)'); ylabel('Intensity')

% This will be a visual match to the spectrum
subplot(2,1,2) 
plot(wavelength,marsSPD);
title('SPD of original martian image');
xlabel('wavelength(nm)');ylabel('Intensity')

% The principles are the same when we make a match on a normal monitor. The
% only difference, which is reviewed below, is that the frame-buffer
% entries and the intensity of the phosphor output are a nonlinearly
% related. Hence, we must set the frame-buffer entries so that we obtain
% the linear intensity outputs we have just calculated.  This process is
% called gamma correction.

%% Nonlinearity in display - Gamma table and inverse gamma table
%
% The relationship between the intensity emitted by a CRT phosphor and the
% frame-buffer value is generally a nonlinear function. An example of the
% function relating frame-buffer value to emitted light intensity is shown
% here.

% We pull the measured gamma functions out of the display object. This
% particular one was measured at a small number of levels.  Go figure.
monitorGam = displayGet(d, 'gamma');
nLevels = size(monitorGam,1);

vcNewGraphWin;
plot(1:nLevels,monitorGam(:,1)); grid on;
xlabel('Frame buffer');  ylabel('Emitted intensity of red phoshor');
title('Display Red "Gamma" function')

% This is called the "gamma" function of the display. The reason for this
% title is that the function is roughly a simple power function and the
% exponent has historically been called "gamma." Here is a comparison of
% the gamma function of the red phosphor and a power function with an
% exponent of 2.2, the most common value.
vcNewGraphWin;
frameBuffer = 1:nLevels;
pred = ((frameBuffer)/nLevels).^(2.2);
plot(frameBuffer,pred,'k-',frameBuffer,monitorGam(:,1),'r-')
xlim([0 256]); xlabel('Frame buffer'); ylabel('Intensity');
title('Comparison of Power function and red phosphor emission')
legend('y = x^2^.^2', 'Red phosphor','Location', 'NorthWest');
grid on

% For grins, you can see that the fit is different using a larger exponent.
vcNewGraphWin;
frameBuffer = 1:nLevels;
pred = ((frameBuffer)/nLevels).^(2.7);
plot(frameBuffer,pred,'k-',frameBuffer,monitorGam(:,1),'r-')
xlim([0 256]); xlabel('Frame buffer'); ylabel('Intensity');
title('Comparison of Power function and red phosphor emission')
legend('y = x^2^.^7', 'Red phosphor','Location', 'NorthWest');
grid on

% Recall that we measured the emitted intensity using the maximum
% framebuffer value.  This corresponds to the column entries in phosphor,
% and these are the signals emitted when the relative intensity is one.

% To specify the intensity of the emitted light for any given frame-buffer
% level, we can use the simple gamma function.  For example, the spectral
% power distribution of the light emitted by the green phosphor at a frame
% buffer level of 130 is
vcNewGraphWin;
emitted = phosphors(:,2)*monitorGam(130,2);
plot(wavelength,emitted), grid on
xlabel('Wavelength')
ylabel('Intensity')
title('SPD of Green Phosphor at fb = 130');

% Frequently, we are interested in how to set the frame-buffer level in
% order to obtain a given linear output intensity.  To determine this, we
% must calculate the inverse of the "gamma" function.  If we have fit a
% simple polynomial to the gamma function, then we can calculate the
% frame-buffer setting by inverting the function.  So that given a linear
% intensity, l, we can calculate the frame-buffer value as frame-buffer =
% l^(1/gamma).
vcNewGraphWin;
intensity = 0:.001:1;
predFB = intensity.^(1/2.2);
plot(intensity,predFB)
xlabel('Intensity'); ylabel('Frame buffer level');
title('Power Gamma Function Inverse');
grid on

% Another way to perform this calculation is by creating a look-up table
% that inverts the gamma function. Here is the ISETBIO way to do this.
vcNewGraphWin;
invGamTable = ieLUTInvert(monitorGam);
nTableLevels = size(invGamTable, 1);
plot((1:nTableLevels)/nTableLevels,invGamTable/max(invGamTable));
grid on; xlabel('Relative intensity'); ylabel('Frame buffer level');
title('Calibration Inverse Gamma Table Values');

% (We make invGamTables with more than 8 bits of resolution because some of
% the frame buffers we have in the lab are 10 bits.)

%% Invert the gamma table
% The function ieLUTLinear inverts the gamma table. It produces its output
% in the integer range that was specified at display calibration time, but
% doesn't round.
intensity = (.1:.2:.9);
fb = round(ieLUTLinear(intensity, invGamTable));

% Now, let's see how well we did. Here are the intensities we will obtain
% with these frame buffer values.
obtainedIntensity = monitorGam(fb,1);

% We can plot the obtained and desired intensities in a graph We are close,
% but because of the quantization of the device we do not obtain the exact
% linear intensities.
plot(intensity, obtainedIntensity, 'o', intensity, intensity,'-'); grid on
axis equal, axis square, axis tight
set(gca,'xtick',(0:.2:1),'ytick',(0:.2:1))
%identityLine = line([0 1],[0 1]);
legend('Obtained Intensity', 'Ideal Intensity', 'Location', 'NorthWest');
title('Ideal vs Obtained Intensity');

%% Computing xy-chromaticity coordinates
%
% The monitor is also described in terms of several different chromaticity
% coordinate measurements, namely its "white point" and the gamut of colors
% that it can reach.  The white point is the chromaticity coordinates of
% the display when all three phosphors are set to maximum intensity.  These
% can be computed as
whitePoint = chromaticity(sum(maxXYZ, 2)')';

% The (x,y) chromaticity coordinates of the phosphors can be computed
% individually as
xyMonitor = chromaticity(maxXYZ')';

% We can build a graph describing the chromaticity coordinates of the
% phosphors and the white point by first computing the xy coordinates of
% the spectrum.  Remember that the rows of xyz contain the XYZ values of
% each spectral light.  So, we can compute the chromaticity of the spectral
% lights as
xySpectrum = chromaticity(XYZ)';

% Now, we plot these values and turn on hold.  Any light is a mixture of
% spectral lights, so these values define an outer boundary for where any
% physical light can fall.
plotSpectrumLocus;  % Read this routine
axis equal, axis square
grid on, xlabel('x-chromaticity'), ylabel('y-chromaticity')
title('Spectrum Locus (gamut of visible light)');
hold on

% Overlay the xy coordinates of the three monitor phosphors on top of the
% graph
plot(xyMonitor(1,1),xyMonitor(2,1),'ro');
plot(xyMonitor(1,2),xyMonitor(2,2),'go');
plot(xyMonitor(1,3),xyMonitor(2,3),'bo');

% And place a patch over the region where sums of the phosphors can fall.
% This is called the "gamut" of the display
p = patch(xyMonitor(1,:), xyMonitor(2,:), [.5 .5 .5]);

% Finally, add in the chromaticity coordinate of the white point and label
% the axes.
plot(whitePoint(1),whitePoint(2),'wo');
xlabel('x chromaticity'), ylabel('y chromaticity')
hold off

% To plot gamut for a display, we can simply call
displayPlot(d, 'gamut');

% Notice that the white point coordinates are not at the middle of the
% gamut. The position of the white point depends on the sum of the (X,Y,Z)
% values from each of the phosphors.  These are unequal, with the green and
% blue being the largest.  Hence, the white point is closer to these two
% corners of the gamut
sum(maxXYZ)

%% TUTORIAL QUESTIONS
%
% USING THE COLOR MATCHING FUNCTIONS
%
% Consider a color matching experiment using a CRT monitor with phosphor
% spectral power distributions (SPD) given by 'phosphors' in
% cMatch/monitor.mat
%
% a) Using the CIE-XYZ method, calculate what phosphor intensities you will
% need to match a monochrome light at 550nm.  What phosphor intensities are
% needed to match a monochrome light at 430nm?
%
% b) Plot the SPD of the phosphors that would make this match.  Why are
% these intensities not physically realizable?
%
% c) If you wanted to perform an experiment to test the predicted match,
% what could you do to arrange the viewing conditions?
%
% COLOR MONITOR CALIBRATION AND CHROMATICITY
%
% a) Let the SPDs of the three phosphors of a color monitor be R, G, and B.
% Let the value of a pixel be written as a vector x = [r,g,b], where r, g,
% and b are between 0 and 1.
%
% Write the matrix equation that expresses the SPD of a monitor pixel
% displaying the pixel x.  (Ignore gamma correction)
%
% b) How do the set of spectral power distributions emitted from a pixel
% compare with the spectral power distributions that are possible in the
% environment?
%
% c) Typical monitors can modulate the linear phosphor intensity at 256
% levels (8-bits). Suppose that you could modulate the phosphor intensities
% at 16-bit accuracy. Would this monitor produce better images?  If you are
% not sure, then state what you need to know about the human visual system
% to decide whether the improvement is worthwhile.
%
% d) Suppose that you are able to build a monitor with a fourth phosphor,
% not just the three that are usually built. In what sense would this
% monitor be better than a three-primary monitor?  If you could set the x-y
% chromaticity of the phosphor, how would you design it to achieve the best
% monitor performance?  You may want to sketch or plot a chromaticity
% diagram to show what you mean.
%
%% Optional questions
% 
% Suppose you are an LCD manufacturer, and you know that if you had an
% ideal LCD, each of the R,G,B color channels would emit light according to
% the SPD given in monitors.mat.  We have already plotted the color gamut
% of such a monitor.
%
% In a real LCD display, the LC gates are not able to block 100% of the
% light from the backlight.  Suppose that due to such leakage, the contrast
% ratio between a fully black and fully white display is 100:1. Plot the
% gamut of colors for this display and explain what happens.


##### SOURCE END #####
--></body></html>