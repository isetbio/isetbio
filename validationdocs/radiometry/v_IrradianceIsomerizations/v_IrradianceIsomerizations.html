
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>v_IrradianceIsomerizations</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-04-14"><meta name="DC.source" content="v_IrradianceIsomerizations.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Initialize ISETBIO</a></li><li><a href="#5">Set computation params</a></li><li><a href="#6">Create a radiance image in ISETBIO</a></li><li><a href="#7">Compute the irradiance in ISETBIO</a></li><li><a href="#8">Define a region of interest starting at the scene's center with size</a></li><li><a href="#9">Get wavelength and spectral radiance spd data (averaged within the scene ROI)</a></li><li><a href="#10">Check spatial uniformity of scene radiance data.</a></li><li><a href="#11">Get wavelength and spectral irradiance spd data (averaged within the scene ROI)</a></li><li><a href="#12">Check spatial uniformity of optical image irradiance data.</a></li><li><a href="#13">Get the underlying parameters that are needed from the ISETBIO structures.</a></li><li><a href="#14">Compute the irradiance in PTB</a></li><li><a href="#15">Compare irradiances computed by ISETBIO vs. PTB</a></li><li><a href="#16">Numerical check to decide whether we passed.</a></li><li><a href="#17">Compare spectral sensitivities used by ISETBIO and PTB.</a></li><li><a href="#18">Compute quantal absorptions</a></li><li><a href="#19">Adjust answer for differences in collecting area in the two calculations</a></li><li><a href="#20">Also need to correct for magnification difference</a></li><li><a href="#21">Plotting</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = v_IrradianceIsomerizations(varargin)
<span class="comment">%</span>
<span class="comment">% Validate ISETBIO-based irradiance/isomerization computations by comparing to PTB-based irradiance/isomerization computations.</span>
<span class="comment">%</span>
<span class="comment">% See also: v_Cones</span>
<span class="comment">%</span>
<span class="comment">% Minor issues:</span>
<span class="comment">%</span>
<span class="comment">% 1) The irradiance calculations agree to about 1%, once the difference in</span>
<span class="comment">% how isetbio and PTB compute degrees to mm of retina is taken into</span>
<span class="comment">% account. We are not sure of the reason for the 1% difference.  This may</span>
<span class="comment">% be related to the fact that the spatial uniformity of the optical image</span>
<span class="comment">% irradiance in isetbio is only good to about 1%, even though we think the</span>
<span class="comment">% optics are turned off in the computation.  A similar magnitude difference</span>
<span class="comment">% is seen in the isomerizations, which may have its roots in this same</span>
<span class="comment">% effect (since isomerizations are computed from the irradiance in each</span>
<span class="comment">% case), or in the slight differences in spectral qe below.</span>
<span class="comment">%</span>
<span class="comment">% 2) Isetbio and PTB agree to about a percent for quantal efficiencies, but</span>
<span class="comment">% not exactly, about the CIE 2-deg cone fundamentals, when converted to</span>
<span class="comment">% quantal efficiencies.  They agree better in v_Cones, I think.  Why?</span>
<span class="comment">%</span>
<span class="comment">% To do:</span>
<span class="comment">%</span>
<span class="comment">% 1) It might be good to vary some of the underlying parameters in both</span>
<span class="comment">% calculational paths and make sure that all of the parameters are have</span>
<span class="comment">% the expected and same effects in both cases.  Key parameters are lens and</span>
<span class="comment">% macular pigment density, pigment optical density, photopigment</span>
<span class="comment">% lambda-max, cone aperature area, photopigment quantal efficiency.  It is</span>
<span class="comment">% possible this should be done in v_Cones rather than here.</span>
<span class="comment">%</span>
<span class="comment">% 2) Check that integration over wavelength is being done consistently in</span>
<span class="comment">% isetbio and PTB.  PTB works by assuming that spectral power is per</span>
<span class="comment">% wavelength band.  Isetbio takes irrandiance in a per nm basis and explicitly</span>
<span class="comment">% includes the wavelength sampling step in its numerical integration.</span>

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Initialize ISETBIO<a name="4"></a></h2><pre class="codeinput">    s_initISET;
</pre><h2>Set computation params<a name="5"></a></h2><pre class="codeinput">    fov     = 20;  <span class="comment">% need large field</span>
    roiSize = 5;
</pre><h2>Create a radiance image in ISETBIO<a name="6"></a></h2><pre class="codeinput">    scene = sceneCreate(<span class="string">'uniform ee'</span>);    <span class="comment">% Equal energy</span>
    scene = sceneSet(scene,<span class="string">'name'</span>,<span class="string">'Equal energy uniform field'</span>);
    scene = sceneSet(scene,<span class="string">'fov'</span>, fov);
</pre><h2>Compute the irradiance in ISETBIO<a name="7"></a></h2><p>To make comparison to PTB work, we turn off off axis correction as well as optical blurring in the optics.</p><pre class="codeinput">    oi     = oiCreate(<span class="string">'human'</span>);
    optics = oiGet(oi,<span class="string">'optics'</span>);
    optics = opticsSet(optics,<span class="string">'off axis method'</span>,<span class="string">'skip'</span>);
    optics = opticsSet(optics,<span class="string">'otf method'</span>,<span class="string">'skip otf'</span>);
    oi     = oiSet(oi,<span class="string">'optics'</span>,optics);
    oi     = oiCompute(oi,scene);
</pre><h2>Define a region of interest starting at the scene's center with size<a name="8"></a></h2><p>roiSize x roiSize</p><pre class="codeinput">    sz = sceneGet(scene,<span class="string">'size'</span>);
    rect = [sz(2)/2,sz(1)/2,roiSize,roiSize];
    sceneRoiLocs = ieRoi2Locs(rect);
</pre><h2>Get wavelength and spectral radiance spd data (averaged within the scene ROI)<a name="9"></a></h2><pre class="codeinput">    wave  = sceneGet(scene,<span class="string">'wave'</span>);
    radiancePhotons = sceneGet(scene,<span class="string">'roi mean photons'</span>, sceneRoiLocs);
    radianceEnergy  = sceneGet(scene,<span class="string">'roi mean energy'</span>,  sceneRoiLocs);
</pre><h2>Check spatial uniformity of scene radiance data.<a name="10"></a></h2><p>This also verifies that two ways of getting the same information out in isetbio give the same answer.</p><pre class="codeinput">    radianceData = vcGetROIData(scene,sceneRoiLocs,<span class="string">'energy'</span>);
    radianceEnergyCheck = mean(radianceData,1);
    <span class="keyword">if</span> (any(radianceEnergy ~= radianceEnergyCheck))
        UnitTest.validationRecord(<span class="string">'FUNDAMENTAL_CHECK_FAILED'</span>, <span class="string">'Two ways of extracting mean scene radiance in isetbio do not agree.'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    radianceUniformityErr = (max(radianceData(:)) - min(radianceData(:)))/mean(radianceData(:));
    uniformityRadianceTolerance = 0.00001;
    quantityOfInterest = radianceUniformityErr;
    UnitTest.assertIsZero(quantityOfInterest,<span class="string">'Spatial uniformity of scene radiance'</span>,uniformityRadianceTolerance);
</pre><h2>Get wavelength and spectral irradiance spd data (averaged within the scene ROI)<a name="11"></a></h2><p>Need to recenter roi when computing from the optical image, because the optical image is padded to deal with optical blurring at its edge.</p><pre class="codeinput">    sz         = oiGet(oi,<span class="string">'size'</span>);
    rect       = [sz(2)/2,sz(1)/2,roiSize,roiSize];
    oiRoiLocs  = ieRoi2Locs(rect);
    <span class="keyword">if</span> (any(wave-oiGet(scene,<span class="string">'wave'</span>)))
        UnitTest.validationRecord(<span class="string">'FUNDAMENTAL_CHECK_FAILED'</span>, <span class="string">'Wavelength sampling changed between scene and optical image.'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    isetbioIrradianceEnergy = oiGet(oi,<span class="string">'roi mean energy'</span>, oiRoiLocs);
</pre><h2>Check spatial uniformity of optical image irradiance data.<a name="12"></a></h2><p>With optics turned off, we think this should be perfect but it isn't. It's good to 1%, but not to 0.1%.  This may be why PTB and isetbio only agree to about 1%.</p><p>This also verifies that two ways of getting the same information out in isetbio give the same answer.</p><pre class="codeinput">    irradianceData = vcGetROIData(oi,oiRoiLocs,<span class="string">'energy'</span>);
    irradianceEnergyCheck = mean(irradianceData,1);
    <span class="keyword">if</span> (any(isetbioIrradianceEnergy ~= irradianceEnergyCheck))
        UnitTest.validationRecord(<span class="string">'FUNDAMENTAL_CHECK_FAILED'</span>, <span class="string">'Two ways of extracting mean optical image irradiance in isetbio do not agree.'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    irradianceUniformityErr = (max(irradianceData(:)) - min(irradianceData(:)))/mean(irradianceData(:));
    uniformityIrradianceTolerance = 0.01;
    UnitTest.assertIsZero(irradianceUniformityErr, <span class="string">'Spatial uniformity of optical image irradiance'</span>, uniformityIrradianceTolerance);
    UnitTest.extraData(<span class="string">'irradianceData'</span>,irradianceData);
    UnitTest.extraData(<span class="string">'irradianceUniformityErr'</span>,irradianceUniformityErr);
</pre><h2>Get the underlying parameters that are needed from the ISETBIO structures.<a name="13"></a></h2><pre class="codeinput">    optics = oiGet(oi,<span class="string">'optics'</span>);
    pupilDiameterMm  = opticsGet(optics,<span class="string">'pupil diameter'</span>,<span class="string">'mm'</span>);
    focalLengthMm    = opticsGet(optics,<span class="string">'focal length'</span>,<span class="string">'mm'</span>);
</pre><h2>Compute the irradiance in PTB<a name="14"></a></h2><p>The PTB calculation is encapsulated in ptb.ConeIsomerizationsFromRadiance. This routine also returns cone isomerizations, which we will use below to to validate that computation as well.</p><p>The macular pigment and integration time parameters affect the isomerizations, but don't affect the irradiance returned by the PTB routine. The integration time doesn't affect the irradiance, but we need to pass it</p><pre class="codeinput">    macularPigmentOffset = 0;
    integrationTimeSec   = 0.05;
    [ptbIsomerizations, ~, ptbPhotoreceptors, ptbIrradiance] = <span class="keyword">...</span>
        ptb.ConeIsomerizationsFromRadiance(radianceEnergy(:), wave(:),<span class="keyword">...</span>
        pupilDiameterMm, focalLengthMm, integrationTimeSec,macularPigmentOffset);
</pre><h2>Compare irradiances computed by ISETBIO vs. PTB<a name="15"></a></h2><p>The comparison accounts for a magnification difference in the computation of retinal irradiance.  The magnification difference results from how Peter Catrysse implemented the radiance to irradiance calculation in isetbio versus the simple trig formula used in PTB. Correcting for this reduces the difference to about 1%</p><p>It might be useful here to explain how the correction factor is deterimend. One assumes that the squaring deals with linear dimension to area. Why the absolute value around the (m), however, is mysterious to DHB.</p><pre class="codeinput">    m = opticsGet(optics,<span class="string">'magnification'</span>,sceneGet(scene,<span class="string">'distance'</span>));
    ptbMagCorrectIrradiance = ptbIrradiance(:)/(1+abs(m))^2;
</pre><h2>Numerical check to decide whether we passed.<a name="16"></a></h2><p>We are checking against a 1% error.  We also store the computed values for future comparison via our validation and check mechanism.</p><pre class="codeinput">    tolerance = 0.01;
    ptbMagCorrectIrradiance = ptbMagCorrectIrradiance(:);
    isetbioIrradianceEnergy = isetbioIrradianceEnergy(:);
    difference = ptbMagCorrectIrradiance-isetbioIrradianceEnergy;
    quantityOfInterest = difference./isetbioIrradianceEnergy;
    UnitTest.assertIsZero(quantityOfInterest,<span class="string">'Difference between PTB and isetbio irradiance'</span>,tolerance);

    <span class="comment">% Add validation data</span>
    UnitTest.extraData(<span class="string">'fov'</span>, fov);
    UnitTest.extraData(<span class="string">'roiSize'</span>, roiSize);
    UnitTest.extraData(<span class="string">'tolerance'</span>, tolerance);
    UnitTest.extraData(<span class="string">'magCorrectionFactor'</span>,m);
    UnitTest.extraData(<span class="string">'ptbMagCorrectIrradiance'</span>, ptbMagCorrectIrradiance);
    UnitTest.extraData(<span class="string">'isetbioIrradianceEnergy'</span>,isetbioIrradianceEnergy);

    <span class="comment">% Add extra data</span>
    UnitTest.extraData(<span class="string">'scene'</span>, scene);
    UnitTest.extraData(<span class="string">'oi'</span>, oi);
</pre><h2>Compare spectral sensitivities used by ISETBIO and PTB.<a name="17"></a></h2><p>The PTB routine above uses the CIE 2-deg standard, which is the Stockman-Sharpe 2-degree fundamentals.  Apparently, so does ISETBIO.</p><p>The agreement is good to about a percent.</p><p>Get PTB cones spectral sensitivity, quantal units</p><pre class="codeinput">    coneTolerance = 0.01;
    ptbCones = ptbPhotoreceptors.isomerizationAbsorptance';

    <span class="comment">% Create isetbio sensor object with human cones, and pull out quantal</span>
    <span class="comment">% efficiencies.</span>
    sensor = sensorCreate(<span class="string">'human'</span>);
    sensor = sensorSet(sensor,<span class="string">'size'</span>,oiGet(oi,<span class="string">'size'</span>));
    sensor = sensorSet(sensor,<span class="string">'noise flag'</span>,0);
    isetbioCones = sensorGet(sensor,<span class="string">'spectral qe'</span>);
    isetbioCones = isetbioCones(:,2:4);

    <span class="comment">% Compare with PTB</span>
    coneDifference = ptbCones-isetbioCones;
    coneMean = mean(isetbioCones(:));
    quantityOfInterest = coneDifference/coneMean;
    UnitTest.assertIsZero(quantityOfInterest,<span class="string">'Difference between PTB and isetbio quantal efficiencies'</span>,coneTolerance);

    UnitTest.validationData(<span class="string">'isetCones'</span>,isetbioCones);
    UnitTest.validationData(<span class="string">'ptbCones'</span>,ptbCones);
    UnitTest.extraData(<span class="string">'coneTolerance'</span>,coneTolerance);
</pre><h2>Compute quantal absorptions<a name="18"></a></h2><pre>Need to:
1) Get out L, M, S absorptions from the ROI where we get the spectrum
2) Compare with PTB computation done above.
3) Work through parameters that might lead to differences
  e.g., cone aperture, integration time, ...</pre><pre class="codeinput">    sensor = sensorSet(sensor, <span class="string">'exp time'</span>, integrationTimeSec);
    sensor = sensorCompute(sensor, oi);
    isetbioIsomerizationsArray = sensorGet(sensor,<span class="string">'photons'</span>);

    <span class="comment">% Pull out responses of each cone type within ROI. I am doing this by</span>
    <span class="comment">% brute force, because I can't find quite the right combination of ROI</span>
    <span class="comment">% gets from the sensor image.</span>
    <span class="comment">%</span>
    <span class="comment">% This code should be slicked up by an isetbio pro.  Do I have the</span>
    <span class="comment">% row/col indexing convention of the RoiLocs correct, or reversed?</span>
    sensorCFA = sensorGet(sensor,<span class="string">'cfa'</span>);
    nLocs = size(oiRoiLocs,1);
    sumIsomerizations = zeros(3,1);
    nSummed = zeros(3,1);
    <span class="keyword">for</span> jj = 1:nLocs
        coneType = sensorCFA.pattern(oiRoiLocs(jj,1),oiRoiLocs(jj,2))-1;
        sumIsomerizations(coneType) = sumIsomerizations(coneType)+isetbioIsomerizationsArray(oiRoiLocs(jj,1),oiRoiLocs(jj,2));
        nSummed(coneType) = nSummed(coneType) + 1;
    <span class="keyword">end</span>
    isetbioIsomerizations = sumIsomerizations ./ nSummed;
</pre><h2>Adjust answer for differences in collecting area in the two calculations<a name="19"></a></h2><p>PTB specifies cone aperture as the diameter of the inner segment and assumes a circular aperture, and allows separate specifciation for each cone type.  ISETBIO specifies square pixels, the same for each cone type as far as I can tell.</p><p>Since in both cases isomerizations are proportional to area, we can do the consistency check without too much fuss.</p><p>It's possible we should handle this by setting the areas to be the same in the two calculations, rather than post-correcting.</p><p>I checked by hand that the axial densities and quantal efficiences in the two calculations match.</p><pre class="codeinput">    ptbConeDiameter = mean(ptbPhotoreceptors.ISdiameter.value);
    <span class="keyword">if</span> (any(ptbPhotoreceptors.ISdiameter.value ~= ptbConeDiameter))
        UnitTest.validationRecord(<span class="string">'FUNDAMENTAL_CHECK_FAILED'</span>, <span class="string">'This calculation assumes all entries for PTB ISDiameter the same, but they are not.'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    ptbConeArea = pi*((ptbConeDiameter/2)^2);
    pixel = sensorGet(sensor,<span class="string">'pixel'</span>);
    isetbioConeArea = pixelGet(pixel,<span class="string">'width'</span>)*pixelGet(pixel,<span class="string">'width'</span>)*1e12;
    ptbAreaCorrectedIsomerizations = (isetbioConeArea/ptbConeArea)*ptbIsomerizations;
</pre><h2>Also need to correct for magnification difference<a name="20"></a></h2><p>This follows irradiance correction above.</p><pre class="codeinput">    ptbCorrectedIsomerizations = ptbAreaCorrectedIsomerizations/(1+abs(m))^2;

    isomerizationTolerance = 0.01;
    isomerizationDifference = ptbCorrectedIsomerizations-isetbioIsomerizations;
    quantityOfInterest = isomerizationDifference./ptbCorrectedIsomerizations;
    UnitTest.assertIsZero(quantityOfInterest,<span class="string">'Difference between PTB and isetbio isomerizations'</span>,isomerizationTolerance);

    <span class="comment">% Add validation data</span>
    UnitTest.extraData(<span class="string">'isomerizationTolerance'</span>,isomerizationTolerance);
    UnitTest.extraData(<span class="string">'isetIsomerizations'</span>,isetbioIsomerizations);
    UnitTest.extraData(<span class="string">'ptbIsomerizations'</span>,ptbIsomerizations);
    UnitTest.extraData(<span class="string">'ptbAreaCorrectedIsomerizations'</span>,ptbAreaCorrectedIsomerizations);
    UnitTest.extraData(<span class="string">'ptbCorrectedIsomerizations'</span>,ptbCorrectedIsomerizations);
    UnitTest.extraData(<span class="string">'ptbConeArea'</span>,ptbConeArea);
    UnitTest.extraData(<span class="string">'isetbioConeArea'</span>,ptbConeArea);
    UnitTest.extraData(<span class="string">'ptbPhotoreceptors'</span>,ptbPhotoreceptors);

    <span class="comment">% Add extra data</span>
    UnitTest.extraData(<span class="string">'sensor'</span>,sensor);
</pre><h2>Plotting<a name="21"></a></h2><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.generatePlots)

        h = figure(500);
        clf;
        set(h, <span class="string">'Position'</span>, [100 100 800 600]);
        subplot(2,1,1);
        plot(wave, ptbIrradiance, <span class="string">'ro'</span>, <span class="string">'MarkerFaceColor'</span>, [1.0 0.8 0.8], <span class="string">'MarkerSize'</span>, 10);
        hold <span class="string">on</span>;
        plot(wave, isetbioIrradianceEnergy, <span class="string">'bo'</span>, <span class="string">'MarkerFaceColor'</span>, [0.8 0.8 1.0], <span class="string">'MarkerSize'</span>, 10);
        hold <span class="string">off</span>
        set(gca,<span class="string">'ylim'</span>,[0 1.2*max([max(ptbIrradiance(:)) max(isetbioIrradianceEnergy(:))])]);
        set(gca, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14,  <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
        legend({<span class="string">'PTB'</span>,<span class="string">'ISETBIO'</span>}, <span class="string">'Location'</span>,<span class="string">'SouthEast'</span>,<span class="string">'FontSize'</span>,12);
        xlabel(<span class="string">'Wave (nm)'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 16); ylabel(<span class="string">'Irradiance (q/s/nm/m^2)'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 16)
        title(<span class="string">'Without magnification correction'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 18, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);

        subplot(2,1,2);
        plot(wave,ptbMagCorrectIrradiance,<span class="string">'ro'</span>, <span class="string">'MarkerFaceColor'</span>, [1.0 0.8 0.8], <span class="string">'MarkerSize'</span>, 10);
        hold <span class="string">on</span>;
        plot(wave,isetbioIrradianceEnergy,<span class="string">'bo'</span>, <span class="string">'MarkerFaceColor'</span>, [0.8 0.8 1.0], <span class="string">'MarkerSize'</span>, 10);
        hold <span class="string">off</span>
        set(gca,<span class="string">'ylim'</span>,[0 1.2*max([max(ptbIrradiance(:)) max(isetbioIrradianceEnergy(:))])]);
        set(gca, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
        xlabel(<span class="string">'Wave (nm)'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14); ylabel(<span class="string">'Irradiance (q/s/nm/m^2)'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14)
        legend({<span class="string">'PTB'</span>,<span class="string">'ISETBIO'</span>}, <span class="string">'Location'</span>,<span class="string">'SouthEast'</span>,<span class="string">'FontSize'</span>,12)
        title(<span class="string">'Magnification-corrected comparison'</span>, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 18, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);

        <span class="comment">% Compare PTB sensor spectral responses with ISETBIO</span>
        vcNewGraphWin; hold <span class="string">on</span>;
        set(gca, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14,  <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
        plot(wave, isetbioCones(:,1),<span class="string">'ro'</span>, <span class="string">'MarkerFaceColor'</span>, [1.0 0.8 0.8], <span class="string">'MarkerSize'</span>, 10);
        plot(wave, ptbCones(:,1), <span class="string">'r-'</span>);
        plot(wave, isetbioCones(:,2),<span class="string">'go'</span>, <span class="string">'MarkerFaceColor'</span>, [0.8 1.0 0.8], <span class="string">'MarkerSize'</span>, 10);
        plot(wave, ptbCones(:,2), <span class="string">'g-'</span>);
        plot(wave, isetbioCones(:,3),<span class="string">'bo'</span>, <span class="string">'MarkerFaceColor'</span>, [0.8 0.8 1.0], <span class="string">'MarkerSize'</span>, 10);
        plot(wave, ptbCones(:,3), <span class="string">'b-'</span>);
        legend({<span class="string">'ISETBIO'</span>,<span class="string">'PTB'</span>},<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>,<span class="string">'FontSize'</span>,12);
        xlabel(<span class="string">'Wavelength'</span>);
        ylabel(<span class="string">'Quantal Efficiency'</span>)

        vcNewGraphWin; hold <span class="string">on</span>
        set(gca, <span class="string">'FontName'</span>, <span class="string">'Helvetica'</span>, <span class="string">'FontSize'</span>, 14,  <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
        plot(ptbCones(:),isetbioCones(:),<span class="string">'o'</span>,<span class="string">'MarkerSize'</span>, 10);
        plot([0 0.5],[0 0.5], <span class="string">'--'</span>);
        xlabel(<span class="string">'PTB cones'</span>);
        ylabel(<span class="string">'ISET cones'</span>);
        axis(<span class="string">'square'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="v_IrradianceIsomerizations_01.png" alt=""> <img vspace="5" hspace="5" src="v_IrradianceIsomerizations_02.png" alt=""> <img vspace="5" hspace="5" src="v_IrradianceIsomerizations_03.png" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = v_IrradianceIsomerizations(varargin)
%
% Validate ISETBIO-based irradiance/isomerization computations by comparing to PTB-based irradiance/isomerization computations.
%
% See also: v_Cones
%
% Minor issues:
%
% 1) The irradiance calculations agree to about 1%, once the difference in
% how isetbio and PTB compute degrees to mm of retina is taken into
% account. We are not sure of the reason for the 1% difference.  This may
% be related to the fact that the spatial uniformity of the optical image
% irradiance in isetbio is only good to about 1%, even though we think the
% optics are turned off in the computation.  A similar magnitude difference
% is seen in the isomerizations, which may have its roots in this same
% effect (since isomerizations are computed from the irradiance in each
% case), or in the slight differences in spectral qe below.
%
% 2) Isetbio and PTB agree to about a percent for quantal efficiencies, but
% not exactly, about the CIE 2-deg cone fundamentals, when converted to
% quantal efficiencies.  They agree better in v_Cones, I think.  Why?
%
% To do:
%
% 1) It might be good to vary some of the underlying parameters in both
% calculational paths and make sure that all of the parameters are have
% the expected and same effects in both cases.  Key parameters are lens and
% macular pigment density, pigment optical density, photopigment
% lambda-max, cone aperature area, photopigment quantal efficiency.  It is
% possible this should be done in v_Cones rather than here.
%
% 2) Check that integration over wavelength is being done consistently in
% isetbio and PTB.  PTB works by assuming that spectral power is per
% wavelength band.  Isetbio takes irrandiance in a per nm basis and explicitly
% includes the wavelength sampling step in its numerical integration.

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)
    
    %% Initialize ISETBIO
    s_initISET;
       
    %% Set computation params
    fov     = 20;  % need large field
    roiSize = 5;
        
    %% Create a radiance image in ISETBIO
    scene = sceneCreate('uniform ee');    % Equal energy
    scene = sceneSet(scene,'name','Equal energy uniform field');
    scene = sceneSet(scene,'fov', fov);
    
    %% Compute the irradiance in ISETBIO
    %
    % To make comparison to PTB work, we turn off
    % off axis correction as well as optical blurring
    % in the optics.
    oi     = oiCreate('human');
    optics = oiGet(oi,'optics');
    optics = opticsSet(optics,'off axis method','skip');
    optics = opticsSet(optics,'otf method','skip otf');
    oi     = oiSet(oi,'optics',optics);
    oi     = oiCompute(oi,scene);

    %% Define a region of interest starting at the scene's center with size
    % roiSize x roiSize
    sz = sceneGet(scene,'size');
    rect = [sz(2)/2,sz(1)/2,roiSize,roiSize];
    sceneRoiLocs = ieRoi2Locs(rect);
    
    %% Get wavelength and spectral radiance spd data (averaged within the scene ROI) 
    wave  = sceneGet(scene,'wave');
    radiancePhotons = sceneGet(scene,'roi mean photons', sceneRoiLocs);
    radianceEnergy  = sceneGet(scene,'roi mean energy',  sceneRoiLocs); 
    
    %% Check spatial uniformity of scene radiance data.
    % This also verifies that two ways of getting the same information out in isetbio give
    % the same answer.
    radianceData = vcGetROIData(scene,sceneRoiLocs,'energy');
    radianceEnergyCheck = mean(radianceData,1);
    if (any(radianceEnergy ~= radianceEnergyCheck))
        UnitTest.validationRecord('FUNDAMENTAL_CHECK_FAILED', 'Two ways of extracting mean scene radiance in isetbio do not agree.');
        return;
    end
    radianceUniformityErr = (max(radianceData(:)) - min(radianceData(:)))/mean(radianceData(:));
    uniformityRadianceTolerance = 0.00001;
    quantityOfInterest = radianceUniformityErr;
    UnitTest.assertIsZero(quantityOfInterest,'Spatial uniformity of scene radiance',uniformityRadianceTolerance);

    %% Get wavelength and spectral irradiance spd data (averaged within the scene ROI)
    % Need to recenter roi when computing from the optical image,
    % because the optical image is padded to deal with optical blurring at its edge.
    sz         = oiGet(oi,'size');
    rect       = [sz(2)/2,sz(1)/2,roiSize,roiSize];
    oiRoiLocs  = ieRoi2Locs(rect);
    if (any(wave-oiGet(scene,'wave')))
        UnitTest.validationRecord('FUNDAMENTAL_CHECK_FAILED', 'Wavelength sampling changed between scene and optical image.');
        return;
    end
    isetbioIrradianceEnergy = oiGet(oi,'roi mean energy', oiRoiLocs);
    
    %% Check spatial uniformity of optical image irradiance data.
    % With optics turned off, we think this should be perfect but it isn't.
    % It's good to 1%, but not to 0.1%.  This may be why PTB and isetbio
    % only agree to about 1%.
    %
    % This also verifies that two ways of getting the same information out
    % in isetbio give the same answer.
    irradianceData = vcGetROIData(oi,oiRoiLocs,'energy');
    irradianceEnergyCheck = mean(irradianceData,1);
    if (any(isetbioIrradianceEnergy ~= irradianceEnergyCheck))
        UnitTest.validationRecord('FUNDAMENTAL_CHECK_FAILED', 'Two ways of extracting mean optical image irradiance in isetbio do not agree.');
        return;
    end
    irradianceUniformityErr = (max(irradianceData(:)) - min(irradianceData(:)))/mean(irradianceData(:));
    uniformityIrradianceTolerance = 0.01;
    UnitTest.assertIsZero(irradianceUniformityErr, 'Spatial uniformity of optical image irradiance', uniformityIrradianceTolerance);
    UnitTest.extraData('irradianceData',irradianceData);
    UnitTest.extraData('irradianceUniformityErr',irradianceUniformityErr);
     
    %% Get the underlying parameters that are needed from the ISETBIO structures.
    optics = oiGet(oi,'optics');
    pupilDiameterMm  = opticsGet(optics,'pupil diameter','mm');
    focalLengthMm    = opticsGet(optics,'focal length','mm');
    
    %% Compute the irradiance in PTB
    % The PTB calculation is encapsulated in ptb.ConeIsomerizationsFromRadiance.
    % This routine also returns cone isomerizations, which we will use below to
    % to validate that computation as well.
    %
    % The macular pigment and integration time parameters affect the isomerizations,
    % but don't affect the irradiance returned by the PTB routine.
    % The integration time doesn't affect the irradiance, but we need to pass it 
    macularPigmentOffset = 0;
    integrationTimeSec   = 0.05;
    [ptbIsomerizations, ~, ptbPhotoreceptors, ptbIrradiance] = ...
        ptb.ConeIsomerizationsFromRadiance(radianceEnergy(:), wave(:),...
        pupilDiameterMm, focalLengthMm, integrationTimeSec,macularPigmentOffset);
    
    %% Compare irradiances computed by ISETBIO vs. PTB
    %
    % The comparison accounts for a magnification difference in the
    % computation of retinal irradiance.  The magnification difference
    % results from how Peter Catrysse implemented the radiance to
    % irradiance calculation in isetbio versus the simple trig formula used
    % in PTB. Correcting for this reduces the difference to about 1%
    % 
    % It might be useful here to explain how the correction factor is deterimend.
    % One assumes that the squaring deals with linear dimension to area.
    % Why the absolute value around the (m), however, is mysterious to DHB.
    m = opticsGet(optics,'magnification',sceneGet(scene,'distance'));
    ptbMagCorrectIrradiance = ptbIrradiance(:)/(1+abs(m))^2;
    
    %% Numerical check to decide whether we passed.
    % We are checking against a 1% error.  We also
    % store the computed values for future comparison via
    % our validation and check mechanism.
    tolerance = 0.01;
    ptbMagCorrectIrradiance = ptbMagCorrectIrradiance(:);
    isetbioIrradianceEnergy = isetbioIrradianceEnergy(:);
    difference = ptbMagCorrectIrradiance-isetbioIrradianceEnergy;
    quantityOfInterest = difference./isetbioIrradianceEnergy;
    UnitTest.assertIsZero(quantityOfInterest,'Difference between PTB and isetbio irradiance',tolerance);
    
    % Add validation data
    UnitTest.extraData('fov', fov);
    UnitTest.extraData('roiSize', roiSize);
    UnitTest.extraData('tolerance', tolerance);
    UnitTest.extraData('magCorrectionFactor',m);
    UnitTest.extraData('ptbMagCorrectIrradiance', ptbMagCorrectIrradiance);
    UnitTest.extraData('isetbioIrradianceEnergy',isetbioIrradianceEnergy);
    
    % Add extra data
    UnitTest.extraData('scene', scene);
    UnitTest.extraData('oi', oi);
    
    %% Compare spectral sensitivities used by ISETBIO and PTB.
    %
    % The PTB routine above uses the CIE 2-deg standard, which is the
    % Stockman-Sharpe 2-degree fundamentals.  Apparently, so does ISETBIO.
    % 
    % The agreement is good to about a percent.
    %
    % Get PTB cones spectral sensitivity, quantal units
    coneTolerance = 0.01;
    ptbCones = ptbPhotoreceptors.isomerizationAbsorptance';
    
    % Create isetbio sensor object with human cones, and pull out quantal
    % efficiencies. 
    sensor = sensorCreate('human');
    sensor = sensorSet(sensor,'size',oiGet(oi,'size'));
    sensor = sensorSet(sensor,'noise flag',0);
    isetbioCones = sensorGet(sensor,'spectral qe');
    isetbioCones = isetbioCones(:,2:4);
    
    % Compare with PTB
    coneDifference = ptbCones-isetbioCones;
    coneMean = mean(isetbioCones(:));
    quantityOfInterest = coneDifference/coneMean;
    UnitTest.assertIsZero(quantityOfInterest,'Difference between PTB and isetbio quantal efficiencies',coneTolerance);
    
    UnitTest.validationData('isetCones',isetbioCones);
    UnitTest.validationData('ptbCones',ptbCones);
    UnitTest.extraData('coneTolerance',coneTolerance);
   
    %% Compute quantal absorptions
    %  Need to:
    %  1) Get out L, M, S absorptions from the ROI where we get the spectrum
    %  2) Compare with PTB computation done above.
    %  3) Work through parameters that might lead to differences
    %    e.g., cone aperture, integration time, ...
    sensor = sensorSet(sensor, 'exp time', integrationTimeSec);
    sensor = sensorCompute(sensor, oi);
    isetbioIsomerizationsArray = sensorGet(sensor,'photons');
    
    % Pull out responses of each cone type within ROI. I am doing this by
    % brute force, because I can't find quite the right combination of ROI
    % gets from the sensor image.
    %
    % This code should be slicked up by an isetbio pro.  Do I have the
    % row/col indexing convention of the RoiLocs correct, or reversed?
    sensorCFA = sensorGet(sensor,'cfa');
    nLocs = size(oiRoiLocs,1);
    sumIsomerizations = zeros(3,1);
    nSummed = zeros(3,1);
    for jj = 1:nLocs
        coneType = sensorCFA.pattern(oiRoiLocs(jj,1),oiRoiLocs(jj,2))-1;
        sumIsomerizations(coneType) = sumIsomerizations(coneType)+isetbioIsomerizationsArray(oiRoiLocs(jj,1),oiRoiLocs(jj,2));
        nSummed(coneType) = nSummed(coneType) + 1;
    end
    isetbioIsomerizations = sumIsomerizations ./ nSummed;
    
    %% Adjust answer for differences in collecting area in the two calculations
    %
    % PTB specifies cone aperture as the diameter of the inner segment and
    % assumes a circular aperture, and allows separate specifciation for
    % each cone type.  ISETBIO specifies square pixels, the same for each
    % cone type as far as I can tell.
    %
    % Since in both cases isomerizations are proportional to area, we can
    % do the consistency check without too much fuss.
    %
    % It's possible we should handle this by setting the areas to be the
    % same in the two calculations, rather than post-correcting.
    %
    % I checked by hand that the axial densities and quantal efficiences in
    % the two calculations match.
    ptbConeDiameter = mean(ptbPhotoreceptors.ISdiameter.value);
    if (any(ptbPhotoreceptors.ISdiameter.value ~= ptbConeDiameter))
        UnitTest.validationRecord('FUNDAMENTAL_CHECK_FAILED', 'This calculation assumes all entries for PTB ISDiameter the same, but they are not.');
        return;
    end
    ptbConeArea = pi*((ptbConeDiameter/2)^2);
    pixel = sensorGet(sensor,'pixel');
    isetbioConeArea = pixelGet(pixel,'width')*pixelGet(pixel,'width')*1e12;
    ptbAreaCorrectedIsomerizations = (isetbioConeArea/ptbConeArea)*ptbIsomerizations;
    
    %% Also need to correct for magnification difference
    % This follows irradiance correction above.
    ptbCorrectedIsomerizations = ptbAreaCorrectedIsomerizations/(1+abs(m))^2;

    isomerizationTolerance = 0.01;
    isomerizationDifference = ptbCorrectedIsomerizations-isetbioIsomerizations;
    quantityOfInterest = isomerizationDifference./ptbCorrectedIsomerizations;
    UnitTest.assertIsZero(quantityOfInterest,'Difference between PTB and isetbio isomerizations',isomerizationTolerance);
    
    % Add validation data
    UnitTest.extraData('isomerizationTolerance',isomerizationTolerance);
    UnitTest.extraData('isetIsomerizations',isetbioIsomerizations);
    UnitTest.extraData('ptbIsomerizations',ptbIsomerizations);
    UnitTest.extraData('ptbAreaCorrectedIsomerizations',ptbAreaCorrectedIsomerizations);
    UnitTest.extraData('ptbCorrectedIsomerizations',ptbCorrectedIsomerizations);
    UnitTest.extraData('ptbConeArea',ptbConeArea);
    UnitTest.extraData('isetbioConeArea',ptbConeArea);
    UnitTest.extraData('ptbPhotoreceptors',ptbPhotoreceptors);
    
    % Add extra data
    UnitTest.extraData('sensor',sensor);    
 
    %% Plotting
    if (runTimeParams.generatePlots)

        h = figure(500);
        clf;
        set(h, 'Position', [100 100 800 600]);
        subplot(2,1,1);
        plot(wave, ptbIrradiance, 'ro', 'MarkerFaceColor', [1.0 0.8 0.8], 'MarkerSize', 10);
        hold on;
        plot(wave, isetbioIrradianceEnergy, 'bo', 'MarkerFaceColor', [0.8 0.8 1.0], 'MarkerSize', 10);
        hold off
        set(gca,'ylim',[0 1.2*max([max(ptbIrradiance(:)) max(isetbioIrradianceEnergy(:))])]);
        set(gca, 'FontName', 'Helvetica', 'FontSize', 14,  'FontWeight', 'bold');
        legend({'PTB','ISETBIO'}, 'Location','SouthEast','FontSize',12);
        xlabel('Wave (nm)', 'FontName', 'Helvetica', 'FontSize', 16); ylabel('Irradiance (q/s/nm/m^2)', 'FontName', 'Helvetica', 'FontSize', 16)
        title('Without magnification correction', 'FontName', 'Helvetica', 'FontSize', 18, 'FontWeight', 'bold');
    
        subplot(2,1,2);
        plot(wave,ptbMagCorrectIrradiance,'ro', 'MarkerFaceColor', [1.0 0.8 0.8], 'MarkerSize', 10);
        hold on;
        plot(wave,isetbioIrradianceEnergy,'bo', 'MarkerFaceColor', [0.8 0.8 1.0], 'MarkerSize', 10);
        hold off
        set(gca,'ylim',[0 1.2*max([max(ptbIrradiance(:)) max(isetbioIrradianceEnergy(:))])]);
        set(gca, 'FontName', 'Helvetica', 'FontSize', 14, 'FontWeight', 'bold');
        xlabel('Wave (nm)', 'FontName', 'Helvetica', 'FontSize', 14); ylabel('Irradiance (q/s/nm/m^2)', 'FontName', 'Helvetica', 'FontSize', 14)
        legend({'PTB','ISETBIO'}, 'Location','SouthEast','FontSize',12)
        title('Magnification-corrected comparison', 'FontName', 'Helvetica', 'FontSize', 18, 'FontWeight', 'bold');
        
        % Compare PTB sensor spectral responses with ISETBIO
        vcNewGraphWin; hold on; 
        set(gca, 'FontName', 'Helvetica', 'FontSize', 14,  'FontWeight', 'bold');
        plot(wave, isetbioCones(:,1),'ro', 'MarkerFaceColor', [1.0 0.8 0.8], 'MarkerSize', 10);
        plot(wave, ptbCones(:,1), 'r-');
        plot(wave, isetbioCones(:,2),'go', 'MarkerFaceColor', [0.8 1.0 0.8], 'MarkerSize', 10);
        plot(wave, ptbCones(:,2), 'g-');
        plot(wave, isetbioCones(:,3),'bo', 'MarkerFaceColor', [0.8 0.8 1.0], 'MarkerSize', 10);
        plot(wave, ptbCones(:,3), 'b-');
        legend({'ISETBIO','PTB'},'Location','NorthWest','FontSize',12);
        xlabel('Wavelength');
        ylabel('Quantal Efficiency')

        vcNewGraphWin; hold on
        set(gca, 'FontName', 'Helvetica', 'FontSize', 14,  'FontWeight', 'bold');
        plot(ptbCones(:),isetbioCones(:),'o','MarkerSize', 10);
        plot([0 0.5],[0 0.5], 'REPLACE_WITH_DASH_DASH');
        xlabel('PTB cones');
        ylabel('ISET cones');
        axis('square');
    end 
end
##### SOURCE END #####
--></body></html>