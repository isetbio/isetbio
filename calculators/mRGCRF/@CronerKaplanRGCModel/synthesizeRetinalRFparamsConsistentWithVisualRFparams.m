function synthesizedRFParams = synthesizeRetinalRFparamsConsistentWithVisualRFparams(obj, ...
    rfCenterInputConesNum, rfCenterPositionMicrons, deconvolutionOpticsParams)
% Returns a struct with corresponding retinal <-> visual parameter of
% center/surround characteristic radii & peak sensitivities. These
% are computed from the retinal RF center size and position as determined
% by the connectivity matrix between the cone mosaic and the mRGC RF
% mosaic. The correspondence between retinal <-> visual parameters is build
% based on a deconvolution model (computed based on the various deconvolution files
% which are generated via obj.generatePolansOpticsDeconvolutionFiles()).
% 
    % Validate deconvolutionOpticsParams
    obj.validateDeconvolutionOpticsParams(deconvolutionOpticsParams);
    
    % Compute the deconvolution model. This relies on the various
    % ecc_-%2.1f_deconvolutions_refractionError_%2.2fD.mat data files that
    % are generated by obj.generatePolansOpticsDeconvolutionFiles(deconvolutionOpticsParams)
    % See performPSFConvoComputations

    deconvolutionModel = obj.computeDeconvolutionModel(deconvolutionOpticsParams);

    % Convert RF center positions in retinal microns to visual degs
    rfEccRadiusMicrons = (sqrt(sum(rfCenterPositionMicrons.^2,2.0)));
    rfEccRadiusDegs = WatsonRGCModel.rhoMMsToDegs(rfEccRadiusMicrons/1000.0);
    
    % Find interpolation weights for the center deconvolution
    % Sort the tabulated eccentricities
    tabulatedEccentricityRadiiDegs = sort(deconvolutionModel.center.tabulatedEccentricityRadii);
    
    % Compute interpolation indices and weights from tabulated data in
    % nearby eccentricities. Note: The deconvolution data are obtained for
    % horizontal eccentricities (ecc.x) with ecc.y = 0. Here we are using
    % the cell's ecc radius = sqrt(ecc.x^2 + ecc.y^2)
    rgcEccentricitiesToConsider = rfEccRadiusDegs;
    clear 'rfEccRadiusDegs';
    
    % Here we are using the horizontal eccentricites
    rgcEccentricitiesToConsider = WatsonRGCModel.rhoMMsToDegs(1e-3*squeeze(rfCenterPositionMicrons(:,1)));
    
    [interpolationEccIndices, interpolationEccWeights] = computeInterpolationIndices(...
        'center', 'eccentricities', tabulatedEccentricityRadiiDegs, ...
        rgcEccentricitiesToConsider);
    
    % Memory allocation
    rgcsNum = size(rfCenterPositionMicrons,1);
    centerVisualCharacteristicRadiiDegs = zeros(rgcsNum,1);
    centerVisualPeakSensitivityAttenuation = zeros(rgcsNum,1);
    
    % Use the deconvolutionModel.center to determine:
    % (a) the center's VISUAL characteristic radius based on the number of input cones to this cells' RF center, and 
    % (b) the center's visual peak sensitivity attenuation factor
    for RGCindex = 1:rgcsNum
        inputConesNum = rfCenterInputConesNum(RGCindex);
        % Retrieve the interpolation indices and interpolation weights for
        % weighing characteristic radii from the 2 closest eccentricities
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        weightsOfNeighboringEccs = interpolationEccWeights(RGCindex,:);
        
        % Retrieve the corresponding characteristic radii for the 2 nearby eccentricities
        characteristicRadiusDegsAtNeihboringEccs = zeros(1,numel(neighboringEccIndices));
        peakSensitivitiesAtNeihboringEccs = zeros(1,numel(neighboringEccIndices));
        for k = 1:numel(neighboringEccIndices)
            % Find the coneInputIndex corresponding to the # of cones in this RF center
            coneInputsIndex = find(deconvolutionModel.center.centerConeInputsNum(neighboringEccIndices(k),:) == inputConesNum);
            characteristicRadiusDegsAtNeihboringEccs(k) = deconvolutionModel.center.characteristicRadiusDegs(neighboringEccIndices(k),coneInputsIndex);
            % Retrieve the peak sensitivities (ratio of retinal-to-visual peak sensitivity) for the 2 nearby eccentricities
            peakSensitivitiesAtNeihboringEccs(k) = deconvolutionModel.center.peakSensitivity(neighboringEccIndices(k),coneInputsIndex);
        end
        
        % Set the cell's characteristic radius as the weighted mean of the 2 nearby characteristic radii
        centerVisualCharacteristicRadiiDegs(RGCindex) = sum(characteristicRadiusDegsAtNeihboringEccs .* weightsOfNeighboringEccs,2);
        
        % Compute the attenuation in peak sensitivity (due to the low-pass filtering of the optics, 
        % the visual image of a cone has lower peak amplitude than the retinal image of that cone)
        centerVisualPeakSensitivityAttenuation(RGCindex) = 1 / sum(peakSensitivitiesAtNeihboringEccs .* weightsOfNeighboringEccs,2);
    end
    
    % Use the Croner&Kaplan model centerPeakSensitivityFunction() to
    % compute the center VISUAL peak sensitivity from the center's VISUAL
    % characteristic radius 
    centerVisualPeakSensitivities = obj.centerPeakSensitivityFunction(obj.centerPeakSensitivityParams, centerVisualCharacteristicRadiiDegs);
    
    % To extract the RETINAL peak sensitivity, multiply the Croner&Kaplan estimate of the visual peak sensitivity
    % by the centerVisualPeakSensitivityAttenuation (estimated by the deconvolution model)
    centerRetinalPeakSensitivities = centerVisualPeakSensitivities .* centerVisualPeakSensitivityAttenuation;
    
    % Having determined the center VISUAL characteristic radius, we use the Croner&Kaplan model center-to-surround ratio function to
    % compute the surround VISUAL characteristic radius 
    surroundVisualCharacteristicRadiiDegs = CronerKaplanRGCModel.surroundRadiusFromCenterRadiusDegs(centerVisualCharacteristicRadiiDegs);

    % Next, we use the Croner&Kaplan model surround to center integrated
    % VISUAL sensitivity ratio to compute the surround VISUAL peak sensitivity
    surroundVisualPeakSensitivities = ...
        CronerKaplanRGCModel.surroundToCenterIntegratedVisualSensitivityRatiosFromEccDegs(rgcEccentricitiesToConsider) .* ...
        centerVisualPeakSensitivities ./ ...
        ((surroundVisualCharacteristicRadiiDegs./centerVisualCharacteristicRadiiDegs).^2);
    
    % In the final step, we compute the surround RETINAL characteristic radius and peak sensitivity 
    % using the deconvolutionModel.surround
    surroundRetinalCharacteristicRadiiDegs = zeros(rgcsNum,1);
    surroundPeakSensitivityAttenuation = zeros(rgcsNum,1);
    
    for RGCindex = 1:rgcsNum
        inputConesNum = rfCenterInputConesNum(RGCindex);
        % Retrieve the interpolation indices and interpolation weights for
        % weighing characteristic radii from the 2 closest eccentricities
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        weightsOfNeighboringEccs = interpolationEccWeights(RGCindex,:);
        
        % We have computed deconvolution properties for a number of
        % surround radii. Lets find the 2 closest surrounds
        retinalCharacteristicRadiusEstimates = zeros(1,2);
        visualGainSensitivities = zeros(1,2);
        
        for k = 1:numel(neighboringEccIndices)
            % Find the coneInputIndex corresponding to the # of cones in this RF center
            coneInputsIndex = find(deconvolutionModel.center.centerConeInputsNum(neighboringEccIndices(k),:) == inputConesNum);
            
            % determine interpolation weights for 2 closest surround characteristic radii
            nonNanIndices = find(~isnan(squeeze(deconvolutionModel.surround.characteristicRadiusDegs(neighboringEccIndices(k),coneInputsIndex,:))));
            if (isempty(nonNanIndices))
                error('We have no surround data for centers with %d cone inputs', inputConesNum);
            end
            
            % The surround radii that were examined in the deconvolution model
            examinedVisualCharacteristicRadii = squeeze(deconvolutionModel.surround.characteristicRadiusDegs(neighboringEccIndices(k),coneInputsIndex,nonNanIndices));
            
            % Determine interpolation indices and weights for the 2 closest surround sizes
            [interpolationSurroundRadiiIndices, interpolationSurroundRadiiWeights] = computeInterpolationIndices(...
                'surround', 'radii', examinedVisualCharacteristicRadii, surroundVisualCharacteristicRadiiDegs(RGCindex));
            
            % Mean (across 2 nearby examined surround radii) retinal characteristic radius
            examinedRetinalCharacteristicRadii = ...
                squeeze(deconvolutionModel.surround.nominalSurroundRetinalCharacteristicRadii(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            retinalCharacteristicRadiusEstimates(k) = sum(examinedRetinalCharacteristicRadii' .* interpolationSurroundRadiiWeights,2);
            
            % Mean (across 2 nearby examined surround radii) peak sensitities  (ratio of retinal-to-visual peak sensitivity)
            examinedVisualPeakSensitivities = ...
                squeeze(deconvolutionModel.surround.peakSensitivity(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            visualGainSensitivities(k) = sum(examinedVisualPeakSensitivities' .* interpolationSurroundRadiiWeights,2);
        end
        
        % Weighted retinal characteristic radius (according to the 2 neighboring eccentricities) estimates
        surroundRetinalCharacteristicRadiiDegs(RGCindex) = sum(retinalCharacteristicRadiusEstimates .* interpolationEccWeights(RGCindex,:),2);
        
        % Compute the attenuation in peak sensitivity (due to the low-pass filtering of the optics, 
        % the visual image of a cone has lower peak amplitude than the retinal image of that cone)
        surroundPeakSensitivityAttenuation(RGCindex) = 1 / sum(visualGainSensitivities .* weightsOfNeighboringEccs,2); 
    end
    
    % To extract the RETINAL peak sensitivity, multiply the Croner&Kaplan estimate of the visual peak sensitivity
    % by the surround VisualPeakSensitivityAttenuation (estimated by the deconvolution model)
    surroundRetinalPeakSensitivities = surroundVisualPeakSensitivities .* surroundPeakSensitivityAttenuation;
    
    % Compute surround radius in retinal microns
    surroundRetinalCharacteristicRadiiMicrons = WatsonRGCModel.sizeDegsToSizeRetinalMicrons(surroundRetinalCharacteristicRadiiDegs, rgcEccentricitiesToConsider);
    
    synthesizedRFParams = struct(...
        'rfEccRadiusDegs', rgcEccentricitiesToConsider, ...                                     % ecc of RGCs within the target patch  - DONE
        'rfCenterPositionMicrons', rfCenterPositionMicrons, ...
        'visual', struct(...                                                        % VISUAL RF properties
            'centerCharacteristicRadiiDegs', centerVisualCharacteristicRadiiDegs, ...             
            'surroundCharacteristicRadiiDegs', surroundVisualCharacteristicRadiiDegs, ...         
            'centerPeakSensitivities', centerVisualPeakSensitivities,...            
            'surroundPeakSensitivities', surroundVisualPeakSensitivities...          
            ), ...
         'retinal', struct(...                                                      % RETINAL RF properties  
             'centerCharacteristicRadiiDegs', nan(size(surroundRetinalCharacteristicRadiiDegs)), ...  % there is no retinal center characteristic radius
             'surroundCharacteristicRadiiDegs', surroundRetinalCharacteristicRadiiDegs, ...          
             'surroundCharacteristicRadiiMicrons', surroundRetinalCharacteristicRadiiMicrons, ...
             'centerPeakSensitivities', centerRetinalPeakSensitivities,... 
             'surroundPeakSensitivities', surroundRetinalPeakSensitivities... 
            )...
         );
end

function  [interpolationIndices, interpolationWeights] = computeInterpolationIndices(...
        subregionName, domainName, tabulatedValues, targetValues)
    

    % Determine linear interpolation indices and interpolation values
        
    targetsNum = numel(targetValues);
    interpolationWeights = zeros(targetsNum,2);
    interpolationIndices = zeros(targetsNum,2);
    
    for targetIndex = 1:targetsNum
        
        % Find the index of the tabulated values that is greater or equal to the target value
        targetValue = targetValues(targetIndex);
        idxPos = find(tabulatedValues >= targetValue);
        if (isempty(idxPos))
            fprintf(2,'Deconvolution data for %s do not extend up to %2.3f %s. Max value: %2.3f.\n', ...
                subregionName,  targetValues(targetIndex), domainName, max(tabulatedValues));
            idxPos = length(tabulatedValues);
        end
        
        % Find the index of the tabulated values that is greater or equal to the target value
        idxNeg = find(tabulatedValues <= targetValue);
        if (isempty(idxNeg))
            fprintf(2,'Deconvolution data for %s  do not extend down to %2.3f %s. Min value: %2.3f.\n', ...
                subregionName, targetValues(targetIndex), domainName, min(tabulatedValues));
            idxNeg = 1;
        end
        
        % Intepolation eccentricity indices for this cell
        interpolationIndices(targetIndex,:) = [idxNeg(end) idxPos(1)];
        
        % Compute interpolation weights based on the distance of the target
        % value to the 2 intepolation values
        interpolationValues = tabulatedValues(interpolationIndices(targetIndex,:));
        interpolationValueRange = abs(diff(interpolationValues));
        
        if (interpolationIndices(targetIndex,1) == interpolationIndices(targetIndex,2))
            interpolationWeights(targetIndex,:) = [0.5 0.5];
        else 
            eccDiffs = abs(interpolationValues - targetValue);
            % Interpolation weights
            interpolationWeights(targetIndex,:) = [eccDiffs(2) eccDiffs(1)]/interpolationValueRange;
        end
        
        
%         fprintf('interpolation: cell at %2.2f, below/above: %2.2f, %2.2f: weights: (%2.2f,%2.2f)  \n', ...
%             targetValue, ...
%             tabulatedValues(interpolationIndices(targetIndex,1)), ...
%             tabulatedValues(interpolationIndices(targetIndex,2)), ...
%             interpolationWeights(targetIndex,1), interpolationWeights(targetIndex,2));
    end
end